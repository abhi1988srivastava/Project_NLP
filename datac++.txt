#include <iostream>  // need this header file to support the C++ I/O system
using namespace std; // telling the compiler to use namespace "std",
		     // where the entire C++ library is declared.
	
int main()
{
        // Print out a sentence on the screen.
        // "<<" causes the expression on its right to 
        // be directed to the device on its left.
        // "cout" is the standard output device -- the screen.
	cout << "Hello World!" <<  endl;
	return 0; // returns 0,which indicate the successful	
		  // termination of the "main" function 
		     
}

#include <iostream>
using namespace std;
// declaring a constant.  It's value cannot be changed.
const int CONST_VAL = 5;        
int main()
{
	int    iValue;  // An integer variable
	float  fValue;  // A floating point variable
	char   cValue;  // A character variable
	
	iValue = 1234;    // Assigns 1234 to iValue
	fValue = 1234.56; // Assigns 1234.56 to fValue
	cValue = 'A';     // Assigns A to cValue
	
	// Now print them out on the screen:
	cout << "Integer value is: " << iValue << endl;
	cout << "Float value is: " << fValue <<  endl;
	cout << "Character value is: " << cValue << endl;
	cout << "The constant is: " << CONST_VAL << endl;
	
	return 0;
}

#include <iostream>
using namespace std;

int main()
{
  float gallons, liters;

  cout << "Enter number of gallons: ";
  cin >> gallons; // Read the inputs from the user

  liters = gallons * 3.7854; // convert to liters

  cout << "Liters: " << liters << endl; 

  return 0;
}

#include "Absolute.h" // This header file contains the function prototype
int Abs(int i)
{
	if( i >= 0)
		return i;
	else
		return -i;
}

int main()
{
	int number;
	int abs_number;

	cout << "This program finds the absolute value of an integer." << endl;
	cout << "Enter an integer (positive or negative): ";
	cin >> number;
	
	abs_number = Abs(number);
	cout << "The absolute value of " << number << " is " << abs_number;
	cout << endl;
	return 0;
}


#include <iostream>
using namespace std;

int main()
{
	// declare an integer and a float variable
	int IntNum; 
	float FloatNum;
	
	// declare integer and float pointers
	int *pIntNum;
	float *pFloatNum;
	
	// initialize the integer and float variables
	IntNum = 10;
	FloatNum = 12.34;
	
	// store addresses in pointers
	pIntNum = &IntNum;
	pFloatNum = &FloatNum;

	// print out the original values
        cout << "Before increment: " << endl;
	cout << "\t IntNum is: " << IntNum << endl;
	cout << "\t FloatNum is: " << FloatNum << endl;
	
	// note that we need to dereference a pointer in order
	// to extract the value it contains.
	cout << "\t pIntNum contains: " << *pIntNum << endl;
	cout << "\t pFloatNum contains: " << *pFloatNum << endl;

	// increment values of the integer and float variables 
	(*pIntNum)++;  // dereference and then increment
	(*pFloatNum)++;

	// print out the values after increment
        cout << "After increment: " << endl;
	cout << "\t IntNum is: " << IntNum << endl;
	cout << "\t FloatNum is: " << FloatNum << endl;

	cout << "\t pIntNum contains: " << *pIntNum << endl;
	cout << "\t pFloatNum contains: " << *pFloatNum << endl;

	return 0;
}

#include <iostream>
#include <stdio.h> // use <cstdio> for newer compilers.
using namespace std;

int main()
{
	// a pointer to char is initialized with a string literal
	char *Buffer = "Dummy content.";
	
	cout << "Original content of Buffer:--> " << Buffer << endl;
	cout << "Enter a sentense: " << endl;

	// use gets() to get the whole line.
	// cout would only get the first word.
	gets(Buffer);
	cout << "Now the Buffer contains:--> " << endl;
	cout << Buffer << endl;
	return 0;
}


#include <iostream>
using namespace std;

int main()
{
	int	IntArray[10]; // array of int
	int 	*pInt;        // pointer to int
	int	i;            // loop counter

	// populate the int array with 1, 2, 3, ...
	for(i = 0; i < 10; i++)
	{
		IntArray[i] = i+1;
	}

	// store the address of the first element of IntArray 
	//in pointer
	pInt = IntArray;

	// print out values in the int array
	for (i = 0; i < 10; i++)
	{
		cout << *pInt << ' ' ;
		pInt++;      // pointer arithmetic
		// the above two lines could also be replaced with:
		// cout << *(pInt++) << ' ' ;
	}
	cout << endl;
	return 0;
}

#include <iostream>
#include <stdio.h>
using namespace std;

int main()
{
	// initialize an array of char pointers with five fortunes
	const char* const Fortune[5] = 
	         {" Earth is a great funhouse without the fun.",
		  " There is always more hell that needs raising.",
		  " Confession is good for the soul, but bad for the career.",
		  " Live in a world of your own, but always welcome visitors.",
		  " The man who laughs has not yet been told the terrible news."
		  };
	cout << "Here are the 5 fortunes: " << endl;
	for(int i = 0; i < 5; i++)
	{
		cout << Fortune[i] << endl;
	}

	
}
#include <iostream>
using namespace std;

class cl {
  int i; // private by default
public:
  int get_i();
  void put_i(int j);
};

int cl::get_i()
{
  return i;
}

void cl::put_i(int j)
{
  i = j;
}

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i() <<endl;

  return 0;
}

#include <iostream>
using namespace std;

// Class to represent a box
class Box
{
  public:
    double length;
    double breadth;
    double height;

    // Constructor
    Box(double lengthValue, double breadthValue, double heightValue)
    {
      cout << "Box constructor called" << endl;
      length = lengthValue;
      breadth = breadthValue;
      height = heightValue;
    }

    // Function to calculate the volume of a box
    double volume()
    {
      return length * breadth * height;
    }
};
#include <iostream>
using namespace std;

// Class to represent a box
class Box
{
  public:
    double length;
    double breadth;
    double height;

    // Inline initialization
    Box(double lv = 1.0, double bv = 1.0, double hv = 1.0):length(lv),
                                                           breadth(bv),
                                                           height(hv)
    {
      cout << "Box constructor called" << endl;
    }

    // Function to calculate the volume of a box
    double volume()
    {
      return length * breadth * height;
    }
};

int main()
{
  Box firstBox(80.0, 50.0, 40.0);

  // Calculate the volume of the box
  double firstBoxVolume = firstBox.volume();
  cout << endl;
  cout << "Size of first Box object is "
       << firstBox.length  << " by "
       << firstBox.breadth << " by "
	<< firstBox.height
       << endl;
  cout << "Volume of first Box object is " << firstBoxVolume
       << endl;

  return 0;
}
#include <iostream>
#include <cstdlib>
using namespace std;

class myclass {
  int *p;
public:
  myclass(int i);
  ~myclass();
  int getval() { return *p; }
};

myclass::myclass(int i)
{
  cout << "Allocating p\n";
  p = new int;
  if(!p) {
    cout << "Allocation failure.\n";
    exit(1); // exit program if out of memory
  }

  *p = i;
}

myclass::~myclass()
{
  cout << "Freeing p\n";
  delete p;
}

// when this function is called, the copy constructor is called
void display(myclass ob)
{
  cout << ob.getval() << '\n';
}

int main()
{
  myclass a(10);

  display(a);

  return 0;
}
#include <iostream>
#include <stdlib.h> //for newer compilers, include <cstdlib>
using namespace std;

int main()
{
	char name[32]; // big enough to hold 32 characters

	// prompt for the name
	cout << "What's your name?" << endl;
	gets(name); // read a string from the key board.
	cout << "Hello! " << name << "!"  << endl;

	return 0;
}

#include <iostream>
using namespace std;

int main()
{
  // C++ allows for the initialization of arrays.  In the following,
  // we are initializing a 10x2 integer array. After initialization,
  // sqrs[0][0] = 1
  // sqrs[0][1] = 1
  // sqrs[1][0] = 2
  // sqrs[1][1] = 4 
  // and so on
  int sqrs[10][2] = { 
         {1, 1}, 
	 {2, 4}, // The square of 2 is 4,and so on
	 {3, 9}, 
	 {4, 16}, 
	 {5, 25}, 
	 {6, 36}, 
	 {7, 49}, 
	 {8, 64}, 
	 {9, 81}, 
	 {10, 100} 
  };

  int i, j;

  cout << "Enter a number between 1 and 10: ";
  cin >> i;

  // look up i
  for(j = 0; j < 10; j++) 
    if(sqrs[j][0] == i) break; // break from loop if i is found 
  cout << "The square of " << i << " is " ;
  cout << sqrs[j][1] << endl;

  return 0;
}
#include <iostream>
using namespace std;

// function prototyping
int menu();    // funciton to display the menu
void enter();  // function to enter info
void report(); // function to print report

// Global variables:
char name[2][80];  // this array holds employee names
char phone[2][20]; // their phone numbers
float hours[2];    // hours worked per week
float wage[2];     // wage
int choice;

int main()
{
  do {
    choice = menu(); // get selection
    switch(choice) {
      case 0: break;
      case 1: enter();
        break;
      case 2: report();
        break;
      default: cout << "Try again.\n\n";
    }
  } while(choice != 0);

  return 0;
}

// Return a user's selection.
int menu()
{
  int choice;

  cout << "0. Quit\n";
  cout << "1. Enter information\n";
  cout << "2. Report information\n";
  cout << "\nChoose one: ";
  cin >> choice;

  return choice;
}

// Enter information.
void enter()
{
  int i;
  for(i=0; i<2; i++) {
    cout << "Enter last name: ";
    cin >> name[i];
    cout << "Enter phone number: ";
    cin >> phone[i];
    cout << "Enter number of hours worked: ";
    cin >> hours[i];
    cout << "Enter wage: ";
    cin >> wage[i];
  }
}

// Display report.
void report()
{
  int i;

  for(i=0; i<2; i++) {
    cout << name[i] << ' ' << phone[i] << '\n';
    cout << "Pay for the week: " << wage[i] * hours[i];
    cout << '\n';
  }
}
#include <iostream>
using namespace std;

int main()
{
  int a, b;

  cout << "Enter first number: ";
  cin >> a;
  cout << "Enter second number: ";
  cin >> b;

  if(a < b) 
	  cout << "First number is less than second.\n";

  return 0;
}
#include <iostream>
using namespace std;

int main()
{
  int a, b;

  cout << "Enter first number: ";
  cin >> a;
  cout << "Enter second number: ";
  cin >> b;

  if(a < b) 
	  cout << "First number is less than second.\n";
  else
	  cout << "First number is greater than or equal to second.\n";

  return 0;

}
#include <iostream>
// <cstdlib> is needed in order to use the rand().
// For older compilers, use <stdlib.h>
#include <stdlib.h> 
using namespace std;

int main()
{
  int magic;  // magic number
  int guess;  // user's guess

  magic = rand(); // get a random number
  
  cout << "Enter your guess: ";
  cin >> guess;

  if(guess == magic) 
	  // Notice the "==" operator, which compares two values.   
	  cout << "** Right **";
  cout << "The magic number was: " << magic << endl;
  return 0;
}
#include <iostream>
#include <math.h> // for newer compilers, use <cmath>
using namespace std;

int main()
{
  int num;
  double sq_root;

  for(num=1; num < 10; num++) {
    sq_root = sqrt((double) num); //casting num from integer to double 
    				  // then taking its square root
    cout << num << "  " << sq_root << '\n';
  }

  return 0;
}

#include <iostream>
// <cstdlib> is needed in order to use the rand().
// For older compilers, use <stdlib.h>
#include <stdlib.h> 
using namespace std;

int main()
{
  int magic;  // magic number
  int guess;  // user's guess

  cout << "I will come up with a magic number between 0 and 9 ";
  cout << "and ask you to guess it." << endl;

  magic = rand()%10; // get a random number between 0 and 9
  
  cout << "Enter your guess: ";
  cin >> guess;

  while (guess != magic)  // as long as guess is incorrect
  {
	  if(guess > magic)
	  {
	          cout << "Too big! Guess again..." << endl;
	  }
	  else            // guess is less than magic
	  {
		  cout << "Too small! Guess again..." << endl;
	  }
	  cin >> guess;
  }
  cout << "You are RIGHT!" << endl;;
  return 0;
}
#include <iostream>
using namespace std;

int main()
{
	int choice;

	cout << "Enter an integer number: 1 - 5 " ;
	cin >> choice;

	switch (choice)
	{
		case 1:
		   cout << "You entered 1.";
		   break;
		case 2:
		   cout << "You entered 2.";
		   break;
		case 3:
		   cout << "You entered 3.";
		   break;
		case 4:
		   cout << "You entered 4.";
		   break;
		case 5:
		   cout << "You entered 5.";
		   break;
		default:
		   cout << "Invalid input.";
	}

	return 0;

}
#include <iostream>
using namespace std;

int main()
{
	int choice;

	cout << "Enter an integer number: 1 - 5 " ;
	cin >> choice;

	switch (choice)
	{
		case 1:
		   cout << "You entered 1.";
		   break;
		case 2:
		   cout << "You entered 2.";
		   break;
		case 3:
		   cout << "You entered 3.";
		   break;
		case 4:
		   cout << "You entered 4.";
		   break;
		case 5:
		   cout << "You entered 5.";
		   break;
		default:
		   cout << "Invalid input.";
	}

	return 0;

}
#include <iostream>
using namespace std;

class base {
protected:
  int i, j; // private to base, but accessible to derived
public:
  void set(int a, int b) { i = a; j = b; }
  void show() { cout << i << " " << j << "\n"; }
};

class derived : public base {
  int k;
public:
  // derived may access base's i and j
  void setk() { k = i*j; }

  void showk() { cout << k << "\n"; }
};

int main()
{
  derived ob;

  ob.set(2, 3); // OK, known to derived
  ob.show();    // OK, known to derived

  ob.setk();
  ob.showk();

  return 0;
}
#include <iostream>
using namespace std;

class base {
  int i;
protected:
  int j;
public:
  int k;
  void seti(int a) { i = a; }
  int geti() { return i; }
};

// Inherit base as protected.
class derived : protected base {
public:
  void setj(int a) { j = a; } // j is protected here
  void setk(int a) { k = a; } // k is also protected
  int getj() { return j; }
  int getk() { return k; }
};

int main()
{
  derived ob;

  /* This next line is illegal because seti() is
     a protected member of derived, which makes it
     inaccessible outside of derived. */
//  ob.seti(10);

//  cout << ob.geti(); // illegal -- geti() is protected
//  ob.k = 10; // also illegal because k is protected

  // these next statements are OK
  ob.setk(10);
  cout << ob.getk() << ' ';
  ob.setj(12);
  cout << ob.getj() << ' ';

  return 0;
}
#include <iostream>
using namespace std;

class base1 {
protected:
  int x;
public:
  void showx() { cout << x << "\n"; }
};

class base2 {
protected:
  int y;
public:
  void showy() { cout << y << "\n"; }
};

// Inherit multiple base classes.
class derived: public base1, public base2 {
public:
  void set(int i, int j) { x = i; y = j; }
};

int main()
{
  derived ob;

  ob.set(10, 20); // provided by derived
  ob.showx();     // from base1
  ob.showy();     // from base2

  return 0;
}
#include <iostream>
using namespace std;

class base1 {
protected:
  int i;
public:
  base1(int x) { i = x; cout << "Constructing base1\n"; }
  ~base1() { cout << "Destructing base2\n"; }
};

class base2 {
protected:
  int k;
public:
  base2(int x) { k = x; cout << "Constructing base2\n"; }
  ~base2() { cout << "Destructing base2\n"; }
};

class derived: public base1, public base2 {
  int j;
public:
  derived(int x, int y, int z): base1(y), base2(z)
    { j = x; cout << "Constructing derived\n"; }

  ~derived() { cout << "Destructing derived\n"; }
  void show() { cout << i << " " << j << " " << k << "\n"; }
};

int main()
{
  derived ob(3, 4, 5);

  ob.show();  // displays 4 3 5

  return 0;
}
#include <iostream>
using namespace std;

int main()
{
	int number;
	int abs_number;

	// Ask for input
	cout << "This program finds the absolute value of an integer." << endl;
	cout << "Enter an integer (positive or negative): ";
	cin >> number;
	
	// Find the absolute value
	if(number >= 0)
	{
		abs_number = number;
	}
	else
		abs_number = -number;
	
	// Print out output
	cout << "The absolute value of " << number << " is " << abs_number;
	cout << endl;
	return 0;
}
int Abs(int i); // Function prototype
int main()
{
	int number;
	int abs_number;

	cout << "This program finds the absolute value of an integer." << endl;
	cout << "Enter an integer (positive or negative): ";
	cin >> number;
	
	// Calling the function Abs()
	abs_number = Abs(number);
	cout << "The absolute value of " << number << " is " << abs_number;
	cout << endl;
	return 0;
}
// Function definition
int Abs(int i)
{
	if( i >= 0)
		return i;
	else
		return -i;
}
#include <iostream>
using namespace std;

int main()
{
	float num[5] = {1.0, -1.2345, 2350.1, 23.4, 45.34};
	int i;

 	cout.setf(ios::showpos); // show the + sign before positive numbers
  	cout.setf(ios::scientific); // use scientific notation
  	cout.precision(2); // two digits after decimal point
	
	for(i = 0; i < 5; i++)
	{
  		cout.width(20);    // use 10 spaces for the number
		cout.fill('$');    // pad with $
  	    	cout << num[i] << endl;
	}

  return 0;
}
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
	float num[5] = {1.0, -1.2345, 2350.1, 23.4, 45.34};
	int i;

 	cout << setiosflags(ios::showpos);
	cout << setiosflags(ios::scientific); 
	cout << setprecision(2); 
	
	for(i = 0; i < 5; i++)
	{
  		cout << setw(20);    
  		cout << setfill('$');    
  	    	cout << num[i] << endl;
	}

  return 0;
}
#include <iostream>
#include <iomanip>
using namespace std;

// function prototype for a user-defined IO manipulator function
ostream &SetHex(ostream &stream);

int main()
{
	int input;
	cout << "Enter an integer: " ;
	cin  >> input;

	cout << "Hexdecimal is: ";
	
	// call the SetHex function so that the input
	// integer will be printed out in hexdecimal
	cout << SetHex << input << endl;
	return 0;
}

// definition of a user defined I/O manipulate function
ostream &SetHex(ostream &stream)
{
	// Set output base to be hexdecimal.
	// Use ios::basefield to make sure that all other
	// field in basefield is cleared before setting it
	// to hex.
	stream.setf(ios::hex,ios::basefield); 
	return stream;
}
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
	char OutFile[80]; // output file name
	ofstream OutStream;  // open an output stream
	
	cout << "Please enter output file name: " ;
	cin >> OutFile;

	OutStream.open(OutFile, ios::out | ios::trunc);
	
	// make sure file is successfully opened
	if(!OutStream)
	{
		cout << "Error open file " << OutFile << " for writing\n";
		return 1;
	}
	
	// Write the following two lines to file
	OutStream<<"It is easier to resist at the beginning than at the end.\n";
	OutStream <<"                 -- Leonardo da Vinci" << endl;

	OutStream.close(); // close output stream

	cout << "Content written to " << OutFile <<".\n";

	return 0;

}
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
	char InFile[80];  // input file name
	char ch;
	
	ifstream InStream;

	cout << "This program reads the content of a file and ";
	cout << "prints it out on the screen." << endl;

	cout << "Enter input file name: " ;
	cin >> InFile;

	// Open file for input
	// in.open(fin); also works
	InStream.open(InFile, ios::in);

	// ensure file is opened successfully
	if(!InStream)
	{
		cout << "Error open file " << InFile << endl;
		return 1;
	}
	
	cout << "Here is the content of " << InFile << ":\n";
	// Read in each character until eof character is read.
	// Output it to screen.
	while (!InStream.eof()) {
		//Read each character.
		InStream.get(ch);    

		// make sure we don't write any odd characters on screen
		if (!InStream.eof()) 
		{
			cout << ch;  //Write to screen
		}
	}

	InStream.close();
}
#include <iostream>
using namespace std;

int main()
{
        // Defining a structure
        struct PersonalData
        {
                char *FirstName;
                char *LastName;
                char *Birthday;  // in the format of 12/30/1978
                int  PhoneNum;
        }; // don't forget the ending ";"

        // Declaring a variable of type PersonalData
        PersonalData PersonOne;

        // Populate PersonOne with data
        PersonOne.FirstName = "John";
        PersonOne.LastName = "Doe";
        PersonOne.Birthday = "12/30/1978";
        PersonOne.PhoneNum = 5855555;

        // Print the data out
        cout << "PersonOne's First name is: " << PersonOne.FirstName << endl;
        cout << "PersonOne's Last name is: " << PersonOne.LastName<< endl;
        cout << "PersonOne's Birthday is: " << PersonOne.Birthday<< endl;
        cout << "PersonOne's Phone number is: " << PersonOne.PhoneNum<< endl;

        return 0;
}

#include <iostream>
using namespace std;

int main()
{
        // Defining a structure for name
        struct Name
        {
                char *FirstName;
                char *LastName;
        };

        struct PersonalData
        {
                Name NameField; // struct as a memeber
                char *Birthday;  // in the format of 12/30/1978
                int  PhoneNum;
        }; // don't forget the ending ";"

        // Declaring a variable of type PersonalData
        PersonalData PersonOne;


        PersonOne.NameField.FirstName = "John";
        PersonOne.NameField.LastName = "Doe";

        // Populate PersonOne with data
        PersonOne.Birthday = "12/30/1978";
        PersonOne.PhoneNum = 5855555;

        // Print the data out
        cout << "First name is: " << PersonOne.NameField.FirstName << endl;
        cout << "Last name is: " << PersonOne.NameField.LastName<< endl;
        cout << "Birthday is: " << PersonOne.Birthday<< endl;
        cout << "Phone number is: " << PersonOne.PhoneNum<< endl;

        return 0;
}
#include <iostream>
using namespace std;

int main()
{
        
        struct PersonalData
        {
                char *FirstName;
                char *LastName;
                char *Birthday;  // in the format of 12/30/1978
                int  PhoneNum;

                // struc can also have member functions
                void PrintDat()
                {
                        // Print the data out
                        cout << "First name is: " << FirstName << endl;
                        cout << "Last name is: " << LastName << endl;
                        cout << "Birthday is: " << Birthday << endl;
                        cout << "Phone number is: " << PhoneNum << endl;
                }
        }; // don't forget the ending ";"

        // Declaring a variable of type PersonalData
        PersonalData PersonOne;

        // Populate PersonOne with data
        PersonOne.FirstName = "John";
        PersonOne.LastName = "Doe";
        PersonOne.Birthday = "12/30/1978";
        PersonOne.PhoneNum = 5855555;

        PersonOne.PrintDat();
        return 0;
}
#include <iostream>
#include <cstring>
using namespace std;

class B_class {
  char author[80];
public:
  void put_author(char *s) { strcpy(author, s); }
  void show_author() { cout << author << "\n"; }
} ;

class D_class : public B_class {
  char title[80];
public:
  void put_title(char *num) {
    strcpy(title, num);
  }
  void show_title() {
    cout << "Title: ";
    cout <<  title << "\n";
  }
};

int main()
{
  B_class *p;
  B_class B_ob;

  D_class *dp;
  D_class D_ob;

  p = &B_ob;  // address of base

  // Access B_class via pointer.
  p->put_author("Tom Clancy");

  // Access D_class via base pointer.
  p = &D_ob;
  p->put_author("William Shakespeare");

  // Show that each author went into proper object.
  B_ob.show_author();
  D_ob.show_author();
  cout << "\n";

  /* Since put_title() and show_title() are not part
     of the base class, they are not accessible via
     the base pointer p and must be accessed either
     directly, or, as shown here, through a pointer to the
     derived type.
  */
  dp = &D_ob;
  dp->put_title("The Tempest");
  p->show_author(); // either p or dp can be used here.
  dp->show_title( );

  return 0;
}
#include <iostream>
using namespace std;

class figure {
protected:
  double x, y;
public:
  void set_dim(double i, double j=0) {
    x = i;
    y = j;
  }
  virtual void show_area() {
    cout << "No area computation defined ";
    cout << "for this class.\n";
  }
} ;

class triangle : public figure {
  public:
    void show_area() {
      cout << "Triangle with height ";
      cout << x << " and base " << y;
      cout << " has an area of ";
      cout << x * 0.5 * y << ".\n";
    }
};

class square : public figure {
  public:
    void show_area() {
      cout << "Square with dimensions ";
      cout << x << "x" << y;
      cout << " has an area of ";
      cout << x *  y << ".\n";
    }
};
class circle : public figure {
  public:
    void show_area() {
      cout << "Circle with radius ";
      cout << x;
      cout << " has an area of ";
      cout << 3.14 * x * x << ".\n";
    }
} ;

int main()
{
  figure *p; // create a pointer to base type

  triangle t; // create objects of derived types
  square s;
  circle c;

  p = &t;
  p->set_dim(10.0, 5.0);
  p->show_area();

  p = &s;
  p->set_dim(10.0, 5.0);
  p->show_area();

  p = &c;
  p->set_dim(9.0);
  p->show_area();

  return 0;
}
Accessing SQL Server from C++

#define DBNTWIN32
#include <stdio.h>
#include <windows.h>
#include <sqlfront.h>
#include <sqldb.h>

// Forward declarations of the error handler and message handler. 

int err_handler(PDBPROCESS, INT, INT, INT, LPCSTR, LPCSTR);
int msg_handler(PDBPROCESS, DBINT, INT, INT, LPCSTR, LPCSTR,
LPCSTR, DBUSMALLINT);
main()
{
   PDBPROCESS dbproc; // The connection with SQL Server. 
   PLOGINREC login; // The login information. 
   DBCHAR name[100];
   DBCHAR city[100];

// Install user-supplied error- and message-handling functions.

   dberrhandle (err_handler);
   dbmsghandle (msg_handler);

// Initialize DB-Library.

   dbinit ();

// Get a LOGINREC.

   login = dblogin ();
   DBSETLUSER (login, "my_login");
   DBSETLPWD (login, "my_password");
   DBSETLAPP (login, "example");

// Get a DBPROCESS structure for communication with SQL Server. 

   dbproc = dbopen (login, "my_server");

// Retrieve some columns from the authors table in the
// pubs database.
// First, put the command into the command buffer. 

   dbcmd (dbproc, "SELECT au_lname, city FROM pubs..authors");
   dbcmd (dbproc, " WHERE state = 'CA' ");

// Send the command to SQL Server and start execution. 

   dbsqlexec (dbproc);

// Process the results. 

   if (dbresults (dbproc) == SUCCEED)
   {

// Bind column to program variables. 

      dbbind (dbproc, 1, NTBSTRINGBIND, 0, name);
      dbbind (dbproc, 2, NTBSTRINGBIND, 0, city);

// Retrieve and print the result rows. 

      while (dbnextrow (dbproc) != NO_MORE_ROWS)
      {
         printf ("%s from %s\n", name, city);
      }
   }

// Close the connection to SQL Server. 

   dbexit ();
   return (0);
}

int err_handler (PDBPROCESS dbproc, INT severity,
INT dberr, INT oserr, LPCSTR dberrstr, LPCSTR oserrstr)
{
   printf ("DB-Library Error %i: %s\n", dberr, dberrstr);
   if (oserr != DBNOERR)
   {
      printf ("Operating System Error %i: %s\n", oserr, oserrstr);
   }
   return (INT_CANCEL);
}

int msg_handler (PDBPROCESS dbproc, DBINT msgno, INT msgstate,
INT severity, LPCSTR msgtext, LPCSTR server,
LPCSTR procedure, DBUSMALLINT line)
{
   printf ("SQL Server Message %ld: %s\n", msgno, msgtext);
   return (0);
}
Area overloded

#include<iostream.h>
#include<conio.h>
#define phi  3.14
int area(int,int);
float area(int);
void main()
{
	int a,b,c,cho;
	clrscr();
	cout<<"\t  What do you want to do?\n";
	cout<<"1. area of rectangle"<<endl;
	cout<<"2. area of circle"<<endl;
	cout<<"Choice:";
	cin>>cho;
	switch(cho)
	{
		case 1:
			cout<<"Enter lengt and breath (with white space):";
			cin>>a>>b;
			cout<<"Area of RECTANGLE:"<<area(a,b);
			break;
		case 2:
			cout<<"Enter radius:";
			cin>>c;
			cout<<"Area of CIRCLE:"<<area(c);
			break;
	  }
	getch();
  }
 int area(int x,int y)
  {
  return (x*y);
 }
 float area(int s)
 {
 return (phi*s*s);
 }
Binary arithmatic

#include<stdio.h>
#include<conio.h>
#include<string.h>
#include<math.h>

void b_to_d(char result[]); //binary to decimal
void d_to_b(int dec,char binary[]); // decimal to binary

main()
{
	int ch,n1,n2,i=0,j,k,l,carry,r,x1,x2,x;
	char bn1[30],bn2[30],result[30],binary[30];
	char multi[30][30];
	clrscr();
	do
	{
		printf("<1> input first operand \n");
		printf("<2> input second operand \n");
		printf("<3> binary addition \n");
		printf("<4> binary subtraction \n");
		printf("<5> binary multiplation \n");
		printf("<6> result to decimal \n");
		printf("<7> Exit \n\n");
		do
		{
			printf("enter your choice ");
			scanf("%d",&ch);
		}while(ch>7 || ch<1);
		switch (ch)
		{
			case 1:
				printf("\n input first operand ");
				scanf("%d",&n1);
				x1=n1;
				d_to_b(n1,binary);
				for(i=0;binary[i]!='\0';++i)
					bn1[i]=binary[i];
				bn1[i]='\0';
				break;
			case 2:
				printf("\n input second operand ");
				scanf("%d",&n2);
				x2=n2;
				d_to_b(n2,binary);
				for(i=0;binary[i]!='\0';++i)
					bn2[i]=binary[i];
				bn2[i]='\0';
				break;
			case 3:		//addition
				for(i=0;i<30;++i)      //reset result
					result[i]='\0';
				carry=0;
				if(strlen(bn1)<strlen(bn2))
					r=strlen(bn2);
				else
					r=strlen(bn1);
				for(i=0;i<r;++i)
				{
					result[i+1]='\0';
					if(carry==0)
					{
						if(bn1[i]-48+bn2[i]-48+carry==1)
							result[i]=bn1[i]-48+bn2[i]-48+48;
						else
							result[i]=0+48;
					}
					else
					{
						if(bn1[i]-48+bn2[i]-48+carry==2)
							result[i]=0+48;
						else
							result[i]=1+48;
					}
					if(bn1[i]-48+bn2[i]-48+carry>1)
						carry=1;
					else
						carry=0;
					if(carry==1)
						result[i+1]=carry+48;
				}
				printf("\n%s\n",strrev(result));
				break;
			case 4:		//subtraction
				for(i=0;i<30;++i)      //reset result
					result[i]='\0';
				carry=0;
				if(strlen(bn1)<strlen(bn2))
					r=strlen(bn2);
				else
					r=strlen(bn1);
				for(i=0;i<r;++i)
				{
					result[i+1]='\0';
					if(bn1[i]<bn2[i])
						carry=2,--bn1[i+1];
					else
						carry=0;
					if(carry+bn1[i]-48-bn2[i]+48==1)
						result[i]=1+48;
					else
						if(carry+bn1[i]-48-bn2[i]+48==0)
							result[i]=0+48;
				}
				printf("\n%s\n",strrev(result));
				break;
			case 5:		//binary multiplication complited on 27-03-2004
				for(i=0;i<30;++i)      //reset result
					result[i]='\0';
				strrev(bn2); // reversing second binary operand
				k=0,x=0;
				for(i=0;i<strlen(bn2);++i)  //creating array for addition
					if(bn2[i]=='1')
					{
						for(j=i+1;bn2[j]!='\0';++j)
							multi[k][x++]='0';
						for(l=0;bn1[l]!='\0';++j,++l)
							multi[k][x++]=bn1[l];
						for(;x<30;++j)
							multi[k][x++]='0';
					++k,x=0;
					}
				l=0;
				for(j=0;j<30;++j)  //addition of all columns without carry
				{
					x=0;
					for(i=0;i<k;++i)
						x+=(multi[i][j]-48);
					multi[0][l++]=x;
				}
				for(i=0;i<30;++i)   //loop for including carry.
					if(multi[0][i]>1)
						multi[0][i+1]+=((multi[0][i]-(multi[0][i]%2))/2);
				printf("\n");
				for(i=29;i>=0;--i)  // excluding first zero's (0's) of array
					if(multi[0][i]!=0)
						break;
				j=0;
				for(;i>=0;--i)   // final calculations and print
					if(multi[0][i]<48)
					{
						multi[0][i]%=2;
						result[j++]=multi[0][i]+48;
					       //	printf("%d",multi[0][i]);
					}
				printf("\n");
				printf("%s\n",result);
				break;
			case 6:		//result in decimal
				b_to_d(result);
				printf("\n");
				break;
		}
		n1=x1;
		d_to_b(n1,binary);
		for(i=0;binary[i]!='\0';++i)
			bn1[i]=binary[i];
		bn1[i]='\0';

		n2=x2;
		d_to_b(n2,binary);
		for(i=0;binary[i]!='\0';++i)
			bn2[i]=binary[i];
		bn2[i]='\0';

	}while(ch!=7);
	printf("\n\n i will wait for your mails");
	getch();
	return 0;
}

void b_to_d(char result[]) //binary to decimal
{
	short int i;
	long int dec=0;
	strrev(result);
	for(i=0;i<strlen(result);++i)
		dec+=(result[i]-48)*pow(2,i);
	printf("result in decimal is %ld\n",dec);
	strrev(result);
}

void d_to_b(int dec,char binary[]) // decimal to binary
{
	int i=0;
	while(dec>0)
	{
		binary[i++]=dec%2+48;
		binary[i]='\0';
		dec-=(dec%2);
		dec/=2;
	}
}
Binary Search Tree Program

#include <iostream>
#include <cstdlib>
using namespace std;

class BinarySearchTree
{
    private:
        struct tree_node
        {
           tree_node* left;
           tree_node* right;
           int data;
        };
        tree_node* root;
    public:
        BinarySearchTree()
        {
           root = NULL;
        }
        bool isEmpty() const { return root==NULL; }
        void print_inorder();
        void inorder(tree_node*);
        void print_preorder();
        void preorder(tree_node*);
        void print_postorder();
        void postorder(tree_node*);
        void insert(int);
        void remove(int);
};

// Smaller elements go left
// larger elements go right
void BinarySearchTree::insert(int d)
{
    tree_node* t = new tree_node;
    tree_node* parent;
    t->data = d;
    t->left = NULL;
    t->right = NULL;
    parent = NULL;
  // is this a new tree?
  if(isEmpty()) root = t;
  else
  {
    //Note: ALL insertions are as leaf nodes
    tree_node* curr;
    curr = root;
    // Find the Node's parent
    while(curr)
    {
        parent = curr;
        if(t->data > curr->data) curr = curr->right;
        else curr = curr->left;
    }

    if(t->data < parent->data)
       parent->left = t;
    else
       parent->right = t;
  }
}

void BinarySearchTree::remove(int d)
{
    //Locate the element
    bool found = false;
    if(isEmpty())
    {
        cout<<" This Tree is empty! "<<endl;
        return;
    }
    tree_node* curr;
    tree_node* parent;
    curr = root;
    while(curr != NULL)
    {
         if(curr->data == d)
         {
            found = true;
            break;
         }
         else
         {
             parent = curr;
             if(d>curr->data) curr = curr->right;
             else curr = curr->left;
         }
    }
    if(!found)
		 {
        cout<<" Data not found! "<<endl;
        return;
    }


		 // 3 cases :
    // 1. We're removing a leaf node
    // 2. We're removing a node with a single child
    // 3. we're removing a node with 2 children

    // Node with single child
    if((curr->left == NULL && curr->right != NULL)|| (curr->left != NULL
&& curr->right == NULL))
    {
       if(curr->left == NULL && curr->right != NULL)
       {
           if(parent->left == curr)
           {
             parent->left = curr->right;
             delete curr;
           }
           else
           {
             parent->right = curr->right;
             delete curr;
           }
       }
       else // left child present, no right child
       {
          if(parent->left == curr)
           {
             parent->left = curr->left;
             delete curr;
           }
           else
           {
             parent->right = curr->left;
             delete curr;
           }
       }
     return;
    }

		 //We're looking at a leaf node
		 if( curr->left == NULL && curr->right == NULL)
    {
        if(parent->left == curr) parent->left = NULL;
        else parent->right = NULL;
		 		 delete curr;
		 		 return;
    }


    //Node with 2 children
    // replace node with smallest value in right subtree
    if (curr->left != NULL && curr->right != NULL)
    {
        tree_node* chkr;
        chkr = curr->right;
        if((chkr->left == NULL) && (chkr->right == NULL))
        {
            curr = chkr;
            delete chkr;
            curr->right = NULL;
        }
        else // right child has children
        {
            //if the node's right child has a left child
            // Move all the way down left to locate smallest element

            if((curr->right)->left != NULL)
            {
                tree_node* lcurr;
                tree_node* lcurrp;
                lcurrp = curr->right;
                lcurr = (curr->right)->left;
                while(lcurr->left != NULL)
                {
                   lcurrp = lcurr;
                   lcurr = lcurr->left;
                }
		 		 		 		 curr->data = lcurr->data;
                delete lcurr;
                lcurrp->left = NULL;
           }
           else
           {
               tree_node* tmp;
               tmp = curr->right;
               curr->data = tmp->data;
		 		 		    curr->right = tmp->right;
               delete tmp;
           }

        }
		 return;
    }

}

void BinarySearchTree::print_inorder()
{
  inorder(root);
}

void BinarySearchTree::inorder(tree_node* p)
{
    if(p != NULL)
    {
        if(p->left) inorder(p->left);
        cout<<" "<<p->data<<" ";
        if(p->right) inorder(p->right);
    }
    else return;
}

void BinarySearchTree::print_preorder()
{
  preorder(root);
}

void BinarySearchTree::preorder(tree_node* p)
{
    if(p != NULL)
    {
        cout<<" "<<p->data<<" ";
        if(p->left) preorder(p->left);
        if(p->right) preorder(p->right);
    }
    else return;
}

void BinarySearchTree::print_postorder()
{
  postorder(root);
}

void BinarySearchTree::postorder(tree_node* p)
{
    if(p != NULL)
    {
        if(p->left) postorder(p->left);
        if(p->right) postorder(p->right);
        cout<<" "<<p->data<<" ";
    }
    else return;
}

int main()
{
    BinarySearchTree b;
    int ch,tmp,tmp1;
    while(1)
    {
       cout<<endl<<endl;
       cout<<" Binary Search Tree Operations "<<endl;
       cout<<" ----------------------------- "<<endl;
       cout<<" 1. Insertion/Creation "<<endl;
       cout<<" 2. In-Order Traversal "<<endl;
       cout<<" 3. Pre-Order Traversal "<<endl;
       cout<<" 4. Post-Order Traversal "<<endl;
       cout<<" 5. Removal "<<endl;
       cout<<" 6. Exit "<<endl;
       cout<<" Enter your choice : ";
       cin>>ch;
       switch(ch)
       {
           case 1 : cout<<" Enter Number to be inserted : ";
                    cin>>tmp;
                    b.insert(tmp);
                    break;
           case 2 : cout<<endl;
                    cout<<" In-Order Traversal "<<endl;
                    cout<<" -------------------"<<endl;
                    b.print_inorder();
                    break;
           case 3 : cout<<endl;
                    cout<<" Pre-Order Traversal "<<endl;
                    cout<<" -------------------"<<endl;
                    b.print_preorder();
                    break;
           case 4 : cout<<endl;
                    cout<<" Post-Order Traversal "<<endl;
                    cout<<" --------------------"<<endl;
                    b.print_postorder();
                    break;
           case 5 : cout<<" Enter data to be deleted : ";
                    cin>>tmp1;
                    b.remove(tmp1);
                    break;
           case 6 : system("pause");
                    return 0;
                    break;
       }
    }
}
Binary Search Tree Program

#include <iostream>
#include <cstdlib>
using namespace std;

class BinarySearchTree
{
    private:
        struct tree_node
        {
           tree_node* left;
           tree_node* right;
           int data;
        };
        tree_node* root;
    public:
        BinarySearchTree()
        {
           root = NULL;
        }
        bool isEmpty() const { return root==NULL; }
        void print_inorder();
        void inorder(tree_node*);
        void print_preorder();
        void preorder(tree_node*);
        void print_postorder();
        void postorder(tree_node*);
        void insert(int);
        void remove(int);
};

// Smaller elements go left
// larger elements go right
void BinarySearchTree::insert(int d)
{
    tree_node* t = new tree_node;
    tree_node* parent;
    t->data = d;
    t->left = NULL;
    t->right = NULL;
    parent = NULL;
  // is this a new tree?
  if(isEmpty()) root = t;
  else
  {
    //Note: ALL insertions are as leaf nodes
    tree_node* curr;
    curr = root;
    // Find the Node's parent
    while(curr)
    {
        parent = curr;
        if(t->data > curr->data) curr = curr->right;
        else curr = curr->left;
    }

    if(t->data < parent->data)
       parent->left = t;
    else
       parent->right = t;
  }
}

void BinarySearchTree::remove(int d)
{
    //Locate the element
    bool found = false;
    if(isEmpty())
    {
        cout<<" This Tree is empty! "<<endl;
        return;
    }
    tree_node* curr;
    tree_node* parent;
    curr = root;
    while(curr != NULL)
    {
         if(curr->data == d)
         {
            found = true;
            break;
         }
         else
         {
             parent = curr;
             if(d>curr->data) curr = curr->right;
             else curr = curr->left;
         }
    }
    if(!found)
		 {
        cout<<" Data not found! "<<endl;
        return;
    }


		 // 3 cases :
    // 1. We're removing a leaf node
    // 2. We're removing a node with a single child
    // 3. we're removing a node with 2 children

    // Node with single child
    if((curr->left == NULL && curr->right != NULL)|| (curr->left != NULL
&& curr->right == NULL))
    {
       if(curr->left == NULL && curr->right != NULL)
       {
           if(parent->left == curr)
           {
             parent->left = curr->right;
             delete curr;
           }
           else
           {
             parent->right = curr->right;
             delete curr;
           }
       }
       else // left child present, no right child
       {
          if(parent->left == curr)
           {
             parent->left = curr->left;
             delete curr;
           }
           else
           {
             parent->right = curr->left;
             delete curr;
           }
       }
     return;
    }

		 //We're looking at a leaf node
		 if( curr->left == NULL && curr->right == NULL)
    {
        if(parent->left == curr) parent->left = NULL;
        else parent->right = NULL;
		 		 delete curr;
		 		 return;
    }


    //Node with 2 children
    // replace node with smallest value in right subtree
    if (curr->left != NULL && curr->right != NULL)
    {
        tree_node* chkr;
        chkr = curr->right;
        if((chkr->left == NULL) && (chkr->right == NULL))
        {
            curr = chkr;
            delete chkr;
            curr->right = NULL;
        }
        else // right child has children
        {
            //if the node's right child has a left child
            // Move all the way down left to locate smallest element

            if((curr->right)->left != NULL)
            {
                tree_node* lcurr;
                tree_node* lcurrp;
                lcurrp = curr->right;
                lcurr = (curr->right)->left;
                while(lcurr->left != NULL)
                {
                   lcurrp = lcurr;
                   lcurr = lcurr->left;
                }
		 		 		 		 curr->data = lcurr->data;
                delete lcurr;
                lcurrp->left = NULL;
           }
           else
           {
               tree_node* tmp;
               tmp = curr->right;
               curr->data = tmp->data;
		 		 		    curr->right = tmp->right;
               delete tmp;
           }

        }
		 return;
    }

}

void BinarySearchTree::print_inorder()
{
  inorder(root);
}

void BinarySearchTree::inorder(tree_node* p)
{
    if(p != NULL)
    {
        if(p->left) inorder(p->left);
        cout<<" "<<p->data<<" ";
        if(p->right) inorder(p->right);
    }
    else return;
}

void BinarySearchTree::print_preorder()
{
  preorder(root);
}

void BinarySearchTree::preorder(tree_node* p)
{
    if(p != NULL)
    {
        cout<<" "<<p->data<<" ";
        if(p->left) preorder(p->left);
        if(p->right) preorder(p->right);
    }
    else return;
}

void BinarySearchTree::print_postorder()
{
  postorder(root);
}

void BinarySearchTree::postorder(tree_node* p)
{
    if(p != NULL)
    {
        if(p->left) postorder(p->left);
        if(p->right) postorder(p->right);
        cout<<" "<<p->data<<" ";
    }
    else return;
}

int main()
{
    BinarySearchTree b;
    int ch,tmp,tmp1;
    while(1)
    {
       cout<<endl<<endl;
       cout<<" Binary Search Tree Operations "<<endl;
       cout<<" ----------------------------- "<<endl;
       cout<<" 1. Insertion/Creation "<<endl;
       cout<<" 2. In-Order Traversal "<<endl;
       cout<<" 3. Pre-Order Traversal "<<endl;
       cout<<" 4. Post-Order Traversal "<<endl;
       cout<<" 5. Removal "<<endl;
       cout<<" 6. Exit "<<endl;
       cout<<" Enter your choice : ";
       cin>>ch;
       switch(ch)
       {
           case 1 : cout<<" Enter Number to be inserted : ";
                    cin>>tmp;
                    b.insert(tmp);
                    break;
           case 2 : cout<<endl;
                    cout<<" In-Order Traversal "<<endl;
                    cout<<" -------------------"<<endl;
                    b.print_inorder();
                    break;
           case 3 : cout<<endl;
                    cout<<" Pre-Order Traversal "<<endl;
                    cout<<" -------------------"<<endl;
                    b.print_preorder();
                    break;
           case 4 : cout<<endl;
                    cout<<" Post-Order Traversal "<<endl;
                    cout<<" --------------------"<<endl;
                    b.print_postorder();
                    break;
           case 5 : cout<<" Enter data to be deleted : ";
                    cin>>tmp1;
                    b.remove(tmp1);
                    break;
           case 6 : system("pause");
                    return 0;
                    break;
       }
    }
}
Binary Search Tree

#include<iostream.h>
#include<conio.h>
#include<alloc.h>

struct tree
 {
  int data;
  tree *left;
  tree *right;
 }*sptr,*q;
  void rightcheck();
  void leftcheck();
  void search();

  int insdata;
  tree *node;
  void main()
   {
    clrscr();
    node=new tree;
    cout<<"   PLEASE  PUT  THE root->>";
    cin>>node->data;
    sptr=node;
    q=sptr;
    node->left=NULL;
    node->right=NULL;
    cout<<"   GIVE THE child->>";
    cin>>insdata;
    search();
    while(insdata!=0)
	{
	 if(insdata>sptr->data)
	    rightcheck();
	 else
	    leftcheck();
	    cout<<"   GIVE  THE  child->>";
	    cin>>insdata;
	    search();
	    sptr=node;
       }
      getch();
      }
     void rightcheck()
       {
	 if(sptr->right==NULL)
	   {
	    cout<<"    "<<insdata<<" IS THE  RIGHT  child of "<<q->data<<endl;
	    sptr->right=new tree;
	    sptr=sptr->right;
	    sptr->data=insdata;
	    sptr->left=NULL;
	    sptr->right=NULL;
	    q=node;
	   }
	 else
	    {
	     if(insdata>sptr->data)
	      {
	       sptr=sptr->right;
	       q=sptr;
	       if(insdata>sptr->data)
		rightcheck();
		else
		leftcheck();
	     }
	     else
	      {
		sptr=sptr->left;
		q=sptr;
		leftcheck();
	      }
	     }
	}
		 void leftcheck()
	{
		 if(sptr->left==NULL)
		  {
		   cout<<"   "<<insdata<<" IS THE LEFT child of "<<q->data<<endl;
		   sptr->left=new tree;
		   sptr=sptr->left;
		   sptr->data=insdata;
		   sptr->right=NULL;
		   sptr->left=NULL;
		   q=node;
		  }
	 else{
	     if(insdata<sptr->data)
	      {
		sptr=sptr->left;
		q=sptr;
		if(insdata>sptr->data)
		rightcheck();
		else
		leftcheck();
	      }
	     else
	      {
		sptr=sptr->right;
		q=sptr;
		rightcheck();}
	      }
	}

       void search()
	{
	   sptr=node;
	   while(sptr!=NULL)
	{
	  if(insdata==sptr->data)
	    {
	    cout<<"This is not insertable.";
	    cout<<"\nInsert child ";
	    cin>>insdata;
	    search();
	    break;
	    }
	  else
	  {
	    if(insdata>sptr->data)
		sptr=sptr->right;
	    else
		sptr=sptr->left;
	 }
       }
	 sptr=node;

       }
Byte alignment in a struct

#include <iostream.h>

#define ALIGN 8
#pragma pack(ALIGN)

/* Algorithm

Byte offset between currentType and nextType  = MIN( multiple of Byte
Alignment specified , multiple of size of nextType)
**/

int ALIGNOFFSET(int currRelativeAddess,int currrentTypeSize,int
nextTypeSize)
{

	int nOffset = currrentTypeSize ;//this is size of the current
type.Offset will be minimum of this size.
	currRelativeAddess += currrentTypeSize ; //cuurent address is
increased by size of current type.
	if( nextTypeSize < ALIGN) // now alignment depens on the next type
and also alignment defined by #pragam pack(#)
	{
		// if the size of next type is less than byte alignment size
specified , then offset will be increased to the muliple of
		// size of next type.
		int nRemainder  = currRelativeAddess % nextTypeSize ;
		if(nRemainder != 0)
		{
			nOffset += nextTypeSize - nRemainder ;//this will
align boundary to next multiple of nextTypeSize
		}

	}
	else
	{
		// if the byte alignment size specified is less than size of
next type , then offset will be increased to the next muliple of
		// size of byte alignment.
		int nRemainder  = currRelativeAddess % ALIGN ;
		if(nRemainder != 0)
		{
			nOffset += ALIGN - nRemainder ;//this will align the
boundary to next multiple of ALIGN
		}
	}
	return nOffset ;
}


struct S
{

   char a[2];
   int b;
   double c;
   char d[1];
   int e;
   double f;
};

void main()
{
	S sz;
	cout << "size of struct :" << sizeof(sz) << endl;
	cout << "address of size::a "<< &sz.a <<" Actual offset = " <<
int(0) << " Calculated offset = " << 0 << endl;

	int offset = ((int)&sz.b)- (int)(&sz.a);


	cout << "address of size::b " << &sz.b <<" Actual offset = " <<
offset << " Calculated offset = " << ALIGNOFFSET((int)(&sz.a)-
(int)(&sz),sizeof(sz.a),sizeof(sz.b)) << endl;
	offset = ((int)&sz.c)- (int)(&sz.b);

	cout << "address of size::c " << &sz.c <<" Actual offset = " <<
offset << " Calculated offset = " << ALIGNOFFSET((int)(&sz.b) -
(int)(&sz),sizeof(sz.b),sizeof(sz.c)) << endl;
	offset = ((int)&sz.d)- (int)(&sz.c);

	cout << "address of size::d " << &sz.d <<" Actual offset = " <<
offset << " Calculated offset = " << ALIGNOFFSET((int)(&sz.c)-
(int)(&sz),sizeof(sz.c),sizeof(sz.d)) << endl;

	offset = ((int)&sz.e)- (int)(&sz.d);

	cout << "address of size::e " << &sz.e <<" Actual offset = " <<
offset << " Calculated offset = " << ALIGNOFFSET((int)(&sz.d)-
(int)(&sz),sizeof(sz.d),sizeof(sz.e)) << endl;
	offset = ((int)&sz.f)- (int)(&sz.e);
	cout << "address of size::f " << &sz.f <<" Actual offset = " <<
offset << " Calculated offset = " << ALIGNOFFSET((int)(&sz.e)-
(int)(&sz),sizeof(sz.e),sizeof(sz.f)) << endl;
}

Complex nos

#include<iostream.h>
#include<conio.h>
class complex
{
	private:
		float real,img;
	public:
		void assign(float x,float y)
		{
			real=x;
			img=y;
		}
		void print()
		{  if(img>=0)
			cout<<real<<"+"<<img<<"i";
			else
				cout<<real<<img<<"i";
		getch();
		}
};
void add( float a,float b,float c, float d)
	{

		float e,f;complex g;
		e=a+c;
		f=b+d;
		g.assign(e,f);
	   g.print();
	}
void sub( float a,float b,float c, float d)
	{

		float e,f;complex g;
		e=a-c;
		f=b-d;
		g.assign(e,f);
	   g.print();
	}
void mul( float a,float b,float c, float d)
	{

		float e,f; complex g;
		e=a*c-b*d;
		f=b*c+a*d;
		g.assign(e,f);
	   g.print();
	}
void main()
{
	float a,b,c,d;
	complex x,y,z;
	clrscr();
	cout<<" for complex 1:";
	cout<<"real part:";
	cin>>a;
	cout<<"imaginary part:";
	cin>>b;
	cout<<" for complex 2:";
	cout<<"real part:";
	cin>>c;
	cout<<"imaginary part:";
	cin>>d;
	x.assign(a,b);
	y.assign(c,d);
	cout<<"**************original data:************\n";
	cout<<"Complex 1:\n";x.print();
	cout<<"\n Complex 2:\n";y.print();
	cout<<"\n************=================**********\n";
	cout<<"\n Addition:\n";add(a,b,c,d);
	cout<<"\n Subtraction:\n";sub(a,b,c,d);
	cout<<"\n Multipication:\n";mul(a,b,c,d);
  }

Copying one or more than one file into one file

#include <stdio.h>

void main(int argc,char *argv[]){
     int i=0,
	 is_copied=0;

     FILE *input,
	  *output;

     char ch;

     clrscr();


     if (argc>=3){

	     /* last file is the output file */
	     output=fopen(argv[argc-1],"w+");
	     if (output==NULL){
		 gotoxy(10,1);
		 printf("Can't open output file :%s",argv[argc-1]);
		 getch();
		 return;
	     }


	     /* input files */
	     for(i=1;i<argc-1;i++){
		 input=fopen(argv[i],"r");

		 if (input==NULL){
			gotoxy(10,i+2);
			printf("Can't open input file :%s",argv[i]);
		 }
		 else{
		      /* writing from input file to output file */

		       rewind(input);
		       while((ch=fgetc(input))!=EOF){
			      fprintf(output,"%c",ch);
			      is_copied=1;
		       }

		       gotoxy(10,i+2);

		       if (is_copied)
			       printf("%s successfully copied into %s",argv[i],argv[argc-1]);
		       else
			       printf("%s can't copy into %s",argv[i],argv[argc-1]);

		       is_copied=0;

		 }
                 fclose(input);
	    }

	    fclose(output);


      }
      else{
	  gotoxy(10,1);
	  printf("please specifiy at least two file one source and another target");
      }

      getch();
}
Fahrenheit-Celsius converter

#include <iostream.h>
#include <iomanip.h>
#include <stdlib.h>

void c_to_f(void);
void f_to_c(void);

void
 main(void)
{
	int choice;
	char again;
	do
	{
		system("CLS");
		
		cout << setw(10) <<" "<< "What conversion would you like to make?\n";	// menu
		cout << setw(20) <<" "<< "1. Celsius to Fahrenheit\n\n";					// make a choice which function to use.
		cout << setw(20) <<" "<< "2. Fahrenheit to celsius\n\n";
		cin >> choice;

			switch(choice)										// go to chosen function.
			{
				case 1 :
					{
						c_to_f();
						break;
					}
				case 2 : 
					{
						f_to_c();
						break;
					}
				default :
				{
					cout << setw(10) <<" "<< "you must enter 1 or 2  "<< endl ;		// validate and correct input of function choice.
				
				}
						
						
			}
			
			

			cout << setw(10) <<" "<< "Do you wish to do another conversion? y for yes, n for no  ";	// rerun loop on y for yes
			cin >> again;
	}while (again == 'Y' || again =='y');
	
}


void c_to_f(void)
{
	system("CLS");								// clear screen for function data.
	int temp,fahrenheit;

	cout << "\n\n\n";
	cout << setw(10) <<" "<< "Enter the temperature in whole degrees celsius. \a";
	cin >> temp;

	fahrenheit = ((temp * 9) / 5) + 32;
	cout << endl << setw(10) <<" "<< temp << " degrees celsius is " << fahrenheit << " degrees fahrenheit \a\n\n\n";
}

void f_to_c(void)
{
	system("CLS");								// clear screen for function data.
	int temp,celsius;

	cout << "\n\n\n";
	cout << setw(10) <<" "<< "Enter the temperature in whole degrees fahrenheit.  \a";
	cin >> temp;

	celsius = ((temp - 32) * 5) / 9;
	
	cout << endl <<setw(10) <<" "<< temp << " degrees fahrenheit is " << celsius << " degrees celsius \a\n\n\n";
}

Fahrenheit-Celsius converter

#include <iostream.h>
#include <iomanip.h>
#include <stdlib.h>

void c_to_f(void);
void f_to_c(void);

void
 main(void)
{
	int choice;
	char again;
	do
	{
		system("CLS");
		
		cout << setw(10) <<" "<< "What conversion would you like to make?\n";	// menu
		cout << setw(20) <<" "<< "1. Celsius to Fahrenheit\n\n";					// make a choice which function to use.
		cout << setw(20) <<" "<< "2. Fahrenheit to celsius\n\n";
		cin >> choice;

			switch(choice)										// go to chosen function.
			{
				case 1 :
					{
						c_to_f();
						break;
					}
				case 2 : 
					{
						f_to_c();
						break;
					}
				default :
				{
					cout << setw(10) <<" "<< "you must enter 1 or 2  "<< endl ;		// validate and correct input of function choice.
				
				}
						
						
			}
			
			

			cout << setw(10) <<" "<< "Do you wish to do another conversion? y for yes, n for no  ";	// rerun loop on y for yes
			cin >> again;
	}while (again == 'Y' || again =='y');
	
}


void c_to_f(void)
{
	system("CLS");								// clear screen for function data.
	int temp,fahrenheit;

	cout << "\n\n\n";
	cout << setw(10) <<" "<< "Enter the temperature in whole degrees celsius. \a";
	cin >> temp;

	fahrenheit = ((temp * 9) / 5) + 32;
	cout << endl << setw(10) <<" "<< temp << " degrees celsius is " << fahrenheit << " degrees fahrenheit \a\n\n\n";
}

void f_to_c(void)
{
	system("CLS");								// clear screen for function data.
	int temp,celsius;

	cout << "\n\n\n";
	cout << setw(10) <<" "<< "Enter the temperature in whole degrees fahrenheit.  \a";
	cin >> temp;

	celsius = ((temp - 32) * 5) / 9;
	
	cout << endl <<setw(10) <<" "<< temp << " degrees fahrenheit is " << celsius << " degrees celsius \a\n\n\n";
}
Fibonacci Series

#include<iostream.h>
#include<conio.h>

main()
{
   const unsigned long limit=4294967295;
   unsigned long next=0;
   unsigned long last=1;
   long sum;

   clrscr();

   cout<<"\n\nThis program will print the Fibonacci series :\n\n ";
   while(next<limit/2)
   {
      cout<<last <<"   ";
      sum=next+last;
      next=last;
      last=sum;
   }
   getch();
}
Frequency words,characters

// ISO/ANSI C program
// 0 Errors and 0 Warnings on turboC 3.0 compilers
// borland 3.0

#include<stdio.h>
#include<conio.h>
#include<string.h>
main()
{
	int ch,i,j,k,l,fc[50][2],flag;
	char line[50],fw[50][50];
	clrscr();
	do
	{
		printf("\n<1> Input a line");
		printf("\n<2> Number of characters");
		printf("\n<3> Number of words");
		printf("\n<4> Number of vowals");
		printf("\n<5> Frequency of characters");
		printf("\n<6> Frequency of words");
		printf("\n<7> Exit\n");
		do
		{
			printf("\n enter your choice ");
			scanf("%d",&ch);
		}while(ch>7 || ch<1);
		switch (ch)
		{
			case 1:		//input a line
				printf("\n Enter a line ");
				scanf("\n%[^\n]",line);
				break;
			case 2:		//number of characters
				j=0;
				for(i=0;i<strlen(line);++i)
				{
					if(line[i]>64 && line[i]<93)
						++j;
					else
						if(line[i]>96 && line[i]<123)
							++j;
				}
				printf("total number of characters are %d",j);
				break;
			case 3:		//number of words
				j=0;
				for(i=0;i<strlen(line);++i)
				{
					if(line[i]==' ' || line[i]=='\t')
						continue;
					else
					{
						for(k=i;k<strlen(line);++k)
						{
							if(line[k]==' ' || line[k]=='\t')
								break;
							else
								++i;
						}
					}
					++j;
				}
				printf("\n total number of words are %d",j);
				break;
			case 4:		//number of vowels
				j=0;
				for(i=0;i<strlen(line);++i)
				{
					if(line[i]=='a' || line[i]=='e' || line[i]=='i' || line[i]=='o' || line[i]=='u')
						++j;
					else
						if(line[i]=='A' || line[i]=='E' || line[i]=='I' || line[i]=='O' || line[i]=='U')
							++j;
				}
				printf("total number of vowels are %d",j);
				break;
			case 5:		//frequency of characters
				for(i=0;i<strlen(line);++i)
				{
					fc[i][1]=0;
					flag=0;
					for(j=0;j<strlen(line);++j)
					{
						if(line[i]==fc[j][0])
						{
							fc[j][0]=line[i];
							++fc[j][1];
							flag=1;
							break;
						}
					}
					if(flag==0)
						fc[i][0]=line[i],fc[i][1]=1;
				}
				printf("\n Frequency of each characters");
				for(i=0;i<strlen(line);++i)
					if(fc[i][1]!=0)
						printf("\n%c %d",fc[i][0],fc[i][1]);
				break;
			case 6:		//frequency of words
				j=0;
				for(i=0;i<strlen(line);++i)
				{
					if(line[i]==' ' || line[i]=='\t')
						continue;
					else
					{
						l=0;
						for(k=i;k<strlen(line);++k)
						{
							if(line[k]==' ' || line[k]=='\t')
								break;
							else
							{
								fw[j][l]=line[k],fw[j][++l]='\0';
								++i;
							}
						}
					}
					++j;
				}
				for(i=0;i<j;++i)
				{
					fc[0][0]=0;
					for(k=i;k<j;++k)
					{
						flag=1;
						for(l=0;l<j;++l)
							if(fw[i][l]!=fw[k][l])
								flag=0;
						if(flag==1)
						{
							++fc[0][0];
							if(fc[0][0]>1)
								fw[k][0]='\0';
						}
					}
					if(fc[0][0]>0)
					{
						flag=0;
						do
						{
							printf("%c",fw[i][flag]);
						} while(fw[i][flag++]!='\0');
						if(fw[i][0]!='\0')
							printf("%d\n",fc[0][0]);
					}
					fc[0][0]=0;
				}
				break;
		}
	}while(ch!=7);
	printf("\n\n i will wait for your mails ");
	getch();
	return ;
}
Graphic Simulation for Shortest & 2nd shortest path in a Weighted Graph

#include<stdio.h>
#include<conio.h>
#include<graphics.h>
#include<dos.h>
float
sum=0,w=0,s,wn,v[8],td=0,e,i,j,n,w1[8],j1[8],arr[8],arr1[8],e1,count,d2,y1
;
float var,a[8][8],d[8],p[8],n1,c,c1,w2;
void main()
{
int gd=DETECT,gm;
clrscr();
void draw(float,float);
void dijkstra(float s,float e,float v1[8],float d1[8],float p1[8],float
a1[8][8],float n);
void ssp();
void path();
void initial();
printf("There are 8 routers in each subnet
");
n=8;
for(i=0;i<n;i++)
{
for(j=0;j<n;j++)
{
a[i][j]=32767;
}}
printf("Enter the weight between 0 & 1 : ");
scanf("%f",&a[0][1]);
a[1][0]=a[0][1];
printf("Enter the weight between 0 & 3 : ");
scanf("%f",&a[0][3]);
a[3][0]=a[0][3];
printf("Enter the weight between 1 & 5 : ");
scanf("%f",&a[1][5]);
a[5][1]=a[1][5];
printf("Enter the weight between 1 & 2 : ");
scanf("%f",&a[1][2]);
a[2][1]=a[1][2];
printf("Enter the weight between 2 & 4 : ");
scanf("%f",&a[2][4]);
a[4][2]=a[2][4];
printf("Enter the weight between 2 & 3 : ");
scanf("%f",&a[2][3]);
a[3][2]=a[2][3];
printf("Enter the weight between 3 & 7 : ");
scanf("%f",&a[3][7]);
a[7][3]=a[3][7];
printf("Enter the weight between 4 & 5 : ");
scanf("%f",&a[4][5]);
a[5][4]=a[4][5];
printf("Enter the weight between 4 & 7 : ");
scanf("%f",&a[4][7]);
a[7][4]=a[4][7];
printf("Enter the weight between 5 & 6 : ");
scanf("%f",&a[5][6]);
a[6][5]=a[5][6];
printf("Enter the weight between 6 & 7 : ");
scanf("%f",&a[6][7]);
a[7][6]=a[6][7];
printf("Enter source and destination node from network 1 ");
scanf("%f %f",&s,&e);
clrscr();
initgraph(&gd,&gm,"c:\tc\bgi");
setcolor(WHITE);
fillellipse(20,100,7,7);fillellipse(85,50,7,7);
fillellipse(150,100,7,7);fillellipse(85,150,7,7);
fillellipse(320,100,7,7);fillellipse(385,50,7,7);
fillellipse(450,100,7,7);fillellipse(385,150,7,7);
w1[0]=20;w1[1]=85;w1[2]=150;w1[3]=85;w1[4]=320;
w1[5]=385;w1[6]=450;w1[7]=385;
j1[0]=100;j1[1]=50;j1[2]=100;j1[3]=150;j1[4]=100;j1[5]=50;
j1[6]=100;j1[7]=150;
initial();
setcolor(GREEN);
for(i=0;i<n;i++)
{
v[i]=32767;
d[i]=32767;
p[i]=0;
}
w=s;
d[s]=0;
v[s]=s;
td=0;
dijkstra(s,e,v,d,p,a,n);
path();
c=w1[e];
c1=j1[e];
printf("One more packet ?(Type 1 if yes) ");
scanf("%f",&count);
path();
if(count==1)
ssp();
path();
w=e;
setcolor(GREEN);
count=0;
printf("Enter source and destination node from network 2 ");
scanf("%f %f",&s,&e);
a[0][1]=2;
a[0][3]=6;
a[1][2]=2;
a[1][5]=7;
a[2][3]=1;
a[2][4]=2;
a[4][5]=3;
a[5][6]=3;
a[4][7]=2;
a[6][7]=2;
a[3][7]=4;
a[1][0]=2;
a[3][0]=6;
a[2][1]=2;
a[5][1]=7;
a[3][2]=1;
a[4][2]=2;
a[5][4]=3;
a[6][5]=3;
a[7][4]=2;
a[7][6]=2;
a[7][3]=4;
setcolor(WHITE);
fillellipse(20,400,7,7);fillellipse(85,350,7,7);
fillellipse(150,400,7,7);fillellipse(85,450,7,7);
fillellipse(320,400,7,7);fillellipse(385,350,7,7);
fillellipse(450,400,7,7);fillellipse(385,450,7,7);
w1[0]=20;w1[1]=85;w1[2]=150;w1[3]=85;w1[4]=320;
w1[5]=385;w1[6]=450;w1[7]=385;
j1[0]=400;j1[1]=350;j1[2]=400;j1[3]=450;j1[4]=400;j1[5]=350;
j1[6]=400;j1[7]=450;
initial();
setcolor(GREEN);
for(i=0;i<n;i++)
{
v[i]=32767;
d[i]=32767;
p[i]=0;
}
w=s;
d[s]=0;
v[s]=s;
td=0;
line(c,c1,w1[s],j1[s]);
delay(2000);
dijkstra(s,e,v,d,p,a,n);
path();
if(count==1)
ssp();
path();
getch();
}
void dijkstra(float s,float e,float v1[8],float d1[8],float p1[8],float
a1[8][8],float n)
{
while((p1[e])==0)
{
for(i=0;i<n;i++)
{
if((a1[w][i]+td)<d1[i]&&i!=w&&a1[w][i]!=32767)
{
d1[i]=a1[w][i]+td;
d2=d1[i];
v1[i]=w;
}}
sum=32767;
for(i=0;i<n;i++)
{
if(d1[i]<sum&&i!=s&&p1[i]!=1)
{
sum=d1[i];
wn=i;
}}
p1[wn]=1;
td=d1[wn];
w=wn;
}
}
void draw(float w,float v1)
{
float s,x,y;
s=(j1[v1]-j1[w])/(w1[v1]-w1[w]);
if(s<0)
s=s*-1;
x=w1[w];
y=j1[w];
moveto(x,y);
if(x==w1[v1])
{
while(y!=j1[v1])
{
if(y>j1[v1])
{
line(x,y,x,y-1);
delay(10);
y=y-1;
}
else
{
line(x,y,x,y+1);
delay(10);
y=y+1;
}}}
if(y==j1[v1])
{
while(x!=w1[v1])
{
if(x>w1[v1])
{
line(x,y,x-1,y);
delay(10);
x=x-1;
}
else
{
line(x,y,x+1,y);
delay(10);
x=x+1;
}}}
if(x<w1[v1]&&y<j1[v1])
{
while(x!=w1[v1])
{
line(x,y,x+1,y+s);
delay(10);
x=x+1;
y=y+s;
}}
if(x>w1[v1]&&y>j1[v1])
{
while(x!=w1[v1])
{
line(x,y,x-1,y-s);
delay(10);
x=x-1;
y=y-s;
i=i+1;
}}
if(x>w1[v1]&&y<j1[v1])
{
while(x!=w1[v1])
{
line(x,y,x-1,y+s);
delay(10);
x=x-1;
y=y+s;
i=i+1;
}}
if(x<w1[v1]&&y>j1[v1])
{
while(x!=w1[v1])
{
line(x,y,x+1,y-s);
delay(10);
x=x+1;
y=y-s;
i=i+1;
}
}}
void ssp()
{
d2=y1=32767;
setcolor(RED);
e1=e;
for(i=0;i<n;i++)
{
arr1[i]=v[i];
arr[i]=v[i];
}
while(e1!=s)
{
var=a[e1][arr1[e1]]=a[arr1[e1]][e1];
a[e1][arr1[e1]]=a[arr1[e1]][e1]=32767;
for(i=0;i<n;i++)
{
v[i]=32767;
d[i]=32767;
p[i]=0;
}
w=s;d[s]=0;
v[s]=s;
td=0;
dijkstra(s,e,v,d,p,a,n);
if(d2<y1)
{
y1=d2;
for(i=0;i<n;i++)
arr[i]=v[i];
}
a[e1][arr1[e1]]=a[arr1[e1]][e1]=var;
e1=arr1[e1];
}}
void path()
{
while(w!=s)
{
if(count==0)
{
draw(w,v[w]);
w=v[w];
}
else
{
draw(w,arr[w]);
w=arr[w];
}}}
void initial()
{
line(w1[0],j1[0],w1[1],j1[1]);
line(w1[0],j1[0],w1[3],j1[3]);
line(w1[1],j1[1],w1[5],j1[5]);
line(w1[1],j1[1],w1[2],j1[2]);
line(w1[2],j1[2],w1[4],j1[4]);
line(w1[2],j1[2],w1[3],j1[3]);
line(w1[3],j1[3],w1[7],j1[7]);
line(w1[4],j1[4],w1[5],j1[5]);
line(w1[4],j1[4],w1[7],j1[7]);
line(w1[5],j1[5],w1[6],j1[6]);
line(w1[6],j1[6],w1[7],j1[7]);
}
Info person

#include<iostream.h>
#include<conio.h>
class person
{
	char *name,*add,*eadd;
	long pno,ctzno;
	public:
	void info()
  {
	cout<<"Enter the name:";
	cin>>name;
	cout<<"Enter the address:";
	cin>>add;
	cout<<"Enter the email address:";
	cin>>eadd;
	cout<<"Enter the phone no:";
	cin>>pno;
	cout<<"Enter the citizenship no:";
	cin>>ctzno;
  }
  void PrintInfo()
  {
	cout<<"********************Person Data***************************"<<endl;
	cout<<"Name:"<< name <<endl;
	cout<<"Address:"<<add<<endl;
	cout<<"E-mail address:"<<eadd<<endl;
	cout<<"Phone no:"<<pno<<endl;
	cout<<"Citizenship no:"<<ctzno<<endl;
	cout<<"********************Thank YOU******************************"<<endl;
  }
};
void main()
{
	person d;
	d.info();
	d.PrintInfo();
	getch();
}
Inheritance Example

class Person
{
public:
	Person(const string& firstName, const string& lastName) : _firstName(firstName), _lastName(lastName);
	string getFirstName() { return _firstName;};
	string getLastName() { return _lastName;};
private:
	string _firstName;
	string _lastName;
}

class Mother : public Person
{
   public:
	Mother(const string& firstName, const string& lastName) : Person(firstName, LastName);
	~Mother();
	Person* hasBaby(const string& firstName);
private:
	vector<Person*> children;
};

Person* Mother::hasBaby(const string& firstName);
{
	Person* newBaby = new Person(firstName, getLastName());
	children.pushback(newBaby);
	return newBaby;
}

int main(void)
{
   Mother sue("Sue", "Smith");
   Person joe = sue.hasBaby("Joe");
   Person kay = sue.hasBaby("Kay");

   cout << "Baby Joe's last name is: " << joe.getLastName() << endl;
   cout << "Baby Kay's last name is: " << kay.getLastName() << endl;

   return 0;
}
Job Sequencing with Deadlines while Maximizing Profits

#include<iostream>
#include<list>
using namespace std;
class node{
public:
int d,p,t;
bool operator < (node n)
{
if(p<n.p)
return 1;
else
return 0;
}
};

int main()
{
int d,p,t,i,profit,min,n;
list<node> lst;
node pt;
cout<<"Enter no of entries
";
cin>>n;
for(i=0;i<n;i++)
{
cout<<"enter data(p,d,t)
";
cin>>p>>d>>t;
pt.d=d;
pt.p=p;
pt.t=t;
lst.push_back(pt);
}
int maxd=0;
lst.sort();
lst.reverse();
cout<<"
sorted list
";
list <node> :: iterator itr=lst.begin();
while(itr!=lst.end()){
pt=*itr;
if(maxd<pt.d) maxd=pt.d;
cout<<pt.p<<endl<<pt.d<<endl<<pt.t<<endl<<endl;
itr++;
}
//cout<<" max deadline "<<maxd<<endl;
itr=lst.begin();
profit=0;
while(itr!=lst.end())
{

  pt=*itr;

 if(pt.d>=pt.t)
min=pt.t;
else
min=pt.d;

if(maxd>=min)
            profit+=min*pt.p;
            else
            profit+=maxd*pt.p;
            itr++;maxd=maxd-min;

}
cout<<"profit is : "<<profit<<endl;
return 0;
}
Matrix Multiplication

void main()
{
	int row1=0,
	    col1=1,	
	    row2=0,
	    col2=0,
	    **matrix1,
	    **matrix2,
	    **result;

          clrscr();
          printf(" Enter number of row for first matrix ");
          scanf("%d",&row1);
   
          while (col1!=row2)
   	    {	
	          printf(" Enter number of column for first matrix ");
	          scanf("%d",&col1);

	          printf(" Enter number of row for second matrix ");
	          scanf("%d",&row2);
		
	         if (col1!=row2)	
	         {
                   clrscr();
				   printf("Column number of first matrix must be same as the row number of second matrix");	    
	         }
		
		
	   }


          printf(" Enter number of column for second matrix ");
          scanf("%d",&col2);
         
          matrix1=init(matrix1,row1,col1);
          matrix2=init(matrix2,row2,col2);
         /* setting values in matrix */
		  printf("First matrix \n");
          set(matrix1,row1,col1);
		  printf("Second matrix \n");
          set(matrix2,row2,col2);
          /* printint matrix */
          clrscr();
          printf("       [ First matrix ]\n");		
          get(matrix1,row1,col1);
          printf("       [ Second matrix ]\n");		 	
          get(matrix2,row2,col2);		

		  printf("       [ Multiplication Result ]\n");
          result=mul(matrix1,matrix2,row1,col2,col1);
          get(result,row1,col2);	
		  printf("\n\t\t Thanks  from debmalya jash");
          getch();
          free(matrix1);
	  free(matrix2);
	  fress(result); 	
         
	
} /* end main */


/* to initialize matrix */
int** init(int** arr,int row,int col)
{
               int i=0,
                   j=0;

	arr=(int**)malloc(sizeof(int)*row*col);

	for(i=0;i<row;i++)
	{
		for(j=0;j<col;j++)
		{
			*((arr+i)+j)=(int*)malloc(sizeof(int));
            *(*(arr+i)+j)=0; 
		}
	}
	return arr;
}

/* to set value in matrix */
int** set(int** arr,int row,int col)
{
	int i=0,
        j=0,
	    val=0;
               
            for(i=0;i<row;i++)
	{
		for(j=0;j<col;j++)
		{
			printf("Enter value for row %d col %d  :",(i+1),(j+1));
			scanf("%d",&val);
			*(*(arr+i)+j)=val;
		}
	}
	return arr;
}


/* print values of the passed matrix */
void get(int** arr,int row,int col)
{
	int i=0,
	    j=0;

	for(i=0;i<row;i++)
	{
		for(j=0;j<col;j++)
		{
			printf("%d\t",*(*(arr+i)+j));
		}
		printf("\n");
	}	
}

/* mutiply two matrices and return the resultant matrix */
int** mul(int** arr1,int** arr2,int row,int col,int col1)
{
	int  **result,
	         i=0,
	         j=0,
	         k=0;

	result=init(result,row,col);
	
	for(i=0;i<row;i++)
	{
		for(j=0;j<col;j++)
		{
			for(k=0;k<col1;k++)
			{
				printf("%dX%d(%d)",*(*(arr1+i)+k),*(*(arr2+k)+j),(*(*(arr1+i)+k))*(*(*(arr2+k)+j))); 
				*(*(result+i)+j)+=(*(*(arr1+i)+k))*(*(*(arr2+k)+j));
				
				if (k!=(col1-1))
					printf("+");
			}
			printf("\t");
		}
		printf("\n");	
	}
	return result;
Merge Sort

#include <iostream.h>
int a[50];
void merge(int,int,int);
void merge_sort(int low,int high)
{
 int mid;
 if(low<high)
 {
  mid=(low+high)/2;
  merge_sort(low,mid);
  merge_sort(mid+1,high);
  merge(low,mid,high);
 }
}
void merge(int low,int mid,int high)
{
 int h,i,j,b[50],k;
 h=low;
 i=low;
 j=mid+1;

 while((h<=mid)&&(j<=high))
 {
  if(a[h]<=a[j])
  {
   b[i]=a[h];
   h++;
  }
  else
  {
   b[i]=a[j];
   j++;
  }
  i++;
 }
 if(h>mid)
 {
  for(k=j;k<=high;k++)
  {
   b[i]=a[k];
   i++;
  }
 }
 else
 {
  for(k=h;k<=mid;k++)
  {
   b[i]=a[k];
   i++;
  }
 }
 for(k=low;k<=high;k++) a[k]=b[k];
}
void main()
{
 int num,i;

cout<<"*******************************************************************
*************"<<endl;
 cout<<"                             MERGE SORT PROGRAM
"<<endl;

cout<<"*******************************************************************
*************"<<endl;
 cout<<endl<<endl;
 cout<<"Please Enter THE NUMBER OF ELEMENTS you want to sort [THEN 
PRESS
ENTER]:"<<endl;
 cin>>num;
 cout<<endl;
 cout<<"Now, Please Enter the ( "<< num <<" ) numbers (ELEMENTS) [THEN
PRESS ENTER]:"<<endl;
 for(i=1;i<=num;i++)
 {
  cin>>a[i] ;
 }
 merge_sort(1,num);
 cout<<endl;
 cout<<"So, the sorted list (using MERGE SORT) will be :"<<endl;
 cout<<endl<<endl;

 for(i=1;i<=num;i++)
 cout<<a[i]<<"	";

 cout<<endl<<endl<<endl<<endl;

}
Quadratic Equation

#include <math.h>
#include <iostream>
using namespace std;
struct graphPoint{
	double x, y;
	};
class QuadraticEquation{
	public:
	QuadraticEquation(double A = 0.0, double B = 0.0, double C = 0.0) : a(A), b(B), c(C){
		xintercepts[0].x = 0.0;
		xintercepts[0].y = 0.0;
		xintercepts[1].x = 0.0;
		xintercepts[1].y = 0.0;
		}
	~QuadraticEquation(){}


	int getxintercepts(){


		double temp = (b * b) - (4 * a * c);
		if(temp < 0){
			cout << "##-Square Root Error:\n"
			     << " ##- SquareRoot ( " << temp << " )\n";
			return 1;
			}

		temp = sqrt ( temp );

		xintercepts[0].x = (b * -1) - temp;
		xintercepts[0].x = xintercepts[0].x / (2 * a);

		xintercepts[1].x  = (b * -1) + temp;
		xintercepts[1].x = xintercepts[1].x / (2 * a);
		return 0;
		}

	void displayequation(){
		if(a != 0){
			cout << a;
			cout << "x^2";}
		if(b >= 1 & a != 0)
			cout << "+";
		if(b != 0)
			cout << b << "x";
		if(c > 0)
			cout << "+";
		if(c != 0)
			cout << c;
		if(a == 0 & b == 0 & c == 0)
			cout << 0;
		cout << "=0" << endl;
		}

	double a, b, c;
	graphPoint xintercepts[2];
	};







void creditsHelp();
void wierdGetch();



int main(int argc, char *argv[]){
cout << "@-Quadratic Equation Solver\n"
     << " @-Karlan Mitchell karlanmitchell-at-comcast-dot-net\n"
     << " @-For Credits/Help enter 0 for A\n";

double a,b,c;

cout << "Enter in values for equation\n";
for(;;){
  cout << "A: ";
  cin >> a;
  if(a == 0.0){
	creditsHelp();
	continue;
	}
  break;
  }
cout << "B: ";
cin >> b;
cout << "C: ";
cin >> c;

QuadraticEquation test(a,b,c);//create the class

test.displayequation();//display the equation with the class function

switch(test.getxintercepts()){/* I am using a switch here instead of
                               * an if because I constanly add/remove
			       * error messages to this function*/
	case 1:
		cout << "!!-Equation not possible\n"
		     << " !!-If you know that it is possible, please contact me about a bug\n";
		exit(1);
		break;
	}

cout << "x = " << test.xintercepts[0].x << " | " << test.xintercepts[1].x << endl;
cout << "(" << test.xintercepts[0].x << ", 0) & (" << test.xintercepts[1].x << ", 0)\n";


wierdGetch();
return 0;
}
void creditsHelp(){

	cout << "\nThis program was created by me to make my math homework easier\n\n"

	     << "What it does:\n"
	     << "It takes in the 'a', 'b', and 'c' values for a quadratic equation\n"
	     << "which equals zero.\n"
	     << "EX: \"x^2 - 3x + 2 = 0\" is equal to \"(x - 2)(x - 1) = 0\"\n"
	     << "    ax^2 + bx + c = 0\n"
	     << "    The 'a','b', and 'c' values for the equation would be 1, -3, and 2\n"
	     << "    The x intercepts for this would be (2, 0) and (1, 0)\n"
	     << "    2^2 - 3(2) + 2 = 0 and 1^2 - 3(1) + 2 = 0\n\n"

	     << "Why would I use this:\n"
	     << "1) You are in Algebra I/II or Geometry\n"
	     << "2) Your too lazy to do the quadratic equation on your own which is:\n"
	     << "   x=( -b +/- sqrt(bb - 4ac) ) / (2a)\n";
	wierdGetch();
	exit(0);
	}
void wierdGetch(){
	cout << "Press enter to exit...";
	getchar();getchar();//Why do I need, two?  The world may never know
	}
Read Text Files

void main()
{
 char pcMyLines[10000];

 ReadLines("C:\\MyTestFile.txt", 10, 5, pcMyLines, 12345);
}

// This function reads n lines from a file
// Returns the amount of bytes read
int ReadLines(const char *pcFile, const int iStartLine, const int iTotLines, char *pcBuffer, const int iBufLen)
{
 FILE *fSrc;
 int   iLines = 0, j, iPos, iByteCount = 0;

 // Try to open the file
 if(fSrc = fopen(pcFile, "r"))
 {
   // Try to locate the starting line
   if(iPos = GetLinePos(fSrc, iStartLine))
   {
     // Set the starting position
     if(!fseek(fSrc, iPos, SEEK_SET))
     {
       // Read the lines
       for(iLines=0;iLines<iTotLines;iLines++)
       {
         // Read the line
         if((j = ReadLine(fSrc, iPos, pcBuffer, iBufLen - iByteCount)) == -1) break;
         iByteCount += j;
       }
     }
   }

   // Close the file
   fclose(fSrc);
 }

 // Return the amount of bytes in the buffer, or -1 for failure
 return iLines == iTotLines ? iByteCount : -1;
}


// This function reads a single line from a file
int ReadLine(FILE *fSrc, const int iStartPos, char *pcBuffer, const int iBufLen)
{
 int iCount = 0;

 // Set the starting position
 if(!fseek(fSrc, iStartPos, SEEK_SET))
 {
   // Keep reading characters while we can
   while(!feof(fSrc) && (iCount < iBufLen))
   {
     // Read the character
     pcBuffer[iCount] = (char)fgetc(fSrc);
     if(pcBuffer[iCount++] == '\n') break;
   }
 }
 else iCount = -1;

 return iCount;
}

// This function locates a line in a file
// Returns the position of the line in the file
int GetLinePos(FILE *fSrc, const int iLine, const int iStartPos /* 0 */)
{
 char  pcBuffer[4096];
 int   i, iPos = 0, iLines = 0, iBytes;

 // Set the start position
 if(!fseek(fSrc, iStartPos, SEEK_SET))
 {
   // Read the (next) block of data
   while(iBytes = fread(pcBuffer, sizeof(char), 4096, fSrc))
   {
     // Go through the block
     for(i=0;i<iBytes;i++)
     {
       // Do we have a new line?
       if(pcBuffer[i] == '\n')
       {
         // Update the line count
         iLines++;

         // Have we reached the desired line?
         if(iLines == iLine)
         {
           // Store the position
           iPos += i;
           break;
         }
       }
     }

     // Update the position
     iPos += iBytes;
   }
 }

 // Return the position of the line in the file, or -1 for failure
 return iLines == iLine ? iPos : -1;
}
Realtime Clock

#include<stdio.h>
#include<dos.h>
main()
 {
   int c,hr=1;
   union REGS in;
   clrscr();

  while(!kbhit())
	{
	in.h.ah=0x02;
	int86(0x1a,&in,&in);
	clrscr();
	hr=1;
	printf("\n\n\n\t");
	fun(in.h.ch , hr);
	printf(":");
	hr=0;
	fun(in.h.cl,hr);
	printf(":");
	fun(in.h.dh,hr);
	delay(250);
	}

 }


fun(int a,int j)
  {
    int i,k;
	i=a;
	a&=0x0f;
	i&= 0xf0;
	i>>=4;
       /*	if(j==0)*/
	printf("%d%d",i,a);
/*	else
	{
	i=i<<4;
	i=i|a;
	i-=0x0c;
	printf("%d",i-6);
	}*/
    }
Regular exp to nfa

# include <stdio.h>
# include <conio.h>
# include <string.h>
# include <ctype.h>
// regular expression to nfa by g.ram kumar
// works for everything but produces excessive epsilon transitions
int ret[100];
static int pos=0;
static int sc=0;
void nfa(int st,int p,char *s)
{    int i,sp,fs[15],fsc=0;
	sp=st;pos=p;sc=st;
	while(*s!=NULL)
	{if(isalpha(*s))
	    {ret[pos++]=sp;
		ret[pos++]=*s;
		ret[pos++]=++sc;}
	if(*s=='.')
		{sp=sc;
		 ret[pos++]=sc;
		 ret[pos++]=238;
		 ret[pos++]=++sc;
		 sp=sc;}
	if(*s=='|')
		{sp=st;
		 fs[fsc++]=sc;}
	if(*s=='*')
		{ret[pos++]=sc;
		 ret[pos++]=238;
		 ret[pos++]=sp;
		 ret[pos++]=sp;
		 ret[pos++]=238;
		 ret[pos++]=sc;
		 }
	 if (*s=='(')
		{char ps[50];
		 int i=0,flag=1;
		 s++;
		   while(flag!=0)
			{ps[i++]=*s;
			 if (*s=='(')
				flag++;
			 if (*s==')')
				flag--;
			 s++;}
			 ps[--i]='\0';
			 nfa(sc,pos,ps);
			 s--;
		}
	 s++;
	}
	sc++;
	  for(i=0;i<fsc;i++)
		 {ret[pos++]=fs[i];
		  ret[pos++]=238;
		  ret[pos++]=sc;
		 }
		  ret[pos++]=sc-1;
		  ret[pos++]=238;
		  ret[pos++]=sc;
}
void main()
{    int i;
	char *inp;
	clrscr();
	printf("enter the regular expression :");
	gets(inp);
	nfa(1,0,inp);
	printf("\nstate  input  state\n");
	for(i=0;i<pos;i=i+3)
		 printf("%d     --%c-->      %d\n",ret[i],ret[i+1],ret[i+2]);
	printf("\n");
	getch();
}

Shows the number of wrods and characters entered

#include<iostream.h>
#include<conio.h>

main()
{
  int chcount=0;
  int wdcount=1;
  char ch;

  clrscr();
  cout<<"\n \n This program will count the number of characters and words that u have entered";
  cout<<"\n Type whaterver u like to followed by an enter ....\n\n";

  while ((ch=getche())!='\r')
  {
     if(ch==' ')
	wdcount++;
     else
	chcount++;
  }

  cout<<"\n\n The number of words are : "<<wdcount<<endl;
  cout<<"\n The number of characters are : "<<chcount<<endl;
  getch();
}
Simple calculator 2

#include<stdio.h>
#include<math.h>

main()
{
  int x,y,ans,i;
  int choice;
  float div;
  char loop;
  ans=0;

  clrscr();

  do
  {
      printf("\n Do you wish to continue (Y/N) : ");
      scanf("%s",&loop);

      if (loop=='y' || loop=='Y')
      {
      clrscr();
      printf("\n Enter any two numbers ");
      printf("\n --------------------- ");

      printf("\n\n Enter the first number : ");
      scanf("%d",&x);

    printf("\n Enter the second number : ");
     scanf("%d",&y);

     clrscr();
     printf("\n Select the operation to be carried out ");
     printf("\n -------------------------------------- ");

     printf("\n 1. Addition ");
     printf("\n 2. Substraction ");
     printf("\n 3. Multiplication ");
     printf("\n 4. Division ");

     printf("\n Enter your choice : ");
     scanf("%d",&choice);

  switch(choice)
  {
     case 1 :
     {
	   ans = x+y;
	   printf("\n Answer = %d",ans);
	   break;
     }
     case 2 :
     {
	      ans = x-y;
	      printf("\n Answer = %d", ans);
	      break;
     }
     case 3 :
     {
	      ans = x*y;
	      printf("\n Answer = %d", ans);
	      break;
     }
     case 4:
     {
	      div = x/y;
	      printf("\n Answer = %.2f", div);
	      break;
     }
     default:
	   printf("\n\n Illegal operation......");
	   break;
   }
  }
  else
      printf("\n Bye....... Bye...........");
      getch();
 }while(loop=='y' || loop=='Y');
}
Simple Calculator

#include <stdio.h>

void main()
{
	double number1 = 0.0;
   double number2 = 0.0;
   char operation = 0;

   printf("\nEnter the calculation\n");
   scanf("%lf %c %lf", &number1, &operation, &number2);

   switch(operation)
   {
   	case '+':
      	printf("= %lf\n", number1+ number2);
      	break;

      case '-':
      	printf("= %lf\n", number1 - number2);
      	break;

   	case '*':
      	printf("= %lf\n", number1 * number2);
      	break;

      case '/':
      	if(number2 == 0)
         	printf("\n\n\aDivision by Zero #ERROR!\n");
         else
         	printf("= %lf\n", number1 / number2);
            break;

      case '%':
      	if((long)number2 == 0)
         	printf("\n\n\aDevision by Zero #ERROR!\n");
         else
         	printf("= %ld\n", (long)number1 % (long)number2);
            break;

      default:
      	printf("\n\n\aIllegal operation!");
   }
}
Student

#include<iostream.h>

#define NUM_TEST 10
#define NUM_STUDENTS 4

int test_grades [NUM_STUDENTS][NUM_TEST];

void enter_Grade()
{

  int student,
      test,
      more=1,
      grade;

  char yorn;

  cout << "\nenter a test grade\n";

 while(more)
 {
  cout <<"\Student #";
  cin>>student;
  cin.ignore(80,'\n');

  cout << "\ntest #";
  cin>>test;
  cin.ignore(80,'\n');

  cout << "\ngrade #";
  cin>>grade;
  cin.ignore(80,'\n');

 test_grades[student-1][test-1] =grade;

  cout << "\nanother grade?";
  cin >>yorn;
  cin.ignore(80,'\n');

 if (yorn=='n')
    more=0;
 }
}

void test_Avarege()
{
  int student=0,
  anotherA=1,
  testdid,
  testNum,
  Total;

 while(anotherA)
  {
  student=0;
  Total=0;
  testdid=0;

  cout << "\nTest Avarege\n\n";

  cout << "\nNumber of the Student";
  cin >>student;

  for (testNum=0; testNum<=3; testNum++)
  {
   if (test_grades[student-1][testNum])
   {
   testdid++;
   Total+= test_grades[student-1][testNum];

   cout << "\nTest #: "<<testNum+1 <<" Grade: "<<test_grades[student-1][testNum]<<"\n";
   }
   else
   cout << "\n\n Student "<<student<<"did not take the test" <<testNum+1<<"\n";
   }
   cout << "\n Student has the avarege of " <<Total/testdid;

   cout << "\nDo you want to see another avarege? 0 to end or 1 to continue . ";
   cin>>anotherA;
 }
  return;
}
get_Help()

{
 cout << "\nThank you for enter this program. This is that way it works:";

 cout << "\n\n1st Option, Enter Grade:";
 cout << "\nIf you choose this option you will be able to enter a gradeto a ";
 cout << "\ndisere student, just remenber that is only 4 students";

 cout << "\n\n2nd option, Test Avarege: ";
 cout << "\nif you choose this option you will be anle to see the overroll ";
 cout << "\navarege of the student that you chose";

 cout << "\n\n3er option, Help:";
 cout << "\nif you chose this optionthe user will be able to see the insatruction";
 cout << "\nabout how this program works";

 cout << "\n\n4th option, Exit";
 cout << "\nif you chosse this option the user will be able to exit the program";
 cout << "\nI hope you like what i did";
 return 0;
}

int main()
{
 int option=0;
 int hold;

  while (option!=4)
  {
  while ((option<1)||(option>4))
  {

  cout << "\nWelcome to my 3th program by Cecilio O. Uribe";
  cout << "\nChose any option follow by the enter key\n\n";
  cout << "\n1. Enter Grade";
  cout << "\n2. Test Avarege";
  cout << "\n3. Help";
  cout << "\n4. Exit\n\n";
  cin >> option;
  }
  if(option==1)
   {
    enter_Grade();
    option=0;
   }
  if(option==2)
   {
    test_Avarege();
    option=0;
   }
  if(option==3)
   {
    get_Help();
    option=0;
   }

   }
     cout << "LATER!";
     cin >> hold;

   return 0;
}
Structure

#include<stdio.h>
#include<conio.h>
#include<malloc.h>
#include<string.h>

typedef struct
{
	char name[6];
	int roll;
}student;
void main()
{
	student *p;
	int n,i,temp;
	FILE *k;
	k=fopen("k.txt","w");
	printf("enter the numbe of students ");
	scanf("%d",&n);
	p=(student *)malloc(n*sizeof(student));
	for(i=0;i<n;++i)
	{
		printf("enter the name of student %d ",i+1);
		scanf("%s",(p+i)->name);
		printf("enter the roll number of student %d ",i+1);
		scanf("%d",&(p+i)->roll);
	}
	for(i=0;i<n;++i)
	{
		printf("\n name of student %d is %s",i+1,(p+i)->name);
		printf("\n roll number of student %d is %d",i+1,(p+i)->roll);
	}
	getch();
	fclose(k);
}
String Reverse code

# include <iostream.h>
# include <string.h>

void reverseit(char array[],int no)
{ char c; int len,x, mid=0;
	if(no==0)
	{for(len=0,x=0; array[x] !='\x0';len++,x++); }
	else
	{ len = 0; len = no; }

	mid = (len-1)/2;

	for(int i=0,j=len-1; i <=mid; i++,j--)
	{ c = array[i];
	  array[i] = array[j];
	  array[j] = c;
	}
	cout << endl<<array;
}

void main()
{ char data[80]; int nos=0;
	cout <<"enter string to reverse it  "; cin.getline(data,80);
	reverseit(data,0);
	cout <<endl<<"enter string to reverse it  "; cin.getline(data,80);
	cout <<endl<<"enter Nos to reversed "; cin >>nos;
	reverseit(data,nos);
}
String matching in linear-time

#include <iostream>
#include <fstream>
#include <string>
#include <vector>

typedef std::vector<int> int_vec;

class string_search
{
  int_vec shifts;
  void compute_shifts(const std::string &pattern);
public:
  int find_first(const std::string &text, const std::string &pattern);
  int_vec find_all(const std::string &text, const std::string &pattern);

};

// create the shift-lookup-table
void string_search::compute_shifts(const std::string &pattern)
{
  int next_shift = 0;
  shifts.clear();
  shifts.push_back(0); // shift to the first character

  // start with the second character, since the shift to the first is always 0
  for(int i = 1; i < pattern.length(); i++)
  {
    while(next_shift > 0 && pattern[next_shift] != pattern[i])
      next_shift = shifts[next_shift];

    if(pattern[next_shift] == pattern[i])
      next_shift++;

    shifts.push_back(next_shift);
  }
}

// search the string and return when the first occurrence is found
int
string_search::find_first(const std::string &text, const std::string &pattern)
{
  int next_shift = 0;
  compute_shifts(pattern);
  for(int i = 0; i < text.length(); i++)
  {
    while(next_shift > 0 && pattern[next_shift] != text[i])
      next_shift = shifts[next_shift - 1];

    if(pattern[next_shift] == text[i])
      next_shift++;

    if(next_shift == pattern.length())
      return i - (pattern.length() - 1); // found the first so return
  }
  return -1;
}

// search the string and put every occurence in a vector
int_vec
string_search::find_all(const std::string &text, const std::string &pattern)
{
  int next_shift = 0;
  int_vec positions;
  compute_shifts(pattern);
  for(int i = 0; i < text.length(); i++)
  {
    while(next_shift > 0 && pattern[next_shift] != text[i])
      next_shift = shifts[next_shift - 1];

    if(pattern[next_shift] == text[i])
      next_shift++;

    if(next_shift == pattern.length())
    {
      positions.push_back(i - (pattern.length() - 1)); // found one, put in list
      next_shift = shifts[next_shift - 1]; // restart pattern with last shift
    }
  }
  return positions;
}

int main(int argc, char **argv)
{
  if(argc <= 2){
    cout << "Usage: " << argv[0] << " filename searchpattern" << endl;
    return 0;
  }
  std::string pattern = argv[2];

  // read the file. Since the file is read like this all white-characters
  // are eaten, so a search including white-characters will fail...
  fstream fs;
  std::string text, temp;
  fs.open(argv[1], ios::in);
  while(!fs.eof()){
    fs >> temp;
    text += temp;
  }
  fs.close();

  // search the file
  string_search search;
  int_vec pos_list = search.find_all(text, pattern);

  // print out result
  std::vector<int>::iterator it;
  cout << "Found " << pos_list.size() << " occurrences" << endl;
  for(it = pos_list.begin(); it != pos_list.end(); it++){
    temp = text.substr(*it, pattern.length());
    cout << "Pos=" << *it << " == " << temp << endl;
  }
}

String matching in linear-time

#include <iostream>
#include <fstream>
#include <string>
#include <vector>

typedef std::vector<int> int_vec;

class string_search
{
  int_vec shifts;
  void compute_shifts(const std::string &pattern);
public:
  int find_first(const std::string &text, const std::string &pattern);
  int_vec find_all(const std::string &text, const std::string &pattern);

};

// create the shift-lookup-table
void string_search::compute_shifts(const std::string &pattern)
{
  int next_shift = 0;
  shifts.clear();
  shifts.push_back(0); // shift to the first character

  // start with the second character, since the shift to the first is always 0
  for(int i = 1; i < pattern.length(); i++)
  {
    while(next_shift > 0 && pattern[next_shift] != pattern[i])
      next_shift = shifts[next_shift];

    if(pattern[next_shift] == pattern[i])
      next_shift++;

    shifts.push_back(next_shift);
  }
}

// search the string and return when the first occurrence is found
int
string_search::find_first(const std::string &text, const std::string &pattern)
{
  int next_shift = 0;
  compute_shifts(pattern);
  for(int i = 0; i < text.length(); i++)
  {
    while(next_shift > 0 && pattern[next_shift] != text[i])
      next_shift = shifts[next_shift - 1];

    if(pattern[next_shift] == text[i])
      next_shift++;

    if(next_shift == pattern.length())
      return i - (pattern.length() - 1); // found the first so return
  }
  return -1;
}

// search the string and put every occurence in a vector
int_vec
string_search::find_all(const std::string &text, const std::string &pattern)
{
  int next_shift = 0;
  int_vec positions;
  compute_shifts(pattern);
  for(int i = 0; i < text.length(); i++)
  {
    while(next_shift > 0 && pattern[next_shift] != text[i])
      next_shift = shifts[next_shift - 1];

    if(pattern[next_shift] == text[i])
      next_shift++;

    if(next_shift == pattern.length())
    {
      positions.push_back(i - (pattern.length() - 1)); // found one, put in list
      next_shift = shifts[next_shift - 1]; // restart pattern with last shift
    }
  }
  return positions;
}

int main(int argc, char **argv)
{
  if(argc <= 2){
    cout << "Usage: " << argv[0] << " filename searchpattern" << endl;
    return 0;
  }
  std::string pattern = argv[2];

  // read the file. Since the file is read like this all white-characters
  // are eaten, so a search including white-characters will fail...
  fstream fs;
  std::string text, temp;
  fs.open(argv[1], ios::in);
  while(!fs.eof()){
    fs >> temp;
    text += temp;
  }
  fs.close();

  // search the file
  string_search search;
  int_vec pos_list = search.find_all(text, pattern);

  // print out result
  std::vector<int>::iterator it;
  cout << "Found " << pos_list.size() << " occurrences" << endl;
  for(it = pos_list.begin(); it != pos_list.end(); it++){
    temp = text.substr(*it, pattern.length());
    cout << "Pos=" << *it << " == " << temp << endl;
  }
}

Telephone

#include<stdio.h>
#include<string.h>
main()
{
 FILE *t,*p;
 char another,choice;
  struct telephone
 {
  char name[30];
  long int code;
  long int number;
  };
  struct telephone data;
  char custname[30];
  long int n;
  long int recsize;

   t=fopen("TELEPHONE.DAT","rb+");
   if(t==NULL)
   {
       t=fopen("TELEPHONE.DAT","wb+");
	   if(t==NULL)
	   {
	     printf("The File can't open\n");
		 exit();
		 }
		 }
     printf("          TELEPHONE DIRECTORY               \n");
	 printf("          *******************               \n");

	 recsize=sizeof(data);

  while(1)
  {
	  printf("\n\n");
   printf("1.Add Records\n");
   printf("2.List Records\n");
   printf("3.Modify Records\n");
   printf("4.Finding Number\n");
   printf("5.Finding Name\n");
   printf("6.Delete Records\n");
   printf("0.Exit\n");
   printf("Your Choice:");

   fflush(stdin);
   choice=getche();

   switch(choice)
   {
   case '1':

	   fseek(t,0,SEEK_END);

	   another='y';

	   while(another=='y')
	   {
		   printf("\nEnter Customer name,Code number and Telephone number\n");
		   scanf("%s  %ld %ld",data.name,&data.code,&data.number);
		   fwrite(&data,recsize,1,t);

		   printf("Add another data(y/n):");
		   fflush(stdin);
		   another=getche();
		   printf("\n");
	   }
	   break;

   case '2':

	   rewind(t); 
	   printf("\n");
	   printf("---------------------------------------------\n");
	   printf("|   CUSTOMER      |   CODE   |  TELEPHONE   |\n");
       printf("---------------------------------------------\n");
       rewind(t);

	   while(fread(&data,recsize,1,t)==1)

	   printf("|  %-18s %-2ld %12ld    |\n\n",data.name,data.code,data.number);
	   printf("--------------------------------------------\n");
       getch();
	   

	   printf("\n");
	   break;

   case '3':
	   another='y';
	   while(another=='y')
	   {
		   printf("\nEnter name of customer to modify:");
		   scanf("%s",custname);
		   rewind(t);
		   while(fread(&data,recsize,1,t)==1)
		   {
			   if(strcmp(data.name,custname)==0)
			   {
				   printf("\nEnter new name,code and telephone number\n");
				   scanf("%s %ld &ld",data.name,&data.code,&data.number);

				   fseek(t,-recsize,SEEK_CUR);
                   fwrite(&data,recsize,1,t);
				   break;
			   }
		   }
		   printf("Modify another record(y/n):");
				   fflush(stdin);
				   another=getche();
				   printf("\n");
	   }

	   break;


   case '4':

	   another='y';
	   while(another=='y')
	   {
	   printf("\nEnter name of customer:");
	   scanf("%s",custname);

	   rewind(t);
	   while(fread(&data,recsize,1,t)==1)
	   {
	   if(strcmp(data.name,custname)==0)
	   {
		   printf("Telephone Number=%ld %ld\n",data.code,data.number);
		   getch();
	   }
	   }
		   printf("Find another number(y/n)? ");
	   fflush(stdin);
	   another=getche();
	   printf("\n");
	   }
	   break;

   case '5':

	   another='y';
	   while(another=='y')
	   {
		   printf("\nEnter number of customer:");
		   scanf("%ld",&n);

		   rewind(t);
		   while(fread(&data,recsize,1,t)==1)
		   {
		   if(data.number==n)
		   {
			   printf("The Name is %s\n",data.name);
			   getch();
		   }
		   }
		   printf("Find another name(y/n)? ");
		   fflush(stdin);
		   another=getche();
		   printf("\n");
	   }
	   break;

   case '6':

	   another='y';
	   while(another=='y')
	   {
		   printf("\nEnter name of customer to delete:");
		   scanf("%s",custname);

		   p=fopen("TEMP.DAT","wb");

		   rewind(t);
		   while(fread(&data,recsize,1,t)==1)
		   {
			   if(strcmp(data.name,custname)!=0)
				   fwrite(&data,recsize,1,p);
		   }
		   fclose(t);
		   fclose(p);

		   remove("TELEPHONE.DAT");
		   rename("TEMP.DAT","TELEPHONE.DAT");

		   t=fopen("TELEPHONE","rb+");
		        
            printf("Delete another record(y/n):");
			fflush(stdin);
			another=getche();
	   }
	   break;


  case '0':

	   printf("\n");
	   fclose(t);
	   exit();
	   }  
   }
   }
Time arithmatic

#include<stdio.h>
#include<conio.h>

typedef struct
{
	int hh,mm,ss;
}time;

time add(time f,time s);
time sub(time f,time s);
time input(void);

void main()
{
	time f,s,ans;
	int ch;
	clrscr();
	do
	{
		printf("\n <1> enter first operand ");
		printf("\n <2> enter second operand ");
		printf("\n <3> time addition ");
		printf("\n <4> time subtraction ");
		printf("\n <5> Exit \n\n");
		do
		{
			printf("enter your choice ");
			scanf("%d",&ch);
		}while(ch<1 || ch>5);
		switch (ch)
		{
			case 1:
				printf("\n enter the time(hh mm ss) ");
				f=input();
				break;
			case 2:
				printf("\n enter the time(hh mm ss) ");
				s=input();
				break;
			case 3:
				ans=add(f,s);
				printf("\n time addition is %d %d %d",ans.hh,ans.mm,ans.ss);
				break;
			case 4:
				ans=sub(f,s);
				printf("\n time subtraction is %d %d %d",ans.hh,ans.mm,ans.ss);
				break;
		}
	}while(ch!=5);
}

time input(void)
{
	time temp;
	do
	{
		printf("\n enter the hours : ");
		scanf("%d",&temp.hh);
	}
	while(temp.hh<0 || temp.hh>12);
	do
	{
		printf("\n enter the minutes : ");
		scanf("%d",&temp.mm);
	}
	while(temp.mm<0 || temp.mm>=60);
	do
	{
		printf("\n enter the seconds : ");
		scanf("%d",&temp.ss);
	}
	while(temp.ss<0 || temp.ss>=60);
	return temp;
}
time add(time x,time y)
{
	time a;
	if(x.ss+y.ss>60)
		++x.mm,a.ss=(x.ss+y.ss)%60;
	else
		a.ss=x.ss+y.ss;
	if(x.mm+y.mm>60)
		++x.hh,a.mm=(x.mm+y.mm)%60;
	else
		a.mm=x.mm+y.mm;
	if(x.hh+y.hh>12)
		a.hh=(x.hh+y.hh)%12;
	else
		a.hh=x.hh+y.hh;
	if(a.hh==0)
		a.hh=12;
	return a;
}

time sub(time x,time y)
{
	time a;
	if(x.ss-y.ss<0)
		--x.mm,a.ss=60+x.ss-y.ss;
	else
		a.ss=x.ss-y.ss;
	if(x.mm-y.mm<0)
		--x.hh,a.mm=60+x.mm-y.mm;
	else
		a.mm=x.mm-y.mm;
	if(x.hh-y.hh<0)
		a.hh=12+x.hh-y.hh;
	else
		a.hh=x.hh-y.hh;
	if(a.hh==0)
		a.hh=12;
	return a;
}
Universal image format convertion

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;

struct UlFormatData
{
public:
    int BytesPP;

    ulong BitMask[4]; // A bit mask in source A8R8G8B8 picture.
    int ShiftR[4]; // Can be < 0 for left shift operation.

public:
    ulong CreateBitMask(int aStartPosition, int aSize)
    {
        ulong result = 0;
        UlFor (int i = 0; i < aSize; i++)
        {
            result = (result >> 1) | 0x80000000;
        }
        result = result >> aStartPosition;
        return result;
    }

    UlFormatData(const char *format_str)
    {
        BytesPP = 0;
        for (int i = 0; i < 4; i++)
        {
            ShiftR[i] = 0;
            BitMask[i] = 0; // Exclude color if not in use.
        }

        // Count destination's bits per pixel.
        int bitsPP = 0;
        UlFor (const char *temp = format_str; *temp; temp++)
        {
            if ('0' <= *temp && *temp <= '9')
                bitsPP += *temp - '0';
        }

        // Main loop: trace format_str and calculate masks and shifts.
        int bitsPassed = 0;
        int currentIndex = 0; // Index for any 'argb' order.

        while (*format_str)
        {
            char color = *(format_str++);
            char numberOfBits = *(format_str++) - '0';

            int sourceColorStart =
            color == 'A' || color == 'X' ? 0 :
            color == 'R' ? 8 :
            color == 'G' ? 16 :
            color == 'B' ? 24 : 32;

            BitMask[currentIndex] = CreateBitMask(sourceColorStart, numberOfBits);
            ShiftR[currentIndex] = bitsPassed - sourceColorStart + (32 - bitsPP);

            bitsPassed += numberOfBits;
            currentIndex++;
        }

        BytesPP = bitsPP / 8;
    }
};

//------------------------------------------------------------------------------
// There is no 24-bit type in C++, so...

struct UlBits24
{
    char b[3];
};

//------------------------------------------------------------------------------
// Template function that will copy a line of image into destination with
//    adequate conversion.

template <class dsttype>
static inline void CopyARGBLine(const ulong *srcline, dsttype *dstline,
    const UlFormatData &aFormatData, int width)
{
    for (int x = 0; x < width; x++)
    {
        ulong temp = *(srcline++);
        ulong result = 0;
        UlFor (int i = 0; i < 4; i++)
        {
            result |= ((temp & aFormatData.BitMask[i]) >>
                aFormatData.ShiftR[i]);
        }
        *(dstline++) = *(dsttype *)(&result);
    }
}

//------------------------------------------------------------------------------
void ConvertFromA8R8G8B8(const ulong *aSource, int width, int height,
    const UlFormatData &aFormatData, uchar *aData, int aPitch)
{
    for (int y = 0; y < height; y++)
    {
        const ulong *line = aSource + (y * width);
        uchar *dstline = aData + (y * aPitch);

        switch (aFormatData.BytesPP)
        {
        case 1:
            CopyARGBLine<uchar>(line, (uchar *)dstline, aFormatData, width);
            break;
        case 2:
            CopyARGBLine<ushort>(line, (ushort *)dstline, aFormatData, width);
            break;
        case 3:
            CopyARGBLine<UlBits24>(line, (UlBits24 *)dstline,
                aFormatData, width);
            break;
        case 4:
            CopyARGBLine<ulong>(line, (ulong *)dstline, aFormatData, width);
            break;
        default:
            throw "Incorrect destination image format";
        }
    }
}
Using algorithm for code assignment to characters of varying probabilities

#include<stdio.h>
#include<conio.h>
#include<math.h>
int temp,i,j,col=0,n=100,count=0,b[10][2];
float a[10],sum=100;
char c[10][10];
void main()
{
void part(int,int);
clrscr();
printf("Enter number of characters ");
while(n>10)
{
printf("(Not more than 10) ");
scanf("%d",&n);
}
while(sum>1)
{
printf("Enter their probabilities of occurences
");
sum=0;
for(i=1;i<=n;i++)
{
printf(".");
scanf("%f",&a[i]);
while(a[i]>=1)
a[i]=a[i]/10;
sum=sum+a[i];
if(sum>1)
break;
}
if(sum>1)
printf("Sum of probabilities must be less than or equal to 1 !
");
}
for(i=0;i<10;i++)
{
for(j=0;j<10;j++)
c[i][j]='*';
}
for(i=0;i<n;i++)
{
for(j=0;j<n;j++)
{
if(a[j]<a[j+1])
{
temp=a[j];
a[j]=a[j+1];
a[j+1]=temp;
}}}
printf("

");
part(1,n);
printf("The codes are 
");
for(i=0;i<n;i++)
{
for(j=0;j<10;j++)
printf("%c ",c[i][j]);
printf("
");
}
getch();
}
void part(int low,int high)
{
int min=100,k,z,sum=0,dif,sum1=0,l=0;
z=(high-low);
z=abs(z);
for(j=0;j<10;j++)
for(i=0;i<2;i++)
b[j][i]=0;
if(z>1)
{
count++;
for(i=low-1;i<high;i++)
sum=sum+a[i];
sum1=a[low-1];
sum=sum-a[low-1];
for(i=low;i<=high;i++)
{
dif=sum-sum1;
sum1=a[i]+sum1;
sum=sum-a[i];
b[l][0]=abs(dif);
b[l][1]=i;
l++;
}
for(i=0;i<l;i++)
if(min>b[i][0])
{
min=b[i][0];
k=b[i][1];
}
for(i=low-1;i<k;i++)
c[i][col]='0';
for(i=k;i<high;i++)
c[i][col]='1';
col++;
part(low,k);
part(k+1,high);
}
else
{
c[low][col]='1';
c[high][col]='0';
if(c[high+1][col]=='*'&&high<=9)
while(c[high+1][col]=='*')
col--;
col++;
}
}
Word Frequency

#include <stdio.h>

#define SIZE 80
#define LEN  80


int strword(char[],char[][]);
int strword_p(char*,char**);


void main(){
	char* s;
	char** w;
	char ch;

	do{
	   clrscr();
	   gotoxy(10,1);
	   printf("Enter a string :");
	   gets(s);
	   gotoxy(10,2);
	   printf("\nNumber of words :%d",strword_p(s,w));
	   gotoxy(10,24);
	   printf(" Continue(y/n)?");
	   ch=getch();

	} while (ch=='y' || ch=='Y');
}

int strword_p(char *s,char **w){
    int is_space=0,
	i=0,
	word_counter=0,
	j=0,
	is_printed=0,
	frequency=0;

	while (*(s+i)!='\0'){
		if (*(s+i)==' ' ||
		    *(s+i)==',' ||
		    *(s+i)=='.' ||
		    *(s+i)==':'){

		     if (is_space==0){
			 *(*(w+word_counter)+j)='\0';
			 word_counter++;
			 is_space=1;
			 j=0;
		     }
		}
		else{
		   *(*(w+word_counter)+j)=*(s+i);
		   j++;
		   is_space=0;
		}
		i++;
	}
     if (is_space==0){
	 *(*(w+word_counter)+j)='\0';
	word_counter++;
     }

     for(j=0;j<word_counter;j++){
	frequency=0;
	is_printed=0;
	for(i=0;i<word_counter;i++){
	    if (strcmp(w[i],w[j])==0){
		 frequency++;
		 if (j<i)
			is_printed=1;
	    }
	}
	if (!is_printed)
		printf("\n Word %d : %s ,frequency->%d",j+1,w[j],frequency);
     }
     printf("\n");


     return word_counter;


}
An implementation of Stack data structure

#include <iostream>
#include <new>
#include <string>
#include <sstream>
using namespace std;

#if !defined __STACK_H
#define __STACK_H

namespace stk{
	class Stack{
		private:
			int *p;
			int top,length;

			string str()const;
		public:
			Stack();
			Stack(const int);
			Stack(const Stack&);
			~Stack();

			void push(int);
			int pop();
			int get_length()const;
			bool is_empty()const;
			Stack operator=(const Stack&);
			friend ostream& operator<<(ostream&,Stack&);

			class StackException{
				private:
					string desc;
				public:
					StackException(string exp){ desc="Exception : "+exp; }
					string get_exp(){ return desc; }
			};
	};

	Stack::Stack(){
		top=-1;
		length=0;
		p=0;
	}

	Stack::Stack(const int size){
		top=-1;
		length=size;
		try{
			p=new int[length];
		}catch(bad_alloc ba){
			cout<<"Memory can not be alllocated
";
			return;
		}
	}

	Stack::Stack(const Stack &o){
		top=o.top;
		length=o.length;
		try{
			p=new int[length];
		}catch(bad_alloc ba){
			cout<<"Memory allocation failed
";
			return;
		}
		for(int i=0;i<length;i++)
			p[i]=o.p[i];
	}

	Stack::~Stack(){
		if(p!=0)
			delete [] p;
	}

	void Stack::push(int elem){
		if(p==0){
			try{
				p=new int[1];
			}catch(bad_alloc ba){
				throw StackException("Memory fault
");
			}
			length++;
			top++;
			p[top]=elem;
		}
		else if(top==(length-1)){
			int *q;
			try{
				q=new int[length+1];
			}catch(bad_alloc ba1){
				throw StackException("Memory fault
");
			}
			for(int i=0;i<length;i++)
				q[i]=p[i];
			length++;
			top++;
			q[top]=elem;
			delete [] p;
			p=q;
		}
		else{
			top++;
			p[top]=elem;
		}
	}

	int Stack::pop(){
		if(p==0 || top==-1){
			throw StackException("Stack empty!
");
		}
		int ret=p[top];
		top--;
		length--;

		if(top==-1){
			delete [] p;
			p=0;
		}
		else{
			int *q;
			try{
				q=new int[length];
			}catch(bad_alloc ba){
				throw StackException("Memory fault
");
			}
			for(int i=0;i<length;i++)
				q[i]=p[i];
			delete [] p;
			p=q;
		}

		return ret;
	}

	int Stack::get_length()const{
		return length;
	}

	bool Stack::is_empty()const{
		return ((p==0)? true : false);
	}

	string Stack::str()const{  // private member function
		stringstream ss;
		for(int i=0;i<length;i++){
			ss << p[i];
			if(i!=(length-1))
				ss << ", ";
		}
		//ss<<"
";
		return ss.str();
	}

	Stack Stack::operator=(const Stack &stk){
		length=stk.length;
		top=stk.top;

		if(p!=0)
			delete [] p;
		try{
			p=new int[length];
		}catch(bad_alloc ba){
			throw StackException("Memory fault in copying!
");
		}
		for(int i=0;i<length;i++)
			p[i]=stk.p[i];

		return *this;
	}

	ostream& operator<<(ostream &o,Stack &s){
		o<<s.str();
		return o;
	}

} // namespace stk;

#endif


This program connects to an ODBC data source called "db97".
It then executes a SQL statement SELECT Model

Code :


#include <windows.h>

#include <sqlext.h>

#include <stdio.h>



int main(void)

{

                HENV                      hEnv = NULL;
// Env Handle from SQLAllocEnv()

                HDBC                      hDBC = NULL;
// Connection handle

                HSTMT                   hStmt = NULL;
// Statement handle

                UCHAR                   szDSN[SQL_MAX_DSN_LENGTH] =
"db97";                // Data Source Name buffer
UCHAR*                  szUID = NULL;
// User ID buffer

                UCHAR*                  szPasswd = NULL;
// Password buffer

                UCHAR                   szModel[128];
// Model buffer

                SDWORD             cbModel;
// Model buffer bytes recieved

                UCHAR                   szSqlStr[] = "Select Model From
Makes Where Make='Vauxhall'";                // SQL string

                RETCODE              retcode;
// Return code



                // Allocate memory for ODBC Environment handle

                SQLAllocEnv (&hEnv);



                // Allocate memory for the connection handle

                SQLAllocConnect (hEnv, &hDBC);



                // Connect to the data source "db97" using userid and
password.

                retcode = SQLConnect (hDBC, szDSN, SQL_NTS, szUID,
SQL_NTS, szPasswd, SQL_NTS);



                if (retcode == SQL_SUCCESS || retcode ==
SQL_SUCCESS_WITH_INFO)

                {

                                // Allocate memory for the statement
handle

                                retcode = SQLAllocStmt (hDBC, &hStmt);



                                // Prepare the SQL statement by 
assigning
it to the statement handle

                                retcode = SQLPrepare (hStmt, szSqlStr,
sizeof (szSqlStr));



                                // Execute the SQL statement handle

                                retcode = SQLExecute (hStmt);



                                // Project only column 1 which is the
models

                                SQLBindCol (hStmt, 1, SQL_C_CHAR, 
szModel,
sizeof(szModel), &cbModel);



                                // Get row of data from the result set
defined above in the statement

                                retcode = SQLFetch (hStmt);



                                while (retcode == SQL_SUCCESS || 
retcode
== SQL_SUCCESS_WITH_INFO)

                                {

                                                printf ("	%s
",
szModel);                                                // Print row
(model)

                                                retcode = SQLFetch
(hStmt);                                 // Fetch next row from result 
set

                                }



                                // Free the allocated statement handle

                                SQLFreeStmt (hStmt, SQL_DROP);



                                // Disconnect from datasource

                                SQLDisconnect (hDBC);

                }



                // Free the allocated connection handle

                SQLFreeConnect (hDBC);



                // Free the allocated ODBC environment handle

                SQLFreeEnv (hEnv);

                return 0;

}
Cpu scheduling program in c++

The program will help "HOW TO INTERACT Cpu scheduling program in c++"

Code :
#include<iostream.h>
#include<conio.h>
#include<stdio.h>

class cpuschedule
{
	int n,Bu[20];
	float Twt,Awt,A[10],Wt[10],w;
public:
	//Getting the No of processes & burst time
	void Getdata();
	//First come First served Algorithm
	void Fcfs();
	//Shortest job First Algorithm
	void Sjf();
	//Shortest job First Algorithm with Preemption
	void SjfP();
	//Shortest job First Algorithm with NonPreemption
	void SjfNp();
	//Round Robin Algorithm
	void RoundRobin();
	//Priority Algorithm
	void Priority();
};
// Implementation file for Cpu scheduling

#include "cpuh.h"
//Getting no of processes and Burst time
void cpuschedule::Getdata()
{
	int i;
	cout<<"
Enter the no of processes:";
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cout<<"
Enter The BurstTime for Process p"<<i<<"=	";
		cin>>Bu[i];
	}
}

//First come First served Algorithm
void cpuschedule::Fcfs()
{
	int i,B[10];
	Twt=0.0;
	for(i=1;i<=n;i++)
	{
		B[i]=Bu[i];
		cout<<"
Burst time for process p"<<i<<"=	";
		cout<<B[i];
	}
	Wt[1]=0;
	for(i=2;i<=n;i++)
	{
		Wt[i]=B[i-1]+Wt[i-1];
	}

	//Calculating Average Weighting Time
	for(i=1;i<=n;i++)
		Twt=Twt+Wt[i];
	Awt=Twt/n;
	cout<<"
Total   Weighting Time="<<Twt;
	cout<<"
Average Weighting Time="<<Awt<<"
";
}

//Shortest job First Algorithm
void cpuschedule::Sjf()
{
	int i,j,temp,B[10];
	Twt=0.0;
	for(i=1;i<=n;i++)
	{
		B[i]=Bu[i];
		cout<<"
Burst time for process p"<<i<<"=	";
		cout<<B[i];
	}
	for(i=n;i>=1;i--)
	{
		for(j=1;j<=n;j++)
		{
			if(B[j-1]>B[j])
			{
				temp=B[j-1];
				B[j-1]=B[j];
				B[j]=temp;
			}
		}
	}

	Wt[1]=0;
	for(i=2;i<=n;i++)
	{
		Wt[i]=B[i-1]+Wt[i-1];
	}
	//calculating Average Weighting Time
	for(i=1;i<=n;i++)
		Twt=Twt+Wt[i];
	Awt=Twt/n;
	cout<<"
Total   Weighting Time="<<Twt;
	cout<<"
Average Weighting Time="<<Awt<<"
";
}

//Shortest job First Algorithm with NonPreemption

void cpuschedule::SjfNp()
{
	int i,B[10],Tt=0,temp,j;
	char S[10];
	float A[10],temp1,t;
	Twt=0.0;
	w=0.0;
	for(i=1;i<=n;i++)
	{
		B[i]=Bu[i];
		cout<<"
Burst time for process p"<<i<<"=	";
		cout<<B[i];
		S[i]='T';
		Tt=Tt+B[i];
		cout<<"
Enter the Arrival Time for"<<i<<"th process=	";
		cin>>A[i];
	}

	for(i=n;i>=1;i--)
	{
		for(j=3;j<=n;j++)
		{
			if(B[j-1]>B[j])
			{
				temp=B[j-1];
				temp1=A[j-1];
				B[j-1]=B[j];
				A[j-1]=A[j];
				B[j]=temp;
				A[j]=temp1;
			}
		}
	}

	for(i=1;i<=n;i++)
	{
		cout<<"
p"<<i<<"	"<<B[i]<<"	"<<A[i];
	}

	//For the 1st process
		Wt[1]=0;
		w=w+B[1];
		t=w;
		S[1]='F';

		while(w<Tt)
		{
			i=2;
			while(i<=n)
			{
				if(S[i]=='T'&&A[i]<=t)
				{
					Wt[i]=w;
					cout<<"
WT"<<i<<"="<<Wt[i];
					S[i]='F';
					w=w+B[i];
					t=w;
					i=2;
				}
				else
					i++;
			}
		}

		for(i=1;i<=n;i++)
			cout<<"
Wt"<<i<<"=="<<Wt[i];


		//calculating average weighting Time
		for(i=1;i<=n;i++)
			Twt=Twt+(Wt[i]-A[i]);
		Awt=Twt/n;
	cout<<"Total   Weighting Time="<<Twt<<"
";
	cout<<"Average Weighting Time="<<Awt<<"
";
}

//Priority Algorithm

void cpuschedule::Priority()
{
	int i,B[10],P[10],j;
	w=0.0;
	int max;
	Twt=0.0;
	max=1;
	for(i=1;i<=n;i++)
	{
		B[i]=Bu[i];
		cout<<"
Burst time for process p"<<i<<"=	";
		cout<<B[i];
		cout<<"
Enter the priority for process P"<<i<<"=	";
		cin>>P[i];
		if(max<P[i])
			max=P[i];
	}
	j=1;
	while(j<=max)
	{
		i=1;
		while(i<=n)
		{
			if(P[i]==j)
			{
				Wt[i]=w;
				w=w+B[i];
			}
			i++;
		}
		j++;
	}

	//calculating average weighting Time
	for(i=1;i<=n;i++)
		Twt=Twt+Wt[i];
	Awt=Twt/n;
	cout<<"Total   Weighting Time="<<Twt<<"
";
	cout<<"Average Weighting Time="<<Awt<<"
";
}

//Shortest job First Algorithm with Preemption
void cpuschedule::SjfP()
{
	int i,j,m,Wt[10],k,B[10],A[10],Tt=0,Wtm[10],temp;
	char S[20],start[20];
	int max=0,Time=0,min;
	float Twt=0.0,Awt;
	for(i=1;i<=n;i++)
	{
		B[i]=Bu[i];
		cout<<"
Burst time for process P"<<i<<"=	"<<B[i];
		if(B[i]>max)
			max=B[i];
		Wt[i]=0;
		S[i]='T';
		start[i]='F';
		Tt=Tt+B[i];
		cout<<"
Enter the Arrival Time for"<<i<<"th process=	";
		cin>>A[i];
		if(A[i]>Time)
			Time=A[i];
	}
	//cout<<"
Max="<<max;
	int w=0,flag=0,t=0;
	i=1;
	while(t<Time)
	{
		if(A[i]<=t && B[i]!=0)
		{
			if(flag==0)
			{
				Wt[i]=Wt[i]+w;

				cout<<"
Wt["<<i<<"]="<<Wt[i];
			}
			B[i]=B[i]-1;
			if(B[i]==0)
				S[i]='F';
			start[i]='T';
			t++;
			w=w+1;
			if(S[i]!='F')
			{
				j=1;flag=1;
				while(j<=n && flag!=0)
				{
					if(S[j]!='F' && B[i]>B[j] && A[j]<=t && i!=j )
					{
						flag=0;
						Wt[i]=Wt[i]-w;
						i=j;
					}
					else
					{
						flag=1;
					}
					j++;
				}
			}
			else
			{
				i++;
				j=1;
				while(A[j]<=t &&j<=n)
				{
					if(B[i]>B[j] && S[j]!='F')
					{
						flag=0;
						i=j;
					}
					j++;
				}
			}
		}
		else
			if(flag==0)
			i++;
	}


	cout<<"
Printing remaining burst time
";
	for(i=1;i<=n;i++)
		cout<<"
B["<<i<<"]="<<B[i];
	cout<<"
";

	while(w<Tt)
	{
		min=max+1;
		i=1;
		while(i<=n)
		{
			if(min>B[i] && S[i]=='T')
			{
				min=B[i];
				j=i;
			}
			i++;
		}
		i=j;
		if(w==Time && start[i]=='T')
		{
			w=w+B[i];
			S[i]='F';
		}
		else
		{
			Wt[i]=Wt[i]+w;
			w=w+B[i];
			S[i]='F';
		}
	}

cout<<"Weight info
";

	for(i=1;i<=n;i++)
		cout<<"
WT["<<i<<"]="<<Wt[i];
cout<<"after subtracting arrival time
";
	for(i=1;i<=n;i++)
	{
		Wt[i]=Wt[i]-A[i];
		cout<<"
WT["<<i<<"]="<<Wt[i];
	}
	//Calculating Average Weighting time
	for(i=1;i<=n;i++)
		Twt=Twt+Wt[i];
	Awt=Twt/n;
	cout<<"
Average Weighting Time="<<Awt;



}

//Round Robin Algorithm
void cpuschedule::RoundRobin()
{

	int i,j,tq,k,B[10],Rrobin[10][10],count[10];
	int max=0;
	int m;
	Twt=0.0;
	for(i=1;i<=n;i++)
	{
		B[i]=Bu[i];
		cout<<"
Burst time for process p"<<i<<"=	";
		cout<<B[i];
		if(max<B[i])
			max=B[i];
		Wt[i]=0;
	}
	cout<<"
Enter the Time Quantum=";
	cin>>tq;
	//TO find the dimension of the Rrobin array
	m=max/tq+1;

	//initializing Rrobin array
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			Rrobin[i][j]=0;
		}
	}
	//placing value in the Rrobin array
	i=1;
	while(i<=n)
	{
		j=1;
		while(B[i]>0)
		{
			if(B[i]>=tq)
			{
				B[i]=B[i]-tq;
				Rrobin[i][j]=tq;
				j++;
			}
			else
			{
				Rrobin[i][j]=B[i];
				B[i]=0;
				j++;
			}
		}
		count[i]=j-1;
		i++;
	}

	cout<<"Display
";
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			cout<<"Rr["<<i<<","<<j<<"]="<<Rrobin[i][j];
			cout<<"	";
		}
		cout<<"
";
	}
	//calculating weighting time
	int x=1;
	i=1;
	while(x<=n)
	{
		for(int a=1;a<x;a++)
		{
			Wt[x]=Wt[x]+Rrobin[a][i];
		}
		i=1;
		int z=x;
		j=count[z];
		k=1;
		while(k<=j-1)
		{
			if(i==n+1)
			{
				i=1;
				k++;
			}
			else
			{
				if(i!=z)
				{
					Wt[z]=Wt[z]+Rrobin[i][k];
				}
				i++;
			}
		}
		x++;
	}
	for(i=1;i<=n;i++)
		cout<<"
Weighting Time for process P"<<i<<"="<<Wt[i];

	//calculating Average Weighting Time
	for(i=1;i<=n;i++)
		Twt=Twt+Wt[i];
	Awt=Twt/n;
	cout<<"
Total   Weighting Time="<<Twt;
	cout<<"
Average Weighting Time="<<Awt<<"
";
}

//Application file for cpu Scheduling
#include "cpuh.h"

void main()
{
	int ch,cho;
	cpuschedule c;
	do
	{
		cout<<"				 MENU
";
		cout<<"1.Getting BurstTime
";
		cout<<"2.FirstComeFirstServed
";
		cout<<"3.ShortestJobFirst
";
		cout<<"4.RoundRobin
";
		cout<<"5.Priority
";
		cout<<"6.EXIT
";
		cout<<"Enter your choice
";
		cin>>ch;
		switch(ch)
		{
		case 1:
			c.Getdata();
			break;
		case 2:
			cout<<"FIRST COME FIRST SERVED SCHEDULING
";
			c.Fcfs();
			break;
		case 3:
			cout<<"SHORTEST JOB FIRST SCHEDULING
";
			do
			{
				cout<<"1.SJF-Normel
";
				cout<<"2.SJF-Preemptive
";
				cout<<"3.SJF-NonPreemptive
";
				cout<<"Enter your choice
";
				cin>>cho;
				switch(cho)
				{
				case 1:
					c.Sjf();
					break;
				case 2:
					c.SjfP();
					break;
				case 3:
					c.SjfNp();
					break;
				}
			}while(cho<=3);
			break;
		case 4:
			cout<<"ROUND ROBIN SCHEDULING
";
			c.RoundRobin();
			break;
		case 5:
			cout<<"PRIORITY SCHEDULING
";
			c.Priority();
			break;
		case 6:
			break;
		}
	}while(ch<=5);
}
Copy all the files and directory

Code :

#include <windows.h>

/*
BOOL Copy(char r_szPath[1024], char r_szDir[1024])
{
	char l_szTemp[2048] = {0};
	sprintf(l_szTemp,"%s\%s"r_szPath,r_szDir);

	if(IsDirectory(
}*/

#include <stdio.h>
#include<conio.h>

BOOL __Copy(char r_szSrcPath[1024],char r_szDesPath[1024])
{
  WIN32_FIND_DATA FindFileData;
  HANDLE hFind;
  char l_szTmp[1025] = {0};
  memcpy(l_szTmp,r_szSrcPath,1024);


  char l_szSrcPath[1025] = {0};
  char l_szDesPath[1025] = {0};
  memcpy(l_szSrcPath,r_szSrcPath,1024);
  memcpy(l_szDesPath,r_szDesPath,1024);

  char l_szNewSrcPath[1025] = {0};
  char l_szNewDesPath[1025] = {0};

  strcat(l_szTmp,"*");

  hFind = FindFirstFile(l_szTmp, &FindFileData);
  if(hFind == NULL) return FALSE;

  do
  {

	  if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	  {
		  if(strcmp(FindFileData.cFileName,"."))
		  {
			  if(strcmp(FindFileData.cFileName,".."))
			  {
					printf ("The Directory found is %s
", FindFileData.cFileName);
					
sprintf(l_szNewDesPath,"%s%s\",l_szDesPath,FindFileData.cFileName);
					
sprintf(l_szNewSrcPath,"%s%s\",l_szSrcPath,FindFileData.cFileName);
					CreateDirectory(l_szNewDesPath,NULL);
					__Copy(l_szNewSrcPath,l_szNewDesPath);
			  }
		  }
	  }
	  else
	  {
		  printf ("The File found is %s
", FindFileData.cFileName);
		  char l_szSrcFile[1025] = {0};
		  char l_szDesFile[1025] = {0};
		  sprintf(l_szDesFile,"%s%s",l_szDesPath,FindFileData.cFileName);
		  sprintf(l_szSrcFile,"%s%s",l_szSrcPath,FindFileData.cFileName);
		  BOOL l_bRet = CopyFile(l_szSrcFile,l_szDesFile,TRUE);

	  }


  }
  while(FindNextFile(hFind, &FindFileData));
  FindClose(hFind);
  return TRUE;
}


int main(int argc, char *argv[])
{
	__Copy("C:\fcdb\","E:\sowmya\");
	getch();
	return 0;
}


A C++ Program to Multiply two Matrices. Divide And Conquer Algorithm

Code :
 
 
 # include <iostream.h>
 # include   <stdlib.h>
 # include    <conio.h>

 

 class Matrix
 {
    private:
       float matrix_a[3][3];
       float matrix_b[3][3];
       float matrix_c[3][3];

    public:
       Matrix( );

       void get_matrix_a( );
       void get_matrix_b( );
       void multiply_matrices( );
       void show_result_Matrix( );
 };

 


 Matrix::Matrix( )
 {
    for(int i=0;i<3;i++)
    {
       for(int j=0;j<3;j++)
       {
	  matrix_a[i][j]=0;
	  matrix_b[i][j]=0;
	  matrix_c[i][j]=0;
       }
    }

    gotoxy(1,1);
    cout<<"
**************************************************************************
****"<<endl;
    cout<<" * * * * * * * * * * * * * *  Matrix  Multiplication  * * * 
* *
* * * * * * * *"<<endl;
    cout<<"
**************************************************************************
****"<<endl;

    gotoxy(1,25);
    cout<<"
**************************************************************************
****";
 }



 void Matrix::get_matrix_a( )
 {
    gotoxy(1,6);
    cout<<" Enter the values of the Matrix A row by row :
 "<<endl;

    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;

    gotoxy(18,10);
    cout<<" A  = "<<endl;

    int x=28;
    int y=9;

    for(int i=0;i<3;i++)
    {
       for(int j=0;j<3;j++)
       {
	  gotoxy(x,y);
	  cin>>matrix_a[i][j];

	  x+=5;
       }

       x=28;
       y++;
    }
 }

 


 void Matrix::get_matrix_b( )
 {
    gotoxy(1,15);
    cout<<" Enter the values of the Matrix B row by row :
 "<<endl;

    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;

    gotoxy(18,19);
    cout<<" B  = "<<endl;

    int x=28;
    int y=18;

    for(int i=0;i<3;i++)
    {
       for(int j=0;j<3;j++)
       {
	  gotoxy(x,y);
	  cin>>matrix_b[i][j];

	  x+=5;
       }

       x=28;
       y++;
    }
 }

 


 void Matrix::multiply_matrices( )
 {
    for(int i=0;i<3;i++)
    {
       for(int j=0;j<3;j++)
       {
	  float value=0;
	  float sum=0;

	  for(int k=0;k<3;k++)
	  {
	     value=matrix_a[j][k]*matrix_b[k][j];
	     sum+=value;
	  }

	  matrix_c[i][j]=sum;
       }
    }
 }

 

 void Matrix::show_result_Matrix( )
 {
    clrscr( );

    gotoxy(1,1);
    cout<<"
**************************************************************************
****"<<endl;
    cout<<" * * * * * * * * * * * * * *  Matrix  Multiplication  * * * 
* *
* * * * * * * *"<<endl;
    cout<<"
**************************************************************************
****"<<endl;

    gotoxy(1,6);
    cout<<" The values of Matrix A and B are :"<<endl;

    cout<<"		 ?               ?  	            ?               
?"<<endl;
    cout<<"		 ?               ?   	            ?               
?"<<endl;
    cout<<"		 ?               ?   	            ?               
?"<<endl;
    cout<<"		 ?               ?  	            ?               
?"<<endl;
    cout<<"		 ?               ? 		    ?               ?"<<endl;

    gotoxy(45,9);
    cout<<" B  = "<<endl;

    gotoxy(10,9);
    cout<<" A  = "<<endl;

    gotoxy(1,15);
    cout<<" The Product of Matrix A and B is :
 "<<endl;

    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;
    cout<<"			 ?               ?"<<endl;

    gotoxy(13,19);
    cout<<" A * B  = "<<endl;

    int x_1=20;
    int y_1=8;

    int x_2=55;
    int y_2=8;

    int x_3=28;
    int y_3=18;

    for(int i=0;i<3;i++)
    {
       for(int j=0;j<3;j++)
       {
	  gotoxy(x_1,y_1);
	  cout<<matrix_a[i][j];

	  gotoxy(x_2,y_2);
	  cout<<matrix_b[i][j];

	  gotoxy(x_3,y_3);
	  cout<<matrix_c[i][j];

	  x_1+=5;
	  x_2+=5;
	  x_3+=5;
       }

       x_1=20;
       y_1++;

       x_2=55;
       y_2++;

       x_3=28;
       y_3++;
    }

    gotoxy(1,25);
    cout<<"
**************************************************************************
****";
 }

 


 int main( )
 {
    textmode(BW80);
    clrscr( );

    Matrix Obj;

    Obj.get_matrix_a( );
    Obj.get_matrix_b( );
    Obj.multiply_matrices( );
    Obj.show_result_Matrix( );

    getch( );
    return 0;
 }



A C++ Program to computes the n_th term of the fibonacci series using
Divide and Conquer Strategy.

Code :


 # include <iostream.h>
 # include    <conio.h>


 //------------------------  Function
rototypes  ------------------------//



 const long fibonacci(const int);


 //----------------------------- 
main( )  -------------------------------//



 int main()
 {
    clrscr( );

    int number;

    cout<<"
 Enter the number ( 1 - 25 ) = ";
    cin>>number;

    number=((number>25)?25:number);

    cout<<"

 The "<<number<<"_th term of fibonacci series =
"<<fibonacci(number);

    getch( );
    return 0;
 }



 //------------------------  Function
efinitions  -----------------------//



 //---------------------------- 
fibonacci( )  ---------------------------//


/

 const long fibonacci(const int n)
 {
    if(n<=1)
       return n;

    else
       return (fibonacci(n-1)+fibonacci(n-2));
 }


Reads information from an inserted floppy disk.
like clusters, sectors etc.

//Reads floppy disk properties(Ensure floppy is avaiable in drive)


#include<iostream.h>
#include<conio.h>
#include<dos.h>
void main(){
     clrscr();
     //Floppy Drive Properties
     struct fatinfo diskinfo;
     getfat(1, &diskinfo);
     cout<<"Floppy Disk Properties..
--------------------------";
     cout<<"
Sectors per cluster:"<<diskinfo.fi_sclus;
     cout<<"
Number of clusters:"<<diskinfo.fi_nclus;
     cout<<"
Bytes per sector:"<<diskinfo.fi_bysec;
     struct dfree free;
     long avail;
     getdfree(1,&free);
     avail =(long)free.df_avail*(long)free.df_bsec*(long)free.df_sclus;
     cout<<"
Total bytes available:"<<avail<<" Bytes";
     cout<<"
Bytes free:"<<(long)free.df_avail<<" Bytes";
     getfatd(&diskinfo);
     //Hard disk drive properties
     cout<<"

Default Drive 
Properties..
--------------------------";
     cout<<"
Sectors per cluster:"<<diskinfo.fi_sclus;
     cout<<"
FAT ID byte:"<<(diskinfo.fi_fatid & 0xFF);
     cout<<"
Number of clusters:"<<diskinfo.fi_nclus;
     cout<<"
Bytes per sector:"<<diskinfo.fi_bysec;
     getch();
}
Find shortest path using floyd warshall algorithm

Code :
#include<iostream.h>
#include<conio.h>
#include<stdio.h>
#include<stdlib.h>
class path
{
	int n;
		int p[10][10];
		int a[10][10];
		int c[10][10];
	public:
		void get();
		void pm();
		void ap();
		void disp();
};
void path::get()
{
	int i,j,k;
	clrscr();
	cout<<"Enter the no. of nodes in the graph :";
	cin>>n;
	cout<<"
Enter the adjacency matrix :
";
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
		    //	cout<<"a["<<i<<","<<j<<"] = ";
			cin>>a[i][j];
			p[i][j]=0;
		}
	}
	cout<<"

Enter The cost matrix is :

";
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
		   //	cout<<"a["<<i<<","<<j<<"] = ";
			cin>>c[i][j];
		}
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{

				p[i][j]=a[i][j];

		}
	}
}
void path::disp()
{
//	cout<<"

 The output matrix for the given graph is :
";
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cout<<p[i][j]<< "	";
		}
		cout<<endl;
}
}

void path::pm()
{
	int i,j,k;

	for(k=1;k<=n;k++)
	{
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				p[i][j]=p[i][j] || p[i][k] && p[k][j];
			}
		}
	}

}
void path::ap()
{
	int i,j,k;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{

				p[i][j]=c[i][j];

		}
	}
	for(k=1;k<=n;k++)
	{
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				if(p[i][j]<p[i][k]+p[k][j])
				{
					p[i][j]=p[i][j];
				}
				else
				{
				p[i][j]=p[i][k]+p[k][j];
				}
			}
		}
	}
}
void main()
{
path p;
p.get();
p.pm();
cout<<"path matrix is :
";
p.disp();
getch();
p.ap();
cout<<"all pair shortest  path matrix is :
";
p.disp();
getch();
}
This is a very simple quiz with Ten questions in it and also is very easy to use.
This is mainly made for extreme begginers in C++.

#include<iostream.h>
#include<conio.h>

void main()
{
	clrscr();
	int x,y,z;
	x=y=z=0;
	char ch1[100],ch2,ch3,ch4,ch5,ch6,ch7,ch8,ch9,ch10,ch11;
	cout<<"		Guest Enter Your Name
";
	cin>>ch1;
	clrscr();
	cout<<"		Welcome "<<ch1<<".

 Sobriquet is an unofficial title or
name given to someone or something.";
	cout<<"
 Enter answer in form of 'a','b' and'c'only.";
	cout<<"

		What is called as ' THE HOLY
LAND'?
a.Jerusalem
b.Mathura
c.Mecca
";
	cin>>ch2;
	if(ch2=='a')
	{
		x=x+10;
		cout<<"Good Job.
Your score is "<<x;


	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	cout<<"

		What is called as ' THE ROOF OF THE
WORLD'?
a.Nepal
b.Rome
c.Tibet
";
	cin>>ch2;
	if(ch2=='c')
	{
		x=x+10;
		cout<<"Good Job.
Your score is "<<x;

	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();

	cout<<"

		What is called as ' THE LAND OF RISING
SUN'?
a.Chicago
b.Japan
c.Tibet
";
	cin>>ch2;
	if(ch2=='b')
	{
		x=x+10;
		cout<<"Good Job.
Your score is "<<x;


	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	cout<<"

		What is called as ' THE GIFT OF
NILE'?
a.Chicago
b.Egypt
c.Africa
";
	cin>>ch2;
	if(ch2=='b')
	{
		x=x+10;
		cout<<"
Your score is "<<x;


	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	cout<<"

		What is called as ' THE LAND OF MIDNIGHT
SUN'?
a.Norway
b.Japan
c.Australia
";
	cin>>ch2;
	if(ch2=='a')
	{
		x=x+10;
		cout<<"
Your score is "<<x;


	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	cout<<"

		What is called as ' THE LAND OF
THUNDERBOLT'?
a.Bhutan
b.Canada
c.Arab
";
	cin>>ch2;
	if(ch2=='a')
	{
		x=x+10;
		cout<<"
Your score is "<<x;


	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	cout<<"

		What is called as ' THE WINDY
CITY?
a.Jerusalem
b.Japan
c.Chicago
";
	cin>>ch2;
	if(ch2=='c')
	{
		x=x+10;
		cout<<"
Your score is "<<x;


	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	cout<<"

		What is called as ' THE LAND OF WHITE
ELEPHANTS'?
a.Bangladesh
b.Thailand
c.India
";
	cin>>ch2;
	if(ch2=='b')
	{
		x=x+10;
		cout<<"
Your score is "<<x;


	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	cout<<"

		What is called as ' THE CITY OF SEVEN
HILLS'?
a.Rome
b.Nilgiri Hills
c.Tibet
";
	cin>>ch2;
	if(ch2=='a')
	{
		x=x+10;
		cout<<"
Your score is "<<x;


	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	cout<<"

		What is called as ' THE DARK
CONTIENENT'?
a.Asia
b.Australia
c.Africa
";
	cin>>ch2;
	if(ch2=='c')
	{
		x=x+10;
		cout<<"
Your score is "<<x;

	}
	else
	cout<<"Sorry wrong answer.";
	getch();
	clrscr();
	if(x==100)
	cout<<"No cheating...... You have done this earlier also.";
	if(x==90)
	cout<<"You are extremely intelligent
 Your Score is 90";
	if(x==80)
	cout<<"You are intelligent
 Your Score is 80";
	if(50==x||x==70||x==60)
	cout<<"You are average
 Your Score is "<<x<<"
Better luck next 
time";
	else if(x<=40)
	cout<<"No use........ Not even 5 questions right";
	getch();
}
Program To Implement Tower Of Hanoi Alogithm Using Recursion.
This program shows the movements of disk from one tower to another when a key is pressed.

Code :


#include<iostream.h>
#include<stdio.h>
#include<conio.h>

class tower
{
	int *t1,*t2,*t3;
	int x,y,z;
	public:
	void disp_tower();
	void move_disk(int tx,int ty);
	void toh(int n,int a,int b,int c);
	tower(int no);
	~tower();
};

tower :: tower(int no)
{
	t1 = new int[no+1];
	t2 = new int[no+1];
	t3 = new int[no+1];
	x  = no;
	y  = z = 0;

	for(int i=0,j=no ; i<no ; i++,j--)
	{
		t1[i] = j;
		t2[i] = t2[i] = 0;
	}
	t1[no] = t2[no] = t3[no] = 0;
}

tower :: ~tower()
{
	delete []t1;
	delete []t2;
	delete []t3;
}
void tower :: disp_tower()
{
	clrscr();
	cout<<"

 X :: ";
	for(int i=0;i<x;i++)
	{
		cout<<" "<<t1[i];
	}
	cout<<"

 Y :: ";
	for(i=0;i<y;i++)
	{
		cout<<" "<<t2[i];
	}
	cout<<"

 Z :: ";
	for(i=0;i<z;i++)
	{
		cout<<" "<<t3[i];
	}
	getch();
}

void tower :: toh(int n,int tx,int ty,int tz)       //x to y using z
{

	if(n>=1)
	{
		toh(n-1,tx,tz,ty);
		move_disk(tx,ty);         	//x to y
		disp_tower();
		toh(n-1,tz,ty,tx);
	}
}

void tower :: move_disk(int tx,int ty)
{
	switch(tx)
	{
		case 1:
			{
				if(ty==2)
					t2[y++] = t1[--x];
				else
					t3[z++] = t1[--x];
			}break;
		case 2:
			{
				if(ty==1)
					t1[x++] = t2[--y];
				else
					t3[z++] = t2[--y];
			}break;
		case 3:
			{
				if(ty==1)
					t1[x++] = t3[--z];
				else
					t2[y++] = t3[--z];
			}break;
	}//end of switch
}
//------------------------------------------------------------------------
---
int main(void)
{
	clrscr();
	cout<<"Enter the no. of disks::";
	int no;
	cin>>no;
	tower obj(no);
	obj.disp_tower();
	obj.toh(no,1,2,3);
	getch();
	return 0;
}
//------------------------------------------------------------------------
---


Mouse Management functions


#include<iostream.h>
#include<conio.h>
#include<dos.h>
#include<process.h>
void main(){
     clrscr();_setcursortype(_NOCURSOR);
     REGS regs;
     //Initializing and showing mouse
     regs.x.ax=0;int86(0x33,s,s);
     regs.x.ax=1;int86(0x33,s,s);
     //Reading mouse click
     for( ; ; ){
	 //Updating mouse motions
	 regs.x.ax=3;int86(0x33,s,s);
	 //Reading mouse click
	 if(regs.x.bx==1){
	    gotoxy(2,2);textbackground(1);textcolor(15);
	    cprintf("Left Button Clicked!");
	    delay(100);
	    }
	 if(regs.x.bx==2){
	    gotoxy(2,2);textcolor(15);textbackground(1);
	    cprintf("Right Button Clicked!");
	    delay(100);
	    }
	 gotoxy(1,2);textbackground(1);cprintf("                         ");
	 //Printing mouse coordinates
	 gotoxy(1,1);textcolor(11);textbackground(6);
	 cprintf(" Mouse Position:(%3d,%3d)",regs.x.cx,regs.x.dx);
	 while(kbhit()){exit(0);}
	}
}
Movement of variables in Stack wihout any graphics

Code :
#include<iostream.h>
#include<conio.h>
#include<dos.h>
#include<string.h>
void hori(int,int);
void para(int,int);
void vert(int,int);
static int x=3,y=15;
char ch;
void main()
{   clrscr();
    cout <<"
enter a character and see the path	";
  cin >>ch;
      gotoxy(x,y);
      x++;
      cout<<ch;
    hori(x,y);

     getch();

}

				 /*   horizontal path  */
	   void hori(int x,int y)
	  {
//x=4,y=15
		 for(;x<=30;x++)
		 {  gotoxy(x,y);
		 delay(100);
		   cout<<" "<<ch;
		  }
//x=31,y=15
		para(x,y);
	  }


				 /*parabolic path*/
	    void para(int x,int y)
	  {
 //x31,y15
 // a,b for erasing previous print
		  int a=0,b=0;
		 for(;x<=50&&y<=30;x++,y++)
	     {	  a=x,b=y ;
		  gotoxy(x,y);
		 delay(100);
		 cout<<ch;
		 gotoxy(a,b);
		 delay(200);
		 cout<<" ";
	     }
// last values for a=49 b=29
		gotoxy(a+1,b+1);
		  delay(200);
		  cout<<" ";
//x51y31
		 vert(x,y);
	}




				/*vertical path*/

	  void vert(int x,int y)
	{
 //x51y31
	 int a=0;
	 for(;y<=40;y++)
	 {
 //a for erasing previous print
 //initial a=30
	   a=y;
	  gotoxy(x,y);  //(51,31 )
	 delay(200);
	 cout<<ch;
	 gotoxy(x,a);   //(51,30)
	 delay(200);
	 cout<<" ";
	 a++;
	  }

	  //x51y51

	  gotoxy(x,y);
	  cout<<ch;
    }   //exit at x y


Mutation strings - This is a code just to find an unknown string

#include<iostream.h>
#include<conio.h>
#include<string.h>
class mutation
{
       public:
               char id[10],p1[9],p2[9],p[9],str[4];
               int c,f;
               void sign();
               void hack();
};


                                 /*JUST LIKE THAT*/
void mutation::sign()
{
cout<<"welcome"<<endl;
 CRE:
       cout<<"Please enter your desired id:";
       cin>>id;
       cout<<"Please enter desired password:";
       cin>>p1;
       cout<<"Please confirm your password :";
       cin>>p2;
       c=strcmp(p1,p2);  /*c=0 if p1==p2 else any non zero number*/
       if(c==0)
       cout<<"Your id has been confirmed."<<endl;
       if(c!=0)
       {
       cout<<"Passwords do not match.Try again."<<endl;
       goto CRE;
       }
}



                               /*THE REAL ONE*/
void mutation::hack()
{
int a=0;
char pas[4];
cout<<"Enter a check string(of length 5 characters):";
for(a=0;a<=4;a++)
{
str[a]=getch();
cout<<"*";
}
cout<<endl;
for(pas[0]=65;pas[0]<=122;pas[0]++)
{
for(pas[1]=65;pas[1]<=122;pas[1]++)
{
for(pas[2]=65;pas[2]<=122;pas[2]++)
{
for(pas[3]=65;pas[3]<=122;pas[3]++)
{
for(pas[4]=65;pas[4]<=122;pas[4]++)
{
if(pas[0]==str[0]&&pas[1]==str[1]&&pas[2]==str[2]&&pas[3]==str[3]&&pas[4]=
=str[4])
{
cout<<"Password detected."<<endl;
cout<<"It is:"<<pas<<endl;
goto bye;
}
else
{
cout<<pas<<"		";
cout<<"trying........"<<endl;
}
}
}
}
}
}
bye:
        cout<<"Thank you for using this program."<<endl;
}



void main()
{
clrscr();
mutation one;
one.sign();
one.hack();
}
This program finds the locations of placing n queens in a n*n chessboard
so that none attack any other

Code :
#include<iostream.h>
#include<conio.h>
#include<math.h>
#include<process.h>
#include<graphics.h>
class queen
{	int n,x[100];
	public:
		queen();
		void nqueen(int,int);
		int place(int,int);
};
queen::queen()
{
	int k=1;
	textcolor(GREEN);
	cprintf("
Enter the number of queens:");
	cin>>n;
	nqueen( k, n);
}
void queen::nqueen(int k,int n)
{
	for(int i=1;i<=n;i++)
	{
		if(place(k,i))
		{
			x[k]=i;
			clrscr();
			if(k==n)
			{
				for(int j=1;j<=n;j++)
				{textcolor(x[j]);
				gotoxy(1,j);
				cprintf("
queen %d : %d",j,x[j]);
				}
				getch();

				break;
			}
			else
			nqueen(k+1,n);
		}
	}
	return;
}
int queen::place(int k,int i)
{
	int j;
	for(j=1;j<=k;j++)
	{
		if((x[j]==i)||(abs(x[j]-i)==abs(j-k)))
		return 0;
	}
	return 1;
}
void main()
{
	clrscr();
	queen q;
}


Which three balls move in three concentric oval orbit without ever colliding.


#define R 5
#include<iostream.h>
#include<conio.h>
#include<graphics.h>
#include<math.h>
#include<dos.h>
#include<stdlib.h>
void main()

 {
   void orbit(void);
   int d=DETECT,m;
   initgraph(&d,&m,"e:\tcc\bgi");
   float xx,yy,aa=15,bb=50,x,y,X,Y,a=34,b=0,A=100,B=60,ex,sq;
   setcolor(14);
 //   orbit();

   for(float i=0;i<=720;i+=.1)
   {


    x=a*cos(i+10)-a*sin(i+10);
    y=b*sin(i+10)+a*cos(i+10);

    X=A*cos(i+20)-B*sin(i+20+90);
    Y=B*sin(i+20)+B*cos(i+20+90);

    xx=aa*cos(i);
    yy=bb*sin(i);

    setcolor(14);
    setfillstyle(1,14);
    circle(x+100,y+100,R);
    floodfill(x+100,y+100,14);

    setcolor(14);
    setfillstyle(1,14);
    circle(xx+100,yy+100,R);
    floodfill(xx+100,yy+100,14);

    setcolor(14);
    setfillstyle(1,14);
    circle(X+100,Y+100,R);
    floodfill(X+100,Y+100,14);

    putpixel(X+100,Y+100,4);
    delay(100);

    setcolor(0);
    setfillstyle(1,0);
    circle(x+100,y+100,R);
    floodfill(x+100,y+100,0);

    setcolor(0);
    setfillstyle(1,0);
    circle(xx+100,yy+100,R);
    floodfill(xx+100,yy+100,0);

    setcolor(0);
    setfillstyle(1,0);
    circle(X+100,Y+100,R);
    floodfill(X+100,Y+100,0);

    if(kbhit())
	exit(1);
    orbit();
   }


 getch();
 }

 void orbit()
 {
  for(float i=0;i<=60;i+=1)
   {
    float xx,yy,aa=15,bb=50,x,y,X,Y,a=34,b=0,A=100,B=60,ex,sq;
    x=a*cos(i)-a*sin(i);
    y=b*sin(i)+a*cos(i);

    X=A*cos(i)-B*sin(i+90);
    Y=B*sin(i)+B*cos(i+90);

    xx=aa*cos(i);
    yy=bb*sin(i);

    putpixel(x+100,y+100,14);
    putpixel(X+100,Y+100,14);
    putpixel(xx+100,yy+100,14);


   }
  }
Which three balls move in three concentric oval orbit without ever colliding.


#define R 5
#include<iostream.h>
#include<conio.h>
#include<graphics.h>
#include<math.h>
#include<dos.h>
#include<stdlib.h>
void main()

 {
   void orbit(void);
   int d=DETECT,m;
   initgraph(&d,&m,"e:\tcc\bgi");
   float xx,yy,aa=15,bb=50,x,y,X,Y,a=34,b=0,A=100,B=60,ex,sq;
   setcolor(14);
 //   orbit();

   for(float i=0;i<=720;i+=.1)
   {


    x=a*cos(i+10)-a*sin(i+10);
    y=b*sin(i+10)+a*cos(i+10);

    X=A*cos(i+20)-B*sin(i+20+90);
    Y=B*sin(i+20)+B*cos(i+20+90);

    xx=aa*cos(i);
    yy=bb*sin(i);

    setcolor(14);
    setfillstyle(1,14);
    circle(x+100,y+100,R);
    floodfill(x+100,y+100,14);

    setcolor(14);
    setfillstyle(1,14);
    circle(xx+100,yy+100,R);
    floodfill(xx+100,yy+100,14);

    setcolor(14);
    setfillstyle(1,14);
    circle(X+100,Y+100,R);
    floodfill(X+100,Y+100,14);

    putpixel(X+100,Y+100,4);
    delay(100);

    setcolor(0);
    setfillstyle(1,0);
    circle(x+100,y+100,R);
    floodfill(x+100,y+100,0);

    setcolor(0);
    setfillstyle(1,0);
    circle(xx+100,yy+100,R);
    floodfill(xx+100,yy+100,0);

    setcolor(0);
    setfillstyle(1,0);
    circle(X+100,Y+100,R);
    floodfill(X+100,Y+100,0);

    if(kbhit())
	exit(1);
    orbit();
   }


 getch();
 }

 void orbit()
 {
  for(float i=0;i<=60;i+=1)
   {
    float xx,yy,aa=15,bb=50,x,y,X,Y,a=34,b=0,A=100,B=60,ex,sq;
    x=a*cos(i)-a*sin(i);
    y=b*sin(i)+a*cos(i);

    X=A*cos(i)-B*sin(i+90);
    Y=B*sin(i)+B*cos(i+90);

    xx=aa*cos(i);
    yy=bb*sin(i);

    putpixel(x+100,y+100,14);
    putpixel(X+100,Y+100,14);
    putpixel(xx+100,yy+100,14);


   }
  }
It evaluates the value of any polynomial of any degree, adds two poly
and also multiplies them

Code :

/*evaluates, adds ,multiplies two polynomials p & f to evaluate poly of
deg > 20 manipulate const in size */

#include <iostream.h>
using namespace std ;
void polyadd(float*a,int dega,float*b,int degb,float*sum)
{int i ;
if(dega>=degb)
{for (i=0;i<=dega;i++)
sum[i]=a[i]+b[i] ;}
if(degb >dega)
{for(i=0;i<=degb;i++)
sum[i]= a[i]+b[i] ; }
}
//********************************************
/*void polymult(float*a,int dega,float*b,int degb,float*mult)
{int i,j;
if(dega<=degb)
for(i=0;i<=degb;i++)
{for(j=0;j<=i;j++)
mult[i]= mult[i] + a[j]*b[i-j]  ;
mult[i] = mult[i] +a[i+1]*b[i+1] ; }
//mult[i] = mult[i] - a[0]*b[0] ; }
if (degb<dega)
{for(i=0;i<=dega;i++)
for(j=0;j<=i;j++)
 mult[i]= mult[i] +a[j]*b[i-j];
mult[i] = mult[i] +a[i+1]*b[i+1] ;} }*/
//********************************************************

double power(float*a,int n,float x)
{float val=0,prod=1 ;
int i ;
for(i=0;i<=n;i++)
{val = val+a[i]*prod;
prod = prod*x ;}
return val ; }
//********************************************************

double power(float*a,int n,float x);

main()
{const int size=20 ;
int deg,j  ;
float a[size], x ;
for(j=0;j<=size-1;j++)
a[j] = 0.0 ;
double ans ;
cout<<"give the degree of the polynomiala "<<endl ;
cin>>deg ;
if(deg<0)
cout<<"go learn ur textbook"<<endl ;
if(deg>=0)
{
cout<<"give the value of the coefficients"<<endl ;
for (j=0;j<=deg;j++)
cin>>a[j] ;
cout<<"give the value x"<<endl ;
cin>>x ;
ans  = power(a,deg,x);
cout<<"the value of p("<<x<<") = "<<ans <<endl ;
 }

float b[size],sum[size],mult[size],y  ;
for(j=0;j<=size-1;j++)
b[j] = sum[j] = mult[j] = 0 ;
int dega,degb ;
dega = deg ;
/*cout<<"give the value of the coefficients"<<endl ;
for (j=0;j<=dega;j++)
cin>>a[j]; */
cout<<" give in the degree of poly b"<<endl ;
cin>>degb ;
cout<<"enter the values of the coefficient of polynomialb"<<endl ;
for(j=0;j<=degb;j++)
cin>>b[j]  ;
cout<<"give the value to be substituted in polynomialb"<<endl ;
cin>>y ;
ans = power(b,degb,y) ;

cout<<"the value of f("<<y<<") ="<<ans<< endl ;
cout<<"the value of f("<<x<<") ="<<power(b,degb,x)<<endl ;
string decision ;
cout<<"to you want to add or multiply a and b(type a or m) "<<endl ;
cin>>decision ;
if(decision =="a")
{ polyadd(a,dega,b,degb,sum);
if (dega>=degb)
{ans= power(sum,dega,x);
cout<<"the answer after addition of p("<<x<<") +f("<<x<<") 
="<<ans<<endl
;}
if(degb>dega)
{ans = power(sum,degb,x) ;
cout<<"the answer after addition of p("<<x<<") +f("<<x<<") 
="<<ans<<endl
; }}
if (decision=="m")
//{polymult(a,dega,b,degb,mult);
//if (dega>=degb)
{ans= power(a,dega,x)*power(b,degb,y) ;

//cout<<"the answer of multiplication"<<ans<<endl ;}
//if (degb>dega)
//{ ans = power(mult,degb,x) ;
cout<<"the answer after multiplication of p("<<x<<") *f("<<y<<")
="<<ans<<endl ;}
return 0 ;}



Just arrange box from 1-15, teasing your brain


Code :

#include<graphics.h>
#include<conio.h>
#include<malloc.h>
#include<stdlib.h>
#include<bios.h>
#include<stdio.h>

#define L 75
#define R 77
#define U 72
#define D 80

     #define __LARGE__
	int getboxpos();
	 int  check_box();
		    void  quit(void) ;
    int  finish(void);

   int x,y,d,locx,locy;
     int	tboxx[]={50,80,110,140,50,80,140,140,50,80,110,110,50,80,140};
     int
tboxy[]={200,200,200,200,235,235,235,270,270,270,305,270,305,305,305};
       int  
winx[]={50,80,110,140,50,80,110,140,50,80,110,140,50,80,110};
       int
winy[]={200,200,200,200,235,235,235,235,270,270,270,270,305,305,305};
       int Vx[]={50,50,50,50,80,80,80,80,110,110,110,110,140,140,140};
       int Vy[]={200,235,270,305, 200,235,270,305, 200,235,270,305,
200,235,270};
	     struct BOX{
       int boxx,boxy;
	void *box; }b[15];
	      int empty_x=110;
	     int empty_y=235;
		     int play=0;
		    char arrange;
		    void display(void)
	   {           cleardevice();
	    for(int q=0;q<15;q++)
		 putimage(b[q].boxx,b[q].boxy,b[q].box,1);
			 gotoxy(10,2);printf("Arrangement Range :[1 - %2d]",play);
		       if(arrange=='h'){	 gotoxy(10,3);printf("Arrangement Style
:Horizontal");}
		  else  {	 gotoxy(10,3);printf("Arrangement Style :Vertical");}
			     }

void main(void)
{        char st[2];
   for(int q=0;q<15;q++)
   b[q].boxx=b[q].boxy=NULL;
 int driver=DETECT,mode;
     int deck_color=0,no_color=0;
	     clrscr();
	  dd:  gotoxy(10,5);
	   printf("Deck Color :");
	   scanf("%d",&deck_color);
	      gotoxy(10,6);
	      printf("No. Color :");
	      scanf("%d",&no_color);
	     printf("Arrangement Range upto:[4,8,10,12,15]");
	     scanf("%d",&play);
	      printf("Arrangement Style :[H]orizontal,[V]ertical");
	      arrange=getche();
	    if(deck_color==0 )goto dd;
	   else if(no_color==deck_color)goto dd;
	       if(play>15 || play<1)play=10;
	       if(arrange!='h' && arrange!='v')arrange='h';
	       initgraph(&driver,&mode,"");
 settextstyle(1,0,1);

	      for(int j=0;j<15;j++)
	    {     cleardevice();
	    setcolor(deck_color);
	    for(int i=1;i<=25;i++)
 rectangle(0,0,i,i);
	    itoa(j+1,st,10);
	setcolor(no_color);
	    outtextxy(5,2,st);
	b[j].box=  malloc(imagesize(0,0,25,25));
getimage(0,0,25,25,b[j].box);
}          cleardevice();
  setlinestyle(SOLID_LINE,1,3);
setcolor(4);
rectangle(0,0,28,28);
void	*select=  malloc(imagesize(0,0,28,28));
getimage(0,0,28,28,select);

	 randomize();
	 for(q=0;q<15;q++)
	     { aa:	int s=rand()%16;
		   if(b[s].boxx==NULL){b[s].boxx=tboxx[q];
				     b[s].boxy=tboxy[q];
				     }
		else goto aa;
	      }
			  locx=x=50;locy=y=200;
		 display();
		 putimage(x,y,select,1);
		 char ch;

	     while(1)
	      {  int key=bioskey(2);
		if((key & 0x40) && (key & 0x20))quit();
	       int	ans= finish();
	gotoxy(10,24);printf("Remaining :%2d",ans);

		 if(!ans){  getch ();quit(); }

	      xx: ch=NULL;
	      while(ch!=13){
	      ch=getch();


	      switch (ch)
	      {case L:x-=30;break;
		case R:x+=30;break;
		case D:y+=35;break;
		case U:y-=35;break;
		}
	if(x>140)x=50;if(y>305)y=200;
	if(x<50)x=140;if(y<200)y=305;
	putimage(locx,locy,select,1);
		d= getboxpos();
			putimage(locx,locy,select,1);
		     }
		 if(!check_box())goto xx;
		 putimage(locx,locy,b[d].box,1);
		putimage(empty_x,empty_y,b[d].box,1);
		b[d].boxx=empty_x;b[d].boxy=empty_y;
		empty_x=locx; empty_y=locy;
		}


}
/*~~~~~~~~~~~~~~~~~~~~~Subroutines~~~~~~~~~~~~~*/

int getboxpos()
	{
	   for(int a=0;a<15;a++)
	   {  if(x>=b[a].boxx && x<=b[a].boxx+25) {locx=b[a].boxx;break;}
	      else continue;
	      }

	      for(a=0;a<15;a++)
	   {  if(y>=b[a].boxy && y<=b[a].boxy+25) {locy=b[a].boxy;break;}
	      else continue;
	      }
	     for(a=0;a<15;a++)
	   {  if(locx==b[a].boxx && locy==b[a].boxy)return a;
	     else continue;
	   }
	   return 0;
	   }
	   int  check_box()
	     {
		   if(abs(locx-empty_x)==30 && abs(locy-empty_y)==0)
		   {
	      gotoxy(60,12);	 printf("                  ");

	     return 1; }
		else if(abs(locx-empty_x)==0 && abs(locy-empty_y)==35)
				   {
	      gotoxy(40,16);	 printf("                  ");

	     return 1; }

		   else
		   {
	      gotoxy(40,16);	 printf("Invalid Selection.");

	      }
	      return 0;
	      }
	    void  quit(void) {

		   closegraph();
    restorecrtmode();
    printf("



	Hoped you Enjoyed !");
if(play!=15)	   printf("

Try arranging other ranges.");
      exit(0);
      }
    int  finish(void)
    {  if(arrange=='h'){ for(int t=0;t<play;t++)
	 { if(b[t].boxx!=winx[t] || b[t].boxy!=winy[t]) return (play-t);
	  else
	  continue;
	  }           }
	else {
			for(int t=0;t<play;t++)
	 { if(b[t].boxx!=Vx[t] || b[t].boxy!=Vy[t]) return (play-t);
	  else
	  continue;
	  }           }
       return 0;
       }


Rational Mini Project. About overloading of operators

Code :

//main subject:operator-overloading

#include <iostream.h>

class rational
{
private:
	int a;
	int b;
public:
	rational(int=1,int=1);
	void set_ab(int,int);
	void print_fraction();
    void print_floating();
	rational operator+(rational object);
    rational operator-(rational object);
	rational operator*(rational object);
    rational operator/(rational object);
    rational operator=(rational object);
	friend ostream &operator<<(ostream &,rational &);
	friend istream &operator>>(istream &,rational &);
	int operator==(rational object);
	int operator!=(rational object);
	int operator>(rational object);
	int operator<(rational object);
};

/*--------------------------------------------------------*/

rational::rational(int m,int n)
{
	set_ab(m,n);
}

/*--------------------------------------------------------*/

void rational::set_ab(int x,int y)
{
	int temporary,m,n;
	m=x;
    n=y;
	if(n>m)
	{
		temporary=n;
		n=m;
		m=temporary;
	}
	while(m!=0 && n!=0)
	{
		if(m%n==0)
			break;
		temporary=m%n;
		m=n;
		n=temporary;
		continue;
	}
 	a=x/n;
	b=y/n;

}

/*--------------------------------------------------------*/

void rational::print_fraction()
{
	cout<<a<<"/"<<b<<"=";
}

/*--------------------------------------------------------*/

void rational::print_floating()
{
	cout<<(float)a/b<<endl;
}

/*--------------------------------------------------------*/

rational rational::operator+(rational object)
{
	rational temporary;
	temporary.a=a*object.b+b*object.a;
	temporary.b=b*object.b;
	return(temporary);
}

/*--------------------------------------------------------*/

rational rational::operator-(rational object)
{
	rational temporary;
	temporary.a=a*object.b-b*object.a;
	temporary.b=b*object.b;
	return(temporary);
}

/*--------------------------------------------------------*/

rational rational::operator*(rational object)
{
	rational temporary;
	temporary.a=a*object.a;
    temporary.b=b*object.b;
	return(temporary);
}

/*--------------------------------------------------------*/

/*
rational rational::operator/(rational object)
{
	rational temporary;
	temporary.a=a*object.b;
	temporary.b=b*object.a;
	return(temporary);
}
*/

/*--------------------------------------------------------*/

rational rational::operator/(rational object)
{
	a=a*object.b;
	b=b*object.a;
	return(*this);
}

/*--------------------------------------------------------*/

rational rational::operator=(rational object)
{
	a=object.a;
	b=object.b;
	return(*this);
}

/*--------------------------------------------------------*/

ostream &operator<<(ostream &output,rational &object)
{
	output<<object.a<<"/"<<object.b<<endl;
	return output;
}

/*--------------------------------------------------------*/

istream &operator>>(istream &input,rational &object)
{
	cout<<"Enter a,b:"<<endl;
	input>>object.a;
	input>>object.b;
	return input;
}

/*--------------------------------------------------------*/

int rational::operator==(rational object)
{
	if(a==object.a && b==object.b)
		return(1);
	else
		return(0);
}

/*--------------------------------------------------------*/

int rational::operator!=(rational object)
{
	if(a!=object.a || b!=object.b)
		return(1);
	else
		return(0);
}

/*--------------------------------------------------------*/

int rational::operator>(rational object)
{
	return((a/b)>(object.a/object.b) ? 1:0);
}

/*--------------------------------------------------------*/

int rational::operator<(rational object)
{
	return((a/b)<(object.a/object.b) ? 1:0);
}

/*--------------------------------------------------------*/

int main()
{
	rational x(3,4),y(3,4),z1,z2,z3,z4,z5;
	if(x==y)
	{cout<<"These 2 fractions are equl."<<endl;}
	if(x!=y)
	{cout<<"These 2 fractions are not equl."<<endl;}
	if(x>y)
	{cout<<"x is bigger than y."<<endl; }
	if(x<y)
	{cout<<"x is smaller than y."<<endl;}
	z1=x+y;
	cout<<"z1=x+y=";
	z1.print_fraction();
	z1.print_floating();
	z2=x-y;
	cout<<"z2=x-y=";
	z2.print_fraction();
	z2.print_floating();
	z3=x*y;
	cout<<"z3=x*y=";
	z3.print_fraction();
	z3.print_floating();
	z4=x/y;
	cout<<"z4=x/y=";
	z4.print_fraction();
	z4.print_floating();
	z5=y=x;
	cout<<"x=";
	x.print_fraction();
	x.print_floating();
	cout<<"y=";
	y.print_fraction();
	y.print_floating();
	cout<<"z5=";
	z5.print_fraction();
	z5.print_floating();

/*	rational k(1,1),l(1,1),z6,z7,z8,z9,z10;
	cin>>k>>l;
	if(k==l)
	{cout<<"These 2 fractions are equl."<<endl;}
	if(k!=l)
	{cout<<"These 2 fractions are not equl."<<endl;}
    if(k>l)
	{cout<<"k is bigger than l."<<endl;}
	if(k<l)
	{cout<<"k is smaller than l."<<endl;}
	z6=k+l;
	z7=k-l;
	z8=k*l;
	z9=k/l;
	z10=l=k;
	cout<<"z6="<<z6<<"z7="<<z7<<"z8="<<z8<<"z9="<<z9;
	cout<<"k="<<k<<"l="<<l<<"z10="<<z10;
*/
	return(0);
}
When you run the program the send to folder will be opened.

/*

*
* Simple program that opens the "Send to" folder of the current user. 
The
* location of this folder can be obtained from
SHGetSpecialFolderLocation().
* Then sf tries to convert the Item Identifier to a string using
* SHGetPathFromIDList() and opens the folder using ShellExecute().
*

*/


#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>


int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInst,
                   LPSTR lpCmdLine,int nCmdShow)
{

  LPITEMIDLIST pidl;
  LPMALLOC     lpMalloc;
  char         sz[MAX_PATH];

  char         *pErrMsg  = "Error opening "Send to" folder.";
  char         *pCaption = "Send to";

  if (NOERROR == SHGetSpecialFolderLocation(
                   NULL,CSIDL_SENDTO,&pidl))
  {
    SHGetPathFromIDList(pidl,sz);

    if (NOERROR == SHGetMalloc(&lpMalloc))
    {
      lpMalloc->lpVtbl->Free(lpMalloc,pidl);
      lpMalloc->lpVtbl->Release(lpMalloc);
    }

    if (32 >= 
(int)ShellExecute(NULL,"open",sz,NULL,NULL,SW_SHOWNORMAL))
      MessageBox(NULL,pErrMsg,pCaption,MB_ICONEXCLAMATION);
  }

  else
    MessageBox(NULL,pErrMsg,pCaption,MB_ICONEXCLAMATION);

  return(0);

}


Program for book shop using pointers to base class
This is a simple program that is used to provide
information abt the book details n ect

Code :


#include<iostream.h>
#include<conio.h>
class book
{
char name[30];
long int tel;
public:
void read()
{
cout<<"
name:" ;
cin>>name;
cout<<name;
cout<<"
tel:";
cin>>tel;
}
void disp()
{
cout<<"
PURCHASER DETAILS : ";
cout<<"
Name : "<<name;
cout<<"
Tel No.:"<<tel;
}
};
class shop:public book
{
char isbn[20],bname[30];
long int price;
public:
void read()
{
cout<<"
Book-Name : ";
cin>>bname;
cout<<"
ISBN NO. : ";
cin>>isbn;
cout<<"
Price of Book : Rs.";
cin>>price;
}
void disp()
{
cout<<"

BOOK DETAILS :";
cout<<"
Book-Name :" <<bname;
cout<<"
ISBN No. :"<<isbn;
cout<<"
Price : Rs."<<price;
}
};
void main()
{
clrscr();
book *ptr;
book p;
ptr=&p;
cout<<"
Enter details of purchaser : ";
(*ptr).read();
shop c;
ptr=&c;
cout<<"
Enter the details of the book sold : ";
((shop *)ptr)->read();
(*ptr).disp();
((shop *)ptr)->disp();
getch();
}
Solar System - Demo of Graphics in C.

#include"stdio.h"
#include"graphics.h"
#include"conio.h"
#include"dos.h"
#include"math.h"
#include"stdlib.h"


void main()
{
	int gd=DETECT,gm;
	float 
i=0,j=100,me=75,ve=23,ma=105,ju=175,sa=10,ur=300,ne=200,pl=175,s=0;
	int x,y,k,tri[8],si,sx=random(300),sy=random(400),X,Y,ss;
	unsigned int
earth,moon,mercury,venus,mars,jupiter,saturn,uranus,neptune,pluto,sunsize,
ship,ship2;
	void
*ear,*moo,*mer,*ven,*mar,*jup,*sat,*ura,*nep,*plu,*sun,*ships,*ships2;
	x=300;
	y=210;

	initgraph(&gd,&gm,"c:\tc\bgi");

	setfillstyle(1,10);
	setcolor(2);
	fillellipse(50,50,13,13);
	earth=imagesize(35,35,65,65);
	ear=malloc(earth);
	getimage(35,35,65,65,ear);
	cleardevice();

	setfillstyle(1,15);
	setcolor(15);
	fillellipse(25,25,5,5);
	moon=imagesize(15,15,35,35);
	moo=malloc(moon);
	getimage(15,15,35,35,moo);
	cleardevice();

	setfillstyle(1,4);
	setcolor(4);
	fillellipse(15,15,4,4);
	mercury=imagesize(10,10,20,20);
	mer=malloc(mercury);
	getimage(10,10,20,20,mer);
	cleardevice();


	setfillstyle(1,11);
	setcolor(11);
	fillellipse(15,15,7,7);
	venus=imagesize(7,7,23,23);
	ven=malloc(venus);
	getimage(7,7,23,23,ven);
	cleardevice();


	setfillstyle(1,6);
	setcolor(6);
	fillellipse(20,20,14,14);
	mars=imagesize(5,5,35,35);
	mar=malloc(mars);
	getimage(5,5,35,35,mar);
	cleardevice();


	setfillstyle(1,7);
	setcolor(7);
	fillellipse(25,25,18,18);
	jupiter=imagesize(5,5,45,45);
	jup=malloc(jupiter);
	getimage(5,5,45,45,jup);
	cleardevice();


	setfillstyle(1,8);
	setcolor(8);
	fillellipse(50,50,12,12);
	uranus=imagesize(35,35,65,65);
	ura=malloc(uranus);
	getimage(35,35,65,65,ura);
	cleardevice();

	setfillstyle(1,12);
	setcolor(12);
	fillellipse(50,50,11,11);
	neptune=imagesize(35,35,65,65);
	nep=malloc(neptune);
	getimage(35,35,65,65,nep);
	cleardevice();

	setfillstyle(1,1);
	setcolor(1);
	fillellipse(50,50,8,8);
	pluto=imagesize(35,35,65,65);
	plu=malloc(pluto);
	getimage(35,35,65,65,plu);
	cleardevice();


	setcolor(14);
	setfillstyle(1,14);
	fillellipse(40,40,25,25);
	for(si=0; si<25; si++)
	{
	tri[0]=(40+25*cos(s));
	tri[1]=(40+25*sin(s));
	s=s+0.3;
	tri[2]=(40+25*cos(s));
	tri[3]=(40+25*sin(s));

	tri[4]=(40+40*cos((2*s-0.3)/2));
	tri[5]=(40+40*sin((2*s-0.3)/2));

	tri[6]=tri[0];
	tri[7]=tri[1];

	fillpoly(4,tri);

	}

	sunsize=imagesize(0,0,80,80);
	sun=malloc(sunsize);
	getimage(0,0,80,80,sun);
	cleardevice();

	setfillstyle(1,15);
	setcolor(15);
	fillellipse(40,40,33,16);
	fillellipse(40,25,15,10);
	setfillstyle(1,2);
	fillellipse(14,37,5,5);
	fillellipse(35,40,5,5);
	fillellipse(55,39,5,5);
	setfillstyle(1,4);
	fillellipse(25,39,5,5);
	fillellipse(46,40,5,5);
	fillellipse(65,37,5,5);
	setfillstyle(1,0);
	fillellipse(30,20,2,2);
	fillellipse(35,20,2,2);
	fillellipse(40,20,2,2);
	fillellipse(45,20,2,2);
	fillellipse(50,20,2,2);
	ship=imagesize(0,0,80,80);
	ships=malloc(ship);
	getimage(0,0,80,80,ships);
	cleardevice();

	setfillstyle(1,15);
	setcolor(15);
	fillellipse(40,40,33,16);
	fillellipse(40,25,15,10);
	setfillstyle(1,4);
	fillellipse(14,37,5,5);
	fillellipse(35,40,5,5);
	fillellipse(55,39,5,5);
	setfillstyle(1,2);
	fillellipse(25,39,5,5);
	fillellipse(46,40,5,5);
	fillellipse(65,37,5,5);
	setfillstyle(1,0);
	fillellipse(30,20,2,2);
	fillellipse(35,20,2,2);
	fillellipse(40,20,2,2);
	fillellipse(45,20,2,2);
	fillellipse(50,20,2,2);
	ship2=imagesize(0,0,80,80);
	ships2=malloc(ship2);
	getimage(0,0,80,80,ships2);
	cleardevice();



	setfillstyle(1,9);
	setcolor(9);
	fillellipse(45,45,16,16);
	setcolor(8);
	ellipse(45,45,125,390,20,7);
	setcolor(1);
	ellipse(45,45,120,400,23,8);
	setcolor(4);
	ellipse(45,45,120,400,25,9);
	setcolor(5);
	ellipse(45,45,120,424,28,10);
	setcolor(6);
	ellipse(45,45,115,425,30,11);
	saturn=imagesize(0,0,50,50);
	sat=malloc(saturn);
	getimage(0,0,75,75,sat);
	cleardevice();
	setcolor(15);


	for(i=0; i<1000 && !kbhit(); i++)
	{
		moveto(getmaxx()/2,getmaxy()/2);
		
lineto(random(600)+random(600)*cos(i),random(600)+random(600)*sin(i));
//		setcolor(i);
		delay(10);
	}
	cleardevice();

	delay(300);
	setlinestyle(0,0,3);
	rectangle(0,0,getmaxx(),getmaxy());
	delay(700);
	for(i=0; i<1000; i++)
	{
		putpixel(random(630),random(530),15);
		putpixel(random(630),random(530),11);
		delay(5);
	}
	setlinestyle(3,0,1);

//	ellipse(x,y,0,360,10+cos(0.2)+13,8+sin(0.2)+13);
	setlinestyle(0,0,1);

	for(k=0; k<200; k++)
	{
		i=i+0.2;
		j=j+0.7;
		me=me+0.1;
		ve=ve+0.3;
		ma=ma+0.1;
		ju=ju+0.08;
		sa=sa+0.07;
		ur=ur+0.06;
		ne=ne+0.05;
		pl=pl+0.04;
		putpixel(x+100*cos(i)+13,y+80*sin(i)+13,10);
//		
putpixel(x+(100*cos(i))+(30*cos(j))+5,y+(80*sin(i))+(25*sin(j))+5,1);
		putpixel(x+60*cos(me)+4,y+40*sin(me)+4,4);
		putpixel(x+80*cos(ve)+7,y+60*sin(ve)+7,3);
		putpixel(x+125*cos(ma)+14,y+110*sin(ma)+14,6);
		putpixel(x+165*cos(ju)+18,y+130*sin(ju)+18,7);
		putpixel(x+220*cos(sa)+30+16,y+170*sin(sa)+30+16,9);
		putpixel(x+250*cos(ur)+12,y+200*sin(ur)+12,8);
		putpixel(x+280*cos(ne)+11,y+230*sin(ne)+11,12);
		putpixel(x+310*cos(pl)+8,y+250*sin(pl)+8,1);


	}


		setfillstyle(1,14);
		setcolor(14);
		fillellipse(x,y,25,25);
		delay(250);
		putimage(x-40,y-40,sun,XOR_PUT);
		setlinestyle(0,0,1);
		setfillstyle(1,14);
		setcolor(14);
		fillellipse(x,y,25,25);
		delay(250);
		putimage(x+100*cos(i),y+80*sin(i),ear,XOR_PUT);
		delay(250);

putimage(x+(100*cos(i))+(30*cos(j)),y+(80*sin(i))+(25*sin(j)),moo,XOR_PUT)
;
		delay(250);
		putimage(x+60*cos(me),y+40*sin(me),mer,XOR_PUT);
		delay(250);
		putimage(x+80*cos(ve),y+60*sin(ve),ven,XOR_PUT);
		delay(250);
		putimage(x+125*cos(ma),y+110*sin(ma),mar,XOR_PUT);
		delay(250);
		putimage(x+165*cos(ju),y+130*sin(ju),jup,XOR_PUT);
		delay(250);
		putimage(x+220*cos(sa),y+170*sin(sa),sat,XOR_PUT);
		delay(250);
		putimage(x+250*cos(ur),y+200*sin(ur),ura,XOR_PUT);
		delay(250);
		putimage(x+280*cos(ne),y+230*sin(ne),nep,XOR_PUT);
		delay(250);
		putimage(x+310*cos(pl),y+250*sin(pl),plu,XOR_PUT);


		putimage(x-40,y-40,sun,XOR_PUT);
		setlinestyle(0,0,1);
		setfillstyle(1,14);
		setcolor(14);
		fillellipse(x,y,25,25);

		putimage(x+100*cos(i),y+80*sin(i),ear,XOR_PUT);

putimage(x+(100*cos(i))+(30*cos(j)),y+(80*sin(i))+(25*sin(j)),moo,XOR_PUT)
;
		putimage(x+60*cos(me),y+40*sin(me),mer,XOR_PUT);
		putimage(x+80*cos(ve),y+60*sin(ve),ven,XOR_PUT);
		putimage(x+125*cos(ma),y+110*sin(ma),mar,XOR_PUT);
		putimage(x+165*cos(ju),y+130*sin(ju),jup,XOR_PUT);
		putimage(x+220*cos(sa),y+170*sin(sa),sat,XOR_PUT);
		putimage(x+250*cos(ur),y+200*sin(ur),ura,XOR_PUT);
		putimage(x+280*cos(ne),y+230*sin(ne),nep,XOR_PUT);
		putimage(x+310*cos(pl),y+250*sin(pl),plu,XOR_PUT);

	for(k=0; k<200; k++)
	{
		i=i+0.2;
		j=j+0.7;
		me=me+0.1;
		ve=ve+0.3;
		ma=ma+0.1;
		ju=ju+0.08;
		sa=sa+0.07;
		ur=ur+0.06;
		ne=ne+0.05;
		pl=pl+0.04;
		putpixel(x+100*cos(i)+13,y+80*sin(i)+13,10);
//		
putpixel(x+(100*cos(i))+(30*cos(j))+5,y+(80*sin(i))+(25*sin(j))+5,1);
		putpixel(x+60*cos(me)+4,y+40*sin(me)+4,4);
		putpixel(x+80*cos(ve)+7,y+60*sin(ve)+7,3);
		putpixel(x+125*cos(ma)+14,y+110*sin(ma)+14,6);
		putpixel(x+165*cos(ju)+18,y+130*sin(ju)+18,7);
		putpixel(x+220*cos(sa)+30+16,y+170*sin(sa)+30+16,9);
		putpixel(x+250*cos(ur)+12,y+200*sin(ur)+12,8);
		putpixel(x+280*cos(ne)+11,y+230*sin(ne)+11,12);
		putpixel(x+310*cos(pl)+8,y+250*sin(pl)+8,1);


	}

	i=0;j=100;me=75;ve=23;ma=105;ju=175;sa=10;ur=300;ne=200;pl=175;


	while(!kbhit())

	{
		i=i+0.2;
		j=j+0.7;
		me=me+0.1;
		ve=ve+0.3;
		ma=ma+0.1;
		ju=ju+0.08;
		sa=sa+0.07;
		ur=ur+0.06;
		ne=ne+0.05;
		pl=pl+0.04;

		putimage(x-40,y-40,sun,XOR_PUT);
		setlinestyle(0,0,1);
		setfillstyle(1,14);
		setcolor(14);
		fillellipse(x,y,25,25);

		putimage(x+100*cos(i),y+80*sin(i),ear,XOR_PUT);

putimage(x+(100*cos(i))+(30*cos(j)),y+(80*sin(i))+(25*sin(j)),moo,XOR_PUT)
;
		putimage(x+60*cos(me),y+40*sin(me),mer,XOR_PUT);
		putimage(x+80*cos(ve),y+60*sin(ve),ven,XOR_PUT);
		putimage(x+125*cos(ma),y+110*sin(ma),mar,XOR_PUT);
		putimage(x+165*cos(ju),y+130*sin(ju),jup,XOR_PUT);
		putimage(x+220*cos(sa),y+170*sin(sa),sat,XOR_PUT);
		putimage(x+250*cos(ur),y+200*sin(ur),ura,XOR_PUT);
		putimage(x+280*cos(ne),y+230*sin(ne),nep,XOR_PUT);
		putimage(x+310*cos(pl),y+250*sin(pl),plu,XOR_PUT);

		for(ss=0; ss<7; ss++)
		{
			X=random(10);
			Y=random(10);

			if(X>3)
				sx=sx+5;
			else
				sx=sx-5;

			if(Y>3)
				sy=sy+5;
			else
				sy=sy-5;

			if(ss%2==0)
			{
				putimage(sx,sy,ships,XOR_PUT);
				delay(100);
				putimage(sx,sy,ships,XOR_PUT);
			}
			else
			{
				putimage(sx,sy,ships2,XOR_PUT);
				delay(100);
				putimage(sx,sy,ships2,XOR_PUT);
			}

		}
		if(sx>getmaxx() || sx<=0)
			sx=random(300);

		if(sy>getmaxy() || sy<=0)
			sy=random(300);
		putimage(x+100*cos(i),y+80*sin(i),ear,XOR_PUT);

putimage(x+(100*cos(i))+(30*cos(j)),y+(80*sin(i))+(25*sin(j)),moo,XOR_PUT)
;
		putimage(x+60*cos(me),y+40*sin(me),mer,XOR_PUT);
		putimage(x+80*cos(ve),y+60*sin(ve),ven,XOR_PUT);
		putimage(x+125*cos(ma),y+110*sin(ma),mar,XOR_PUT);
		putimage(x+165*cos(ju),y+130*sin(ju),jup,XOR_PUT);
		putimage(x+220*cos(sa),y+170*sin(sa),sat,XOR_PUT);
		putimage(x+250*cos(ur),y+200*sin(ur),ura,XOR_PUT);
		putimage(x+280*cos(ne),y+230*sin(ne),nep,XOR_PUT);
		putimage(x+310*cos(pl),y+250*sin(pl),plu,XOR_PUT);


	}


	getch();
	closegraph();
}
String operation

#include<stdio.h>
#include<conio.h>
#include<string.h>
int STRLEN(char*);
int STRCPY(char*,char*);
int STRCMP(char*,char*);
int STRCAT(char*,char*,char*);
int STRREV(char*);
void main()
{
	int c;
	char str[20],str1[10],str2[10],str3[20];
	clrscr();
	re:
	printf("
Enter choice=>");
	printf("
		1:string len.
		2:string copy
		3:string
cmp.
		4:string cat.
		5:string rev.");
	printf("
		6:for exit=>");
	scanf("%d",&c);switch(c)
	{
		case 1:
			printf("Enter the string=>");
			scanf("%s",&str1);
			printf("string length=>%d
",STRLEN(str1));
			break;
		case 2:
			printf("
Enter the string=>");
			scanf("%s",str1);
			STRCPY(str2,str1);
			printf("copied string=>");
			puts(str2);
			break;
		case 3:
			printf("Enter two string=>");
			scanf("%s",&str1);
			scanf("%s",&str2);
			if(STRCMP(str2,str1))
				printf("string is equal");
			else
				printf("String is not equal");
			break;
		case 4:
			printf("Enter two string=>");
			scanf("%s",str1);
			scanf("%s",str2);
			STRCAT(str3,str2,str1);
			puts(str3);
			break;
		case 5:
			printf("Enter the string=>");
			scanf("%s",str1);
			STRREV(str1);
			printf("Reverse stringis=>");
			puts(str1);
			break;
		default:
			goto end;
	}
	goto re;
end:
getch();
}
int STRLEN(char *s)
{
	int i=0;
	while(*s!=NULL)
	{
		i++;
		s++;
	}
	return i;
}
int STRCPY(char *s2,char *s1)
{
	while(*s1!=NULL)
	{
		*s2=*s1;
		s2++;
		s1++;
	}
	*s2=NULL;
	return 1;
}
int STRCMP(char *s2,char *s1)
{
	int i=0,len1,len2;
	len1=strlen(s1);
	len2=strlen(s2);
	if(len1==len2)
	{
		while(*s2==*s1 && *s2 != NULL && *s1!=NULL)
		{
			i++;
			s1++;
			s2++;
		}
		if(i==len1)
			return 1;
		else
			return 0;
	}
	else
	{
		return 0;
	}
}
int STRREV(char *s)
{
	int len;
	char *s1;
	char *ptr;
	len=strlen(s);
	s1=(char *)malloc(sizeof(char));
	strcpy(s1,s);
	ptr=s1+len-1;
	while(*s!=NULL)
	{
		*s=*ptr;
		ptr--;
		s++;
		s1++;
	}
	*s=NULL;
	return 1;
}
int STRCAT(char *s3,char *s2,char *s1)
{
	while(*s1!=NULL)
	{
		*s3=*s1;
		s3++;
		s1++;
	}
	s3++;
	while(*s2!=NULL)
	{
		*s3=*s2;
		s3++;
		s2++;
	}
	*s3=NULL;
	return 1;
}
This virtual calender shows current month and user can navigate
through previous or next month / year using arrow keys

Code :
#include "conio.h"
#include "stdlib.h"
#include "dos.h"
#include "string.h"
#include "stdio.h"

void draw(int, int);  		//DRAWS BOX WITH MONTH & YEAR IN HEADER
void show_time();     		//DISPLAYS CURRENT TIME IN FOOTER OF BOX
void print_cal( int, int); //PRINTS DATES WITHIN BOX
int getkey();              //SCANS USER KEY AND RETUEN ITS SCAN CODE
int first_day( int, int ); //DETEMINES FIRST DAY OF MONTH
int today;

void main()
{
	int year, month;
	char ch;
	struct date d;
	getdate(&d);        //RETURNS CURRENT DATE
	year = d.da_year;
	month = d.da_mon - 1;
	today = d.da_day - 1;     //GET CURRENT DATE
	print_cal(year, month); //PRINTS CALENDER OF CURRENT MONTH
	flushall();
	while((ch = getkey()) != 1) //KEEP TRACK OF KEYS UNTILL 'ESC' PRESSED
	{
		switch(ch)
		{
			case 72: year++;  //UP ARROW KEY
						break;
			case 80: year--; //DOWN ARROW KEY
						break;

			case 77: month++;        //RIGHT ARROW KEY
						if(month > 11)
						{
							month = 0;
							year++;
						}
						break;
			case 75: month--;       //LEFT ARROW KEY
						if(month < 0)
						{
							month = 11;
							year--;
						}
						break;
		}
		print_cal(year, month);  //PRINTS CALENDER OF CHANGED MONTH OR YEAR
	}
}
void show_time()
{
	struct  time t;
	while(!kbhit())
	{
		textcolor(YELLOW);
		gettime(&t);  			//GET CURRENT TIME
		gotoxy(22,2);
		if(t.ti_hour < 13)
			printf(" CURRENT TIME => %2d:%02d:%02d AM",t.ti_hour, t.ti_min,
t.ti_sec);
		else
		{
			t.ti_hour -= 12;
			printf(" CURRENT TIME => %2d:%02d:%02d PM",t.ti_hour, t.ti_min,
t.ti_sec);
		}

		delay(1000);
	}
}

int first_day(int year, int month)  //DETEMINES FIRST DAY OF MONTH
{
	int mdays[] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 
334};
	int lpyear = ((year-1900)/4) + ((year-1900)/400) - ((year-1900)/100);
	long unsigned days = ((year-1900)*365) + lpyear + mdays[month];
	return days % 7;
}
int getkey()    //SCANS USER KEY AND RETURN ITS SCAN CODE
{
	union REGS i,o;
	while(!kbhit())
		;
	i.h.ah = 0;
	int86(22,&i,&o);
	return(o.h.ah);
}
void draw(int year, int month) //DRAWS BOX WITH MONTH & YEAR IN HEADER
{
	char *mo[] = { "January", "Feburary", "March", "April",
						"May", "June", "July", "August", "September",
						"October",  "November", "December" };
	char *day[] = { "SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"};
	int i, j;
	int ro = 205, co = 186;  //GARPH CHAR 205 '?', 186 '?'
	clrscr();
	gotoxy(16, 8);
	printf("USE ARROW KEYS TO NAVIGATE AND ESC KEY TO CLOSE");
	for( i = 16; i <= 65; i++)
	{	gotoxy(i,10);
		printf ("%c",ro);
		gotoxy(i,14);
		printf ("%c",ro);
		gotoxy(i,36);
		printf ("%c",ro);
		gotoxy(i,40);
		printf ("%c",ro);
	}
	for(i = 11; i <= 39; i++)
	{	gotoxy(15,i);
		printf ("%c",co);
		gotoxy(66,i);
		printf ("%c",co);
	}
	gotoxy(15,10);
	printf("%c",201);  //GARPH CHAR 201 '?'
	gotoxy(66,10);
	printf("%c",187);  //GARPH CHAR 187 '?'
	gotoxy(15,40);
	printf("%c",200);  //GARPH CHAR 200 '?'
	gotoxy(66,40);
	printf("%c",188);  //GARPH CHAR 188 '?'
	gotoxy(15,14);
	printf("%c",204);  //GARPH CHAR 204 '?'
	gotoxy(66,14);
	printf("%c",185);  //GARPH CHAR 185 '?'
	gotoxy(15,36);
	printf("%c",204);  //GARPH CHAR 204 '?'
	gotoxy(66,36);
	printf("%c",185);  //GARPH CHAR 185 '?'

	textcolor(YELLOW + BLINK);
	int hed_sp = 16 +((49 - (strlen(mo[month]) + 5))/2); //ALLIGN HEADER 
TO
CENTER
	gotoxy(hed_sp,12);
	cprintf("%s %d",mo[month],year);
	window(16,15,65,35);
	clrscr();
	for(i=1, j = 0; i<49; i+=7,j++) //PRINT DAY NAMES
	{
		  if(i < 7)
		textcolor(RED); // FOR SUNDAY
		  else
		textcolor(YELLOW); //OTHER THAN SUNDAY
		gotoxy(i,3);
		cprintf("%5s",day[j]);
	}
}
void print_cal(int year, int month)
{
	int i, j, start, count, limit;
	textmode(64);
	start = first_day(year, month);
	count = 0, limit = 31;
	draw(year, month);
	if( month == 3 || month == 5 || month == 8 || month == 10 )
	limit = 30;     //FOR APRIL, JUNE, SEPT, NOV
	if(month == 1 ) //FOR FEB
		limit = (year% 4==0 && year%100 != 0 || year%400==0)? 29: 28;
	for(j=7; j< 20; j+=3) //ROW COUNTER
	{
	  for(i=1; i<49; i+=7) //COLUMN COUNTER
	  {
			if(i < 7)
				textcolor(RED);     //DATES ON SUNDAY
			else
				textcolor(YELLOW);
			gotoxy(i,j);
			if(start)
				start--;     //EMPTY SPACES TILL NUMBERING STARTS
			else
			{
				if(count == today)      //HILIGHT CURRENT DATE
				{
					textcolor(BLUE);
					textbackground(YELLOW);
				}
				else
				{
					textcolor(YELLOW);
					textbackground(BLACK);
				}
				cprintf("%4d",count+1);   //PRINT DATE
				count++;
			}
			if(count >= limit)
				break;
		}
	}
	if(count <= 30 && count < limit) //FOR PRINTING IN FIRST ROW IF ALL 
ROWS
EXUASTED
	{  for(i=1; i<49; i+=7)
		{
		if(i < 7)
			textcolor(RED);
		else
			textcolor(YELLOW);
		gotoxy(i,7);
		if(count == today)
		{
			textcolor(BLUE);
			textbackground(YELLOW);
		}
		else
		{
			textcolor(YELLOW);
			textbackground(BLACK);
		}
		cprintf("%4d",count+1);
		count++;
		if(count >= limit)
		break;
		}
	}
	window(16,37,65,39);  //SETS WINDOW TO BOTTOM OF BOX
	show_time();          //SHOWS TIME
}
A simple class called Point, with all necessary functions

# include<iostream.h>
# include<conio.h>
# include<math.h>

class point
{
	int x,y,z;
public:
	point()
	{
		x=y=z=0;
	}
	point(int i,int j,int k)
	{
		x=i;
		y=j;
		z=k;
	}
	point(point &a)
	{
		x=a.x;
		y=a.y;
		z=a.z;
	}

	negate()
	{
		x=-x;
		y=-y;
		z=-z;
	}
	void print()
	{
		cout<<"("<<x<<","<<y<<","<<z<<")";
	}
	int norm()
	{
		return(sqrt(x*x+y*y+z*z));
	}
};
void main()
{
clrscr();
point p(2,3,4),p1(p);

cout<<"The point has the coordinates ";
p.print();
cout<<"
The point coordinates after negation ";
p.negate();
p.print();
cout<<"
Normal Distance of the point from (0,0,0) is "<<p.norm();
cout<<"
The coordinates of the point p1 after copy constructor is ";
p1.print();
getch();
}
Accessing Private Data Members in C++. This is a flaw in the language

#include <iostream.h>
#include <string.h>
#include <conio.h>

class bestcoder
{
  private:

     char name[40];
     char grade;
     int age;

  public:

 bestcoder(char* nam="Some Dude",char gr='A',int saal=25)
      {
         strcpy(name,nam);
         grade=gr;
         age=saal;
      }

 friend ostream& operator <<(ostream& s,bestcoder b);
};

ostream& operator <<(ostream& s,bestcoder b)
{
  s<<"Best Coder  :"<<b.name<<endl
  		 <<"His Rating  :"<<b.grade<<endl
   <<"Current Age :"<<b.age<<"

";
   return s;
}

struct hackit
{
  char name[40];
  char grade;
  char age;
};

void main()
{
 bestcoder bc;
 cout<<bc;
 void* ptr=&bc;
 struct hackit* bettercoder=(hackit*)ptr;
 bettercoder->grade='F';
 bettercoder->age=56;
 cout<<bc;
 strcpy(bettercoder->name,"xxx");
 bettercoder->age=14;
 bettercoder->grade='A';
 cout<<bc;
 getch();
}
Banking Project

#include<fstream.h>
#include<stdio.h>
#include<conio.h>
#include<string.h>
#include<iostream.h>
#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <dos.h>
      void punit (void);
      void deposit(void);
      void addrecord();
      void delrecord();
      void modrecord();
      void disprecord();
      void dispall();
      void withdraw();
   float w,z;
                 class account
  {
                  int accountno,cls;
                  char name[30],type;
                  float deposit,withdraw;
  public:
                  account()
 {
                deposit=withdraw=0;
    }
                    int giveaccountno()
 {
                      return accountno;
    }
                void getdata(int mrno)
 {
                    accountno=mrno+1;
                      cout<<"ACCOUNT NUMBER        ::  ";
                      cout<<accountno<<"
";
                      cout<<"ENTER YOUR NAME       ::  ";
                gets(name);
                      cout<<"
";
                    cout<<"ENTER TYPE OF ACCOUNT SAVING(s)/CURRENT(c)  ::  ";
                cin>>type;
                   cout<<"
";
                   cout<<"ENTER INITIAL AMOUNT  ::Rs  ";cin>>deposit;
                   cout<<"
";
  }
                void withdrawal(int m)
   {
                   cout<<"AMOUNT BEFORE WITHDRAWING::Rs  "<<deposit<<"
";
      deposit=deposit-m;
                   cout<<"AMOUNT AFTER WITHDRAWING::Rs  "<<deposit;
    }
                void deposital(int m)
 {
                   cout<<"AMOUNT BEFORE DEPOSIT::Rs  "<<deposit<<"
";
    deposit=deposit+m;
                   cout<<"AMOUNT AFTER DEPOSIT ::Rs  "<<deposit;
  }
                void dispdata()
   {
                                 int scrnt=0;
                     if(scrnt==1)
    {
      clrscr();
                   cout<<"DISPLAY ALL MENU 
 ";
    scrnt=0;
  }
                    cout<<"

ACCOUNT NUMBER              ::";
                    cout<<accountno;
                    cout<<"

NAME OF DEPOSITER             ::";
                    cout<<name;
                    cout<<"

TYPE OF ACCOUNT SAVING(s)/CURRENT(c)  ::  ";
                    cout<<type;
                    cout<<"

BALANCE  ::Rs  ";
                    cout<<deposit;
    scrnt++;
     }
  };
                void main()
    {
                                 int menuch;
                                       punit();
                 do
    {
                    clrscr();
                    textcolor(14);
                    textbackground(1);
                   cout<<"


					MAIN MENU 
";
                   cout<<"
		1.NEW ACCOUNT     ";
                   cout<<"
		2.CLOSE AN ACCOUNT ";
                   cout<<"
		3.MODIFY AN ACCOUNT  ";
                   cout<<"
		4.DISPLAY AN ACCOUNT ";
                   cout<<"
		5.DISPLAY ALL RECORDS ";
                   cout<<"
		6.WITHDRAW AMOUNT";
                   cout<<"
		7.DEPOSIT AMOUNT";
                   cout<<"
		8.EXIT     ";
                   cout<<"
		ENTER YOUR CHOICE  ";
      cin>>menuch;

                                 switch(menuch)
    {

                   case 1:addrecord();break;
                   case 2:delrecord();break;
                   case 3:modrecord();break;
                   case 4:disprecord();break;
                   case 5:dispall();break;
                   case 6:withdraw();break;
                   case 7:deposit();break;
     }
  }
                 while(menuch!=8);
     }
                  void addrecord()
  {
                                     account obj_1,obj_2;
                                  fstream fout;
                   fout.open("banking.txt",ios::in|ios::binary);
     if(!fout)
  {
                   cout<<"FILE OPEN ERROR  ";getch();return;}
                int recsize=sizeof(account);
                    fout.seekg(0,ios::end);
                  fout.seekg(-1*recsize,ios::cur);
                 fout.read((char*)&obj_1,recsize);
    int mrno=obj_1.giveaccountno();
                fout.close();
    clrscr();
                   cout<<"ADD MENU   

";
     obj_2.getdata(mrno);
                  fout.open("banking.txt",ios::app|ios::binary);
     if(!fout)
   {
                    cout<<"FILE OPEN ERROR  ";getch();return;}
      fout.write((char*)&obj_2,recsize);
                    cout<<"

RECORD ADDED TO DATABASE"<<"
 Press any key to
continue... ";
      getch();
                 fout.close();
   }
                void dispall()
  {
                                  account obj_3;
                    fstream fout;
                  int recsize=sizeof(account);
                   int countrec=0;
                clrscr();
                    cout<<"
DISPLAY ALL MENU 
 ";
    fout.open("banking.txt",ios::in);
                if(!fout)
  {
                    cout<<"FILE OPEN ERROR  ";getch();return;}
                while(fout.read((char*)&obj_3,recsize))
  {
                   obj_3.dispdata();
     countrec++;
                    cout<<"
 PRESS ANY KEY FOR NEXT....";
     getch();
  }
                  clrscr();
                   cout<<"

END OF FILE.TOTALNUMBER OF RECORDS..."<<countrec;
                   cout<<"

Press any key......";
    getch();
      fout.close();}
                void disprecord()
 {
                                   account obj_4;
                   fstream fout;
                     int mrno,flag=0;
                    int recsize=sizeof(account);
    clrscr();
                   cout<<"
 DISPLAY A RECORD MENU  
";
    fout.open("banking.txt",ios::in);
                    if(!fout)
   {
                   cout<<"FILE OPEN ERROR  ";getch();return;}
                   cout<<"

 ENTER  THE ACCOUNT NUMBER  ";cin>>mrno;
     while(fout.read((char*)&obj_4,recsize))
 {
     if (obj_4.giveaccountno()==mrno)
{
                   obj_4.dispdata();
                    cout<<"

Press any key.....";
     flag=1;break;
  }
 }
     if(flag==0)
  {
                   cout<<"

NO SUCH ACCOUNT EXIST  ";
     cout<<"

Press any key......";
  }
                getch();
    fout.close();
 }
                void delrecord()
  {
                                    account obj_5;
                                 fstream fout,temp;
                  int mrno,flag;
                   int recsize=sizeof(account);
     clrscr();
                   cout<<"

         CLOSE ACCOUNT MENU   
 ";
     fout.open("banking.txt",ios::in);
                 if(!fout)
 {
                   cout<<"FILE OPEN ERROR  ";
                    getch();
                   return;
    }
      temp.open("temp.txt",ios::app|ios::binary);
    if(!temp)
 {
                    cout<<"FILE OPEN ERROR  ";
                getch();
     return;
  }
                    cout<<"

 ENTER THE ACCOUNT NUMBER ";
                cin>>mrno;
                  while(fout.read((char*)&obj_5,recsize))
   {
                 if(obj_5.giveaccountno()==mrno)
 {
                   obj_5.dispdata();
                char confirm;
                    cout<<"

ARE YOU SURE TO DELETE IT(Y/N)..";cin>>confirm;
      if(confirm=='Y'||confirm=='y')
 {
                   fout.read((char*)&obj_5,recsize);
                  cout<<"

RECORD DELETED FORM DATABASE
";
                  cout<<"press any key....";
                      flag=1;
                                 if(!fout)
                 break;
      }
                    flag=1;
     }
   temp.write((char*)&obj_5,recsize);}
                 fout.close();
    temp.close();
                    remove("banking.txt");
                  rename("temp.txt","banking.txt");
                    if(flag==0)
 {
                   cout<<"

NO SUCH ACCOUNT EXIST";
                   cout<<"Press any key.....";
  }
     getch();
 }
                 void modrecord()
  {
    account obj_6;
                fstream fout;
                  int mrno,flag=0;
                  int recsize=sizeof(account);
    clrscr();
                    cout<<"
MODIFY RECORD MENU
 ";
    fout.open("banking.txt",ios::in|ios::out|ios::binary);
     if(!fout)
 {
                   cout<<"FILE OPEN ERROR  ";
                   getch();
                    return;
                   }
     fout.seekg(ios::beg);
                   cout<<"
ENTER RECORD NUMBER  ";
                    cin>>mrno;
      while(fout.read((char*)&obj_6,recsize))
  {
                  if(obj_6.giveaccountno()==mrno)
  {
                clrscr();
                  cout<<"

MODIFY MENU 

";
                      obj_6.dispdata();
      int tmprno=obj_6.giveaccountno()-1;
                      account obj_7;
                   cout<<"

 ENTER NEW DATA
";
                     obj_7.getdata(tmprno);
                  char confirm;
      cout<<"

 ARE YOU SURE(Y/N)  
";
                cin>>confirm;
     if(confirm=='Y'||confirm=='y')
 {
                                  fout.seekg(-1*recsize,ios::cur);
                       fout.write((char*)&obj_7,recsize);
                   cout<<"

 RECORD MODIFIED
  ";
                  cout<<"Press any key.....";
                                    flag=1;
  }
     }
                  if(flag==0)
 {
                                 cout<<"NO SUCH RECORD EXIST
";
                       cout<<"Press any key.....";
   }
      }
                                 fout.close();
                    getch();
    }
                 void withdraw()
    {
                     account obj_9;
                fstream fout;
    int mrno=0;
  int recsize=sizeof(account);
                   clrscr();
                       cout<<"

WITHDRAWAL MENU
";
                  fout.open("banking.txt",ios::in|ios::out|ios::binary);
                                  if(!fout)
     {
                   cout<<"FILE OPEN ERROR  ";getch();return;}
                       fout.seekg(ios::beg);
                   cout<<"
ENTER ACCOUNT NUMBER  ";
      cin>>mrno;
                      while(fout.read((char*)&obj_9,recsize))
 {
                    if(obj_9.giveaccountno()==mrno)
      {
                 clrscr();
                 cout<<"

ENTER THE AMOUNT TO BE WITHDRAWED::Rs ";
    cin>>w;
                    obj_9.withdrawal(w);
                                  fout.seekg(-1*recsize,ios::cur);
                   fout.write((char*)&obj_9,recsize);
  }
    }
                  fout.close();
                      getch();
  }
                void punit(void)
  {

    int gd=5, gm, errorcode;
    int col,i=0,j;
                initgraph(&gd, &gm, "c:\tc\bgi");
      while(5*i<=700)
  {
                 setbkcolor(1);
                 setcolor(3);
                 rectangle(0+5*i,0+5*i,getmaxx()-5*i,getmaxy()-5*i);
                 i++;
  }
    i=0;
     setcolor(4);
   settextstyle(1,0,6);

     sleep(5);
      cleardevice();
                  while(5*i<=700)
   {
                 setbkcolor(1);
     setcolor(3);
                 circle(getmaxx()/2,getmaxy()/2,i*5);
   i++;
     }
                   setcolor(4);
                 settextstyle(0,0,6);
     outtextxy(190 ,getmaxy()/2-85,"PROJECT");
                outtextxy(300,getmaxy()/2-25,"ON");

     outtextxy(190,getmaxy()/2+25,"BANKING");
                sleep(3);
     i=0;
                while(i<=130)
  {
                     setbkcolor(1);
                                  setcolor(3);
                 line(i*3,0,i*3,getmaxy());
                   line(getmaxx()-i*3,0,getmaxx()-i*3,getmaxy());
                  i++;
  }
                 sleep(1);
      i=getmaxy();
                  while(i>0)
   {
                line(getmaxx()/2,getmaxy(),getmaxx(),i-=10);
     delay(10);
   }
      i=getmaxx();
                  while(i>0)
   {
     line(getmaxx()/2,getmaxy(),i-=10,0);
      delay(10);
  }
      i=0;
     while(i<getmaxy())
 {
     line(getmaxx()/2,getmaxy(),0,i+=10);
    delay(10);
     }

                 closegraph();
     flushall();
 }

                    void deposit(void)
  {
                  account obj_10;
      fstream fout;
                 int mrno=0;
      int recsize=sizeof(account);
     clrscr();
                    cout<<"

DEPOSITAL MENU
";
                fout.open("banking.txt",ios::in|ios::out|ios::binary);
   if(!fout)
 {
                  cout<<"FILE OPEN ERROR  ";getch();return;}
     fout.seekg(ios::beg);
                  cout<<"
ENTER ACCOUNT NUMBER  ";
                cin>>mrno;
                  while(fout.read((char*)&obj_10,recsize))
  {
      if(obj_10.giveaccountno()==mrno)
  {
    clrscr();
     cout<<"

ENTER THE AMOUNT TO BE DEPOSITED ::Rs ";
   cin>>w;
      obj_10.deposital(w);
  fout.seekg(-1*recsize,ios::cur);
      fout.write((char*)&obj_10,recsize);
   }
     }
  fout.close();
     getch();
   }
Class for Library

# include<iostream.h>
# include<conio.h>
// Creating a basic template for book and magazine
class lib
{
	private:
		char title[20];
		char pub[20];
		unsigned int acc_no;
	public:
//method for getting inputs
		void get_details()
		{
		cout<<"Enter the book title"<<endl;
		cin>>title;
		cout<<"Enter the publisher name"<<endl;
		cin>>pub;
		cout<<"Enter the accession number"<<endl;
		cin>>acc_no;
		}
//method for showing output
		void show_details()
		{
		cout<<"Title : "<<title<<endl;
		cout<<"Publisher : "<<pub<<endl;
		cout<<"Accession No. : "<<acc_no<<endl;
		}
};
// Class Book derived from lib
class book :  private lib
{
private:
	char author[20];
public:
	void get_details()
	{
	lib::get_details();
	cout<<"Enter the author's name: "<<endl;
	cin>>author;
	}
	void show_details()
	{
	lib::show_details();
	cout<<"Autohr : "<<author<<endl;
	}
};
//Class for Magazine derived from lib
class magz :  private lib
{
private:
	char editor[20];
public:
	void get_details()
	{
	lib::get_details();
	cout<<"Enter the editor's name: "<<endl;
	cin>>editor;
	}
	void show_details()
	{
	lib::show_details();
	cout<<"editor : "<<editor<<endl;
	}
};
void main(void)
{
clrscr();
//creating objects
book b;
magz m;
b.get_details();
m.get_details();
b.show_details();
m.show_details();
getch();
}
Class for storing a Person's details

# include<iostream.h>
# include<string.h> // for strcpy
# include<conio.h>

class person
{
	char name[20];
	int yob; //Year of birth
	int yod; // Year of death
public:
	person()
	{       strcpy(name,"N.A.");
		yob=2000; yod=2000;
	}
	~person()
	{
		delete []name;
	}
	void getdata()
	{
		cout<<"

Enter the name : ";
		cin.getline(name,19);
		cout<<"
Enter the year of birth";
		cin>>yob;
		cout<<"
Enter the year of death";
		cin>>yod;
	}
	void print()
	{
		cout<<"

Name:"<<name;
		cout<<"
Year of Birth: "<<yob;
		cout<<"
Year of death: "<<yod;
	}
}; //end of the class
void main()
{
clrscr();
// demonstrating the working for single object
person p;
//getting the input
p.getdata();
//displaying the i/p data
p.print();
getch();
}
Class for storing residential addresses

# include<iostream.h>
# include<conio.h>
# include<string.h>

class address
{
char name[20];
char houseno[10];
char street[20];
char city[20];
long int pin;
public:
address()
{
	strcpy(name,"Unspecified");
	strcpy(houseno,"NA");
	strcpy(street,"NA");
	strcpy(city,"NA");
	pin=0;
}
void put_data()
{
cout<<"
Enter the name of the person";
cin.getline(name,19);
cout<<"
Enter the House number";
cin.getline(houseno,9);
cout<<"
Enter the street address";
cin.getline(street,19);
cout<<"
Enter the city";
cin.getline(city,19);
cout<<"
Enter the pin code";
cin>>pin;
}
void get_data()
{
cout<<"***********************************************"<<endl;
cout<<"NAME     : "<<name<<endl;
cout<<"HOUSE NO.: "<<houseno<<endl;
cout<<"STREET   : "<<street<<endl;
cout<<"CITY     : "<<city<<endl;
cout<<"PIN      : "<<pin<<endl;
cout<<"***********************************************";
}
};
void main()
{
clrscr();
address obj;
obj.put_data();
obj.get_data();
getch();
}
Class that imitates the functionality of the basic data type

# include<iostream.h>
#include<conio.h>
class Int
{
int var;
public :
	/* Here we try to overcome the problem of carbage value by
	   initializing the value by 0 */
	Int()
	 {
	  var =0;
	 }

	// Overloaded Constructor
	Int(int a )
	{
		var = a;
	}
	int add( Int b) // Note : Int , not int
	{
		var+=b.var; /* For ex. if the user enters
				a.add(b);
				then result will be
				a = a + b; */
		return(var);
	}
	void disp() //again, Int
	{
		cout<<var;
	}
};                   // Do not forget this ;
void main(void)
{
	clrscr();
	Int a = 12;
	Int b = 10;
	a.disp();
	cout<<"
 a+b = "<<a.add(b);
	getch();
}
Complete implementation of Publication Class

# include<iostream.h>
# include<conio.h>

class publication
{
	char title[30];
	float price;
public:
	void getdata()
	{
		cout<<"Enter the title :
 "; cin>>title;
		cout<<"Enter the price :
 "; cin>>price;
	}
	void putdata()
	{
		cout<<"The title is : "<<title<<endl;
		cout<<"Price is     : "<<price<<endl;
	}
};
class sales
{
	float s1,s2,s3; // getting the sale of last three momths
public:
	void getdata()
	{
		cout<<"Enter the sale of first month:
";
		cin>>s1;
		cout<<"Enter the sale of second month:
";
		cin>>s2;
		cout<<"Enter the sale of third month:
";
		cin>>s3;
	}
	void putdata()
	{
		cout<<"Sale in first month : $"<<s1<<endl;
		cout<<"Sale in sec.  month : $"<<s2<<endl;
		cout<<"Sale in third month : $"<<s3<<endl;
	}
};


class book: private publication, private sales
{
	int pages;
public:
	void getdata()
	{
		cout<<"      BOOK DETAILS 
";
		publication::getdata();
		sales::getdata();
		cout<<"Enter the number of pages 
";
		cin>>pages;
	}
	void putdata()
	{
		cout<<"      BOOK DETAILS
";
		publication::putdata();
		cout<<"Number of pages : " <<pages<<endl;
		sales::putdata();
	}
};
class tape: private publication,private sales
{
	float time;
public:
	void getdata()
	{
		cout<<"     TAPE DETAILS
";
		publication::getdata();
		sales::getdata();
		cout<<"Enter the time length of the casette"; cin>>time;
	}
	void putdata()
	{
		cout<<"      TAPE DETAILS ";
		publication::putdata();
		cout<<"Time length :"<< time<<endl;
		sales::putdata();
	}
};
void main()
{
book b;
tape t;
b.getdata();
t.getdata();
b.putdata();
t.putdata();
}
Complex Numbers Class with lot's of features

#include <math.h>
#include <iostream.h>
#include <iomanip.h>
#include <conio.h>

class complex
{
                private:
                                                     float real;                                                   // Real Part
           float imag;      //  Imaginary Part


  public:
         complex(float,float);
         complex(complex&);
         complex operator +(complex);
         complex operator -(complex);
         complex operator *(complex);
         complex operator /(complex);
         complex getconjugate();
         complex getreciprocal();
         float getmodulus();
         void setdata(float,float);
         void getdata();
         float getreal();
         float getimaginary();
         bool operator ==(complex);
         void operator =(complex);
         friend ostream& operator <<(ostream &s,complex &c);
};
//                                                                                                                                        CONSTRUCTOR
                                                     complex::complex(float r=0.0f,float im=0.0f)
           {
                            real=r;
              imag=im;
           }

//                                                                                             COPY CONSTRUCTOR
           complex::complex(complex &c)
           {
                            this->real=c.real;
              this->imag=c.imag;
           }


           void complex::operator =(complex c)
           {
              real=c.real;
              imag=c.imag;
           }


           complex complex::operator +(complex c)
           {
                            complex tmp;
              tmp.real=this->real+c.real;
              tmp.imag=this->imag+c.imag;
              return tmp;
           }

           complex complex::operator -(complex c)
           {
                            complex tmp;
              tmp.real=this->real - c.real;
              tmp.imag=this->imag - c.imag;
              return tmp;
           }

                                                                   complex complex::operator *(complex c)
           {
                            complex tmp;
              tmp.real=(real*c.real)-(imag*c.imag);
              tmp.imag=(real*c.imag)-(imag*c.real);
              return tmp;
           }

           complex complex::operator /(complex c)
           {
                            float div=(c.real*c.real) + (c.imag*c.imag);
              complex tmp;
              tmp.real=(real*c.real)+(imag*c.imag);
              tmp.real/=div;
              tmp.imag=(imag*c.real)-(real*c.imag);
              tmp.imag/=div;
              return tmp;
           }

           complex complex::getconjugate()
           {
                            complex tmp;
              tmp.real=this->real;
              tmp.imag=this->imag * -1;
              return tmp;
           }

           complex complex::getreciprocal()
           {
                            complex t;
              t.real=real;
              t.imag=imag * -1;
              float div;
              div=(real*real)+(imag*imag);
              t.real/=div;
              t.imag/=div;
              return t;
           }

           float complex::getmodulus()
           {
                            float z;
              z=(real*real)+(imag*imag);
              z=sqrt(z);
              return z;
           }

           void complex::setdata(float r,float i)
           {
                            real=r;
              imag=i;
           }

           void complex::getdata()
           {
                            cout<<"Enter Real:";
              cin>>this->real;
              cout<<"Enter Imaginary:";
              cin>>this->imag;

           }

           float complex::getreal()
           {
                            return real;
           }

           float complex::getimaginary()
           {
                            return imag;
           }

           bool complex::operator ==(complex c)
           {
            return (real==c.real)&&(imag==c.imag) ? 1 : 0;
            }

                         ostream& operator <<(ostream &s,complex &c)
           {
                            s<<"Real Part = "<<c.real<<endl
               <<"Imaginary Part = "<<c.imag<<endl;
              s<<"z = "<<c.real<<setiosflags(ios::showpos)
               <<c.imag<<"i"<<endl<<resetiosflags(ios::showpos);
               return s;
           }



void main()
{
                complex a(10.0f,-2.f); // Calls Constructor
  cout<<a<<endl;               // Calls the overloaded << operator
  complex b(-2);         // Calls Constructor
  complex c=b;                                                                    // Calls Copy Constructor
  c=a;                                                                                                                       // calls overloaded = operator
  b.getdata();                                                                    // Calls Getdata()
  c.getdata();
  if(b==c)            // calls overloaded == operator
     cout<<"b == c";
     else
     cout<<"b != c";


  cout<<endl<<c.getmodulus()<<endl; // calls getmodulus function()
  complex d;
  d=a+b;   // Calls overloaded +
  cout<<d<<endl;
  d=a-b;                 // Calls overloaded -
  cout<<d<<endl;
  d=a*b;        // calls overloaded *
  cout<<d<<endl;
  d=a/b;        // calls overloaded /
  cout<<d<<endl;

  getch();
} 
Convert a number into words

#include <conio.h>    // For getch() function only
#include <iostream>
using namespace std;


void numword1(int);
void numword2(int);

int main()
{
long unsigned int number,temp;
int mult,i,digit,digits,last_two,hundred,thousand,lakh,crore;
digits=last_two=hundred=thousand=lakh=crore=0;

cout<<"Enter a number(lesser than 99,99,99,999)
";
cin>>number;

if(number>999999999)
{
 cout<<"Number out of range!";
 getch();
 exit(0);
}

if(number==0)
{
 cout<<"Zero";
 getch();
 exit(0);
}

temp=number;

digit=number%10;                    // Extracting last two digts
last_two=digit;
number=number/10;
digit=number%10;
last_two=(digit*10)+last_two;

 number=number/10;                  // Extract hundreds
 digit=number%10;
 hundred=digit;

 number=number/10;                  // Extract thousands
 digit=number%10;
 thousand=digit;
 number=number/10;
 digit=number%10;
 thousand=(digit*10)+thousand;

 number=number/10;                // Extract lakhs
 digit=number%10;
 lakh=digit;
 number=number/10;
 digit=number%10;
 lakh=(digit*10)+lakh;

 number=number/10;              // Extract crores
 digit=number%10;
 crore=digit;
 number=number/10;
 digit=number%10;
 crore=(digit*10)+crore;



while(temp!=0)                // Calculate number of digits in the number
{
 temp=temp/10;
 digits++;
}

cout<<"The number in words is:
";

            // Printing the number in words

if(digits>=8)
{
 numword2(crore);
 cout<<"crores ";
}
if(digits>=6)
{
 if(lakh!=0)
 {
 numword2(lakh);
 cout<<"lakh ";
 }
}
if(digits>=4)
{
if(thousand!=0)
{
 numword2(thousand);
 cout<<"Thousand ";
}
}
if(digits>=3)
{
if(hundred!=0)
{
 numword2(hundred);
 cout<<"Hundred ";
}
}

numword2(last_two);

getch();
return 0;
}


void numword1(int num)
{
switch(num)
{
 case 0: break;

 case 1: cout<<"One ";
         break;
 case 2: cout<<"Two ";
         break;
 case 3: cout<<"Three ";
         break;
 case 4: cout<<"Four ";
         break;
 case 5: cout<<"Five ";
         break;
 case 6: cout<<"Six ";
         break;
 case 7: cout<<"Seven ";
         break;
 case 8: cout<<"Eight ";
         break;
 case 9: cout<<"Nine ";
         break;
 case 10: cout<<"Ten ";
         break;
 case 11: cout<<"Eleven ";
         break;
 case 12: cout<<"Twelve ";
         break;
 case 13: cout<<"Thirteen ";
         break;
 case 14: cout<<"Fourteen ";
         break;
 case 15: cout<<"Fifteen ";
         break;
 case 16: cout<<"Sixteen ";
         break;
 case 17: cout<<"Seventeen ";
         break;
 case 18: cout<<"Eighteen ";
         break;
 case 19: cout<<"Nineteen ";
         break;
}
return;
}

void numword2(int num)
{
if(num>=90)
{
 cout<<"Ninety ";
 numword1(num-90);
}
else if(num>=80)
{
 cout<<"Eighty ";
 numword1(num-80);
}
else if(num>=70)
{
 cout<<"Seventy ";
 numword1(num-70);
}
else if(num>=60)
{
 cout<<"Sixty ";
 numword1(num-60);
}
else if(num>=50)
{
 cout<<"Fifty ";
 numword1(num-50);
}
else if(num>=40)
{
 cout<<"Fourty ";
 numword1(num-40);
}
else if(num>=30)
{
 cout<<"Thirty ";
 numword1(num-30);
}
else if(num>=20)
{
 cout<<"Twenty ";
 numword1(num-20);
}
else
   numword1(num);

return;
}
Extension of publication class

# include<iostream.h>
# include<conio.h>

class publication
{
	char title[30];
	float price;
public:
	void getdata()
	{
		cout<<"Enter the title :
 "; cin>>title;
		cout<<"Enter the price :
 "; cin>>price;
	}
	void putdata()
	{
		cout<<"The title is : "<<title<<endl;
		cout<<"Price is     : "<<price<<endl;
	}
};
class book: private publication
{
	int pages;
public:
	void getdata()
	{
		cout<<"      BOOK DETAILS 
";
		publication::getdata();
		cout<<"Enter the number of pages 
";
		cin>>pages;
	}
	void putdata()
	{
		cout<<"      BOOK DETAILS
";
		publication::putdata();
		cout<<"Number of pages : " <<pages<<endl;
	}
};
class tape: private publication
{
	float time;
public:
	void getdata()
	{
		cout<<"     TAPE DETAILS
";
		publication::getdata();
		cout<<"Enter the time length of the casette"; cin>>time;
	}
	void putdata()
	{
		cout<<"      TAPE DETAILS ";
		publication::putdata();
		cout<<"Time length :"<< time<<endl;
	}
};
void main()
{
book b;
tape t;
b.getdata();
t.getdata();
b.putdata();
t.putdata();
}
Forever Calender in C++

#include<iostream.h>
#include<conio.h>

int step1 (int);
void month_name(int);
int no_days(int,int);
int leap(int);

void main()
{
 restart:
 clrscr();
 cout<<"Enter year : ";
 unsigned int y,m;
 cin>>y;
 int x;
 x=step1(y);
 int month[14][12]= {1,4,4,7,2,5,7,3,6,1,4,6,
		     2,5,5,1,3,6,1,4,7,2,5,7,
		     3,6,6,2,4,7,2,5,1,3,6,1,
		     4,7,7,3,5,1,3,6,2,4,7,2,
		     5,1,1,4,6,2,4,7,3,5,1,3,
		     6,2,2,5,7,3,5,1,4,6,2,4,
		     7,3,3,6,1,4,6,2,5,7,3,5,
		     1,4,5,1,3,6,1,4,7,2,5,7,
		     2,5,6,2,4,7,2,5,1,3,6,1,
		     3,6,7,3,5,1,3,6,2,4,7,2,
		     4,7,1,4,6,2,4,7,3,5,1,3,
		     5,1,2,5,7,3,5,1,4,6,2,4,
		     6,2,3,6,1,4,6,2,5,7,3,5,
		     7,3,4,7,2,5,7,3,6,1,4,6};
 cout<<"Enter month (1 - 12) : ";
 month_input:
 cin>>m;
 if(m<1 || m>12)
 {
  cout<<"Enter a valid month (1 - 12) : ";
  goto month_input;
 }
 cout<<"

		";
 month_name(m);
 cout<<' '<<y<<"

Mon	Tue	Wed	Thu	Fri	Sat	Sun
";
 int j=month[x-1][m-1], days=no_days(m,y);
 for (int i=0; i<j-1; i++)
  cout<<'	';
 for(i=1; i<=days; i++)
 {
  cout<<i<<'	';
  if(j==7)
  {
   cout<<'
';
   j=1;
  }
  else
   j++;
 }
 cout<<"

Try for another month? (y/n) : ";
 char ch;
 cin>>ch;
 if(ch=='y' || ch=='Y')
  goto restart;
}
int step1 (int y)
{
 int x=y%7;
 x+=(y-1)/4;
 x-=(y-1)/100;
 x+=(y-1)/400;
 x=x%7;
 if(x==0)
  x=7;
 if(leap(y))
  x+=7;
 return x;
}
void month_name(int m)
{
 switch(m)
 {
  case 1 : cout<<"January";
	break;
  case 2 : cout<<"February";
	break;
  case 3 : cout<<"March";
	break;
  case 4 : cout<<"April";
	break;
  case 5 : cout<<"May";
	break;
  case 6 : cout<<"June";
	break;
  case 7 : cout<<"July";
	break;
  case 8 : cout<<"August";
	break;
  case 9 : cout<<"September";
	break;
  case 10: cout<<"October";
	break;
  case 11: cout<<"November";
	break;
  case 12: cout<<"December";
	break;
 }
}

int no_days(int mon, int y)
{
 int d;
 switch(mon)
 {
  case 1 :
  case 3 :
  case 5 :
  case 7 :
  case 8 :
  case 10:
  case 12: d=31;
	   break;
  case 4 :
  case 6 :
  case 9 :
  case 11: d=30;
	   break;
  case 2 : if(leap(y))
	    d=29;
	   else
	    d=28;
	   break;
 }
 return d;
}
int leap (int y)
{
 if (y%100==0)
  if (y%400==0)
   return 1;
  else
   return 0;
 else
  if (y%4==0)
   return 1;
  else
   return 0;
}
Game of Bollywood

# include<iostream.h>
# include<stdio.h>
# include<conio.h>
# include<string.h>
# include<dos.h>
# include<process.h>
static int cnt=0;
void main()
{
		 clrscr();
		 char film[150],ch,film2[150];
		 int choi,len,res=0,dig=0,j,count=0,len1,flag=1,p;
		 cout<<"Enter 1 For HOLLYWOOD & 2 For BOLLYWOOD ";
		 cin>>choi;
		 cout<<"
ENTER THE NAME OF THE FILM
";
		 gets(film);
		 len=strlen(film);
		 len1=len;
		 clrscr();
		 flushall();
		 gotoxy(15,10);
		 if(choi==1)
		 		 cout<<"HOLLYWOOD
";
		 else
		 		 cout<<"BOLLYWOOD
";
		 for(int i=0;i<len1;i++)
		 {
		 		 gotoxy(15+i,12);
		 		 switch(film[i])
		 		 {
		 		 		 case 'a':cout<<"a";len--;film2[cnt]='a';cnt++;break;
		 		 		 case 'e':cout<<"e";len--;film2[cnt]='e';cnt++;break;
		 		 		 case 'i':cout<<"i";len--;film2[cnt]='i';cnt++;break;
		 		 		 case 'o':cout<<"o";len--;film2[cnt]='o';cnt++;break;
		 		 		 case 'u':cout<<"u";len--;film2[cnt]='u';cnt++;break;
		 		 		 case '.':cout<<".";len--;break;
		 		 		 case ' ':cout<<" ";len--;break;
		 		 		 default:cout<<"_";
		 		 }
		 }
		 gotoxy(15,15);
		 cout<<"Now Guess The Film ";
		 while(flag==1)
		 {
		 		 p=0;
		 		 dig=0;
		 		 gotoxy(37,15);
		 		 cin>>ch;
		 		 film2[cnt]=ch;
		 		 if(cnt>=1)
		 		 {
		 		 		 for(int k=0;k<cnt;k++)
		 		 		 {
		 		 		 		 if(film2[k]==ch)
		 		 		 		 p=1;
		 		 		 }
		 		 }
		 		 cnt++;
		 		 for(j=0;j<len1;j++)
		 		 {
		 		 		 if(film[j]==ch)
		 		 		 {
		 		 		 		 dig++;
		 		 		 		 count++;
		 		 		 		 if(p==1)
		 		 		 		 {
		 		 		 		 		 count--;
		 		 		 		 }
		 		 		 		 gotoxy((15+j),12);
		 		 		 		 cout<<ch;
		 		 		 		 if(count==len)
		 		 		 		 {
		 		 		 		 		 gotoxy(15,17);
		 		 		 		 		 cout<<"CONGRATS YOU WON! BY "<<(9-res)<<" POINTS";
		 		 		 		 		 getch();
		 		 		 		 		 exit(0);
		 		 		 		 }
		 		 		 }
		 		 }
		 		 if(dig==0)
		 		 {
		 		 		  if(p==1)
		 		 		  {res--;}
		 		 		  gotoxy((15+res),10);
		 		 		  cout<<ch;
		 		 		  res++;
		 		 		   if(res==9)
		 		 		   {
		 		 		 		 flag=0;
		 		 		 		 gotoxy(15,17);
		 		 		 		 cout<<"SORRY YOU LOST THE NAME OF FILM WAS "<<film;
		 		 		 		  getch();
		 		 		   }
		 		 }
		 }
}
Generating N Random Numbers between two specified numbers

#include<iostream.h>
#include<conio.h>
#include<stdlib.h>
#include<time.h>
void main()
{
clrscr();
int min,max,i,range,r,x;
unsigned first = time(NULL);
cout<<"FIRST = " << first <<endl;
srand(first);
cout<<"ENTER THE MINIMUM NUMBER :";
cin>>min;
cout<<"ENTER THE MAXIMUM NUMBER :";
cin>>max;
cout<<"ENTER THE NO.OF TERMS YOU WANT :";
cin>>x;
range=max-min+1;
for(i=0;i<x;i++)
	{
	r=rand()/100%range+min;
	cout<<r<<" ";
	}
getch();
}
Implementing Queue as a Class

# include<iostream.h>
# include<conio.h>
# define SIZE 20

class queue
{
	int a[SIZE];
	int front;
	int rear;
public:
	queue();
	~queue();
	void insert(int i);
	int remove();
	int isempty();
	int isfull();
};

queue::queue()
{
front=0;
rear=0;
}
queue::~queue()
{
delete []a;
}
void queue::insert(int i)
{
if(isfull())
{
	cout<<"

******
Queue is FULL !!!
No insertion allowed further.
******
";
	return;
}
a[rear] = i;
rear++;
}
int queue::remove()
{
if(isempty())
{
	cout<<"

******
Queue Empty !!!
Value returned will be garbage.
******
";
	return (-9999);
}

return(a[front++]);
}
int queue::isempty()
{
if(front == rear)
	return 1;
else
	return 0;
}
int queue::isfull()
{
if(rear == SIZE)
	return 1;
else
	return 0;
}

void main()
{
clrscr();
queue q;
q.insert(1);
q.insert(2);
cout<<"
"<<q.remove();
cout<<"
"<<q.remove();
cout<<"
"<<q.remove();
getch();
}
Implementing Stack using Class (with constructor etc).

# include<iostream.h>
# include<conio.h>
# define SIZE 20

class stack
{
int a[SIZE];
int tos; // Top of Stack
public:
	stack();
	void push(int);
	int pop();
	int isempty();
	int isfull();
};
stack::stack()
{
tos=0; //Initialize Top of Stack
}

int stack::isempty()
{
return (tos==0?1:0);
}
int stack::isfull()
{
return (tos==SIZE?1:0);
}

void stack::push(int i)
{

if(!isfull())
{
cout<<"Pushing "<<i<<endl;
a[tos]=i;
tos++;
}
else
{
 cerr<<"Stack overflow error !
Possible Data Loss !";
}
}
int stack::pop()
{
if(!isempty())
{
cout<<"Popping "<<a[tos-1]<<endl;
return(a[--tos]);
}
else
{
cerr<<"Stack is empty! What to pop...!";
}
return 0;
}

void reverse(stack s)
{
stack s2;
while(!s.isempty())
{
	s2.push(s.pop());
}
cout<<"Reversed contents of the stack..."<<endl;
while(!s2.isempty())
{
	cout<<s2.pop()<<endl;
}
}//end of fn.
void main()
{
clrscr();
stack s;

s.push(1);
s.push(2);
s.push(3);

reverse(s);
getch();
}
Implimentation of a list using a linked list with pointers

#include <iostream.h>
struct element {
  int number;
  element *next;
  };

/* the operators declared on the type list.*/
void read(element *&list);
void write(element *list);
int length(element *list);
int position(element *list, int num);
void remove(element *&list,int position);
void insert(element *&list,int new_num,int position);
element *ele(element *list,int position);

void add(int new_num,element *&list,element *this_el);

void main()
{

  element *list,*p,*q;
  int leng;

  read(list);
  write(list);
  q = ele (list,3);
  add (5,list,q);
  write(list);
  insert(list,10,2);
  write(list);
  remove(list,4);
  write(list);
  insert(list,12,1);
  write(list);
  leng = position(list,10);
  cout<< " pos of 10 is " << leng <<endl;
  cout<< " The length of the list is: " << length(list)<<endl;
  cout<<endl;
  ]
}
/* reading a list from input */
void read(element *&list)
{
  element *p,*last;
  list = new element;
  p = list;
  cout<< " enter a number";
  cin>>p->number;
  while (!cin.eof())
  {
    p->next = new element;
    last = p;
    p = p->next;
    cout<< " enter a number ";
    cin>>p->number;
 }
   delete (p);
   last->next = NULL;
}

/* writing a list on the output */
void write(element *list)
{
  element *p;
  cout<<endl;
  p = list;
  while (p!=NULL)
  {
    cout<< p->number<<"	";
    p=p->next;
  }
  cout<<endl;
}

/* Gets a list and returns its length */
int length (element *list)
{
   element *p;
   int count=0;
   p=list;
   while (p!=NULL)
   {
     count++;
     p = p->next;
   }
   return count;
}

/*Gets an element and returns its positon in the list. If the element*/
/*is not in the list, returns 0 */

int position(element *list,int num)
{
  element *p;
  int i=1;
  for (p=list;p!=NULL;p=p->next)
  {
    if ((p->number)==num)
    return i;
    i++;
  }
  return 0;
}

/*Gets a number and removes the element that stays in this position */
void remove(element *&list,int position)
{
  element *before,*p;
  if (position==1)
  {
    before=list;
    list = list->next;
    delete (before);
  }
  else
  {
    before = ele (list,position-1);
    if (before!=NULL)
    {
      p = before->next;
      before->next = p->next;
      delete (p);
    }
  }
}

/* Insert a new element to be the i-th element of the list */
/* the function uses the function add*/
void insert(element *&list,int new_num,int position)
{
  element *p;
  if (position==1)
  add(new_num,list,NULL);
  else
  {
    p = ele(list,position-1);
    add(new_num,list,p);
  }
}

/* Gets a position in the list and returns a pointer to the element*/
/* in this position*/
element *ele(element *list,int position)
{
  element *p=list;
  int i;
  for (i=1;i<position;i++)
  {
     if (p==NULL)
     return p;
     p=p->next;
  }
  return p;
}

/* Add a new element after a given element.If the given element is NULL*/
/* Add the new element to be the first element*/
void add(int new_num,element *&list,element *this_el)
{
  element *p;
  if (list==NULL)
  {
    list = new element;
    list->number = new_num;
    list->next = NULL;
  }
  else
  {
    p = new element;
    p->number = new_num;
    if (this_el==NULL)
    {
     p->next = list;
     list = p;
    }
    else
    {
      p->next=this_el->next;
      this_el->next = p;
    }
  }
}
Misc. Programs In C++

//This is a program for copy desired file.
//You can use this program as garbage with ur program.

#include <iostream.h>
#include <fstream.h>
#include <process.h>
#include <conio.h>
void main()
{
   ifstream infile;
   ofstream outfile;
   ofstream printer;
   char filename[20];
   cout<<"
Enter the desired file to copy.";
   cin>>filename;
   infile.open(filename,ios::nocreate);
   if(!infile)
   {
      cout<<"Input file can not be opened."<<endl;
      exit(1);
   }
   outfile.open("copy");
   if(!outfile)
   {
      cout<<"Output file can not be opened.";
      exit(1);
   }
   printer.open("PRN");
   if(!printer)
      {
         cout<<"There is a problem with printer.";
         getch();
         exit(1);
      }
   cout<<"All files have been opened.";
   char ch;
   outfile<<"This is the begining of the file.";
   while(infile.get(ch))
   {
      outfile.put(ch);
   }
   infile.close();
   outfile.close();
   getch();
}

// This is How a Header file is creatred and used.

#include <iostream.h>
#include <string.h>
class college
{
   private:
          char collegename[80];
   public:
      college()
      {
         strcpy(collegename,"XXX");
      }
      char * getcollegename()
      {
         return collegename;
      }
};
class student:public college
{
   private:
      char studname[40];
      char address[80];
   public:
      student(char *name)
      {
         strcpy(studname,name);
      }
      char * studentname()
      {
         return studname;
      }
      setaddress(char *add)
      {
         strcpy(address,add);
      }
      char * studentaddress()
      {
         return address;
      }
};


#include <d:cppcollege.h>
#include <conio.h>
void main()
{
   clrscr();
   studentfile student;
   student.studentname("XXX");
   getch();
};


#include <iostream.h>
#include <conio.h>
#include <stdarg.h>
//Declare a function with one required parameter
void display(int number,...);
void main()
{
   int index=5;
   int one=1,two=2;
   clrscr();
   display(one,index);
   getch();
}
void display(int number,...)
{
   va_list para;
   va_start(para,number);
   cout<<"The parameters are:"<<endl;
   cout<<va_arg(para,int)<<" ";//extract a parameter
}


#include<stdio.h>
#include<conio.h>
void main()
  {
    clrscr();
    printf("%d
%d",sizeof(NULL),sizeof(""));
    getch();
  }

#include<stdio.h>
#include<conio.h>
void main()
 {
  int a=10,b=20;
  clrscr();
  swapv(&a,&b);
  printf("
 A=%d",a);
  printf("
 B=%d",b);
  getch();
 }

 swapv(int *x,int *y)
  {
   int t;
   t=*x;
   *x=*y;
   *y=t;
   return;
  }


/* This is the program using pointer to swap values */

#include<stdio.h>
#include<conio.h>
void main()
 {
  int a=10,b=20;
  clrscr();
  nilesh(a,b);
  printf("
 A=%d",a);
  printf("
 B=%d",b);
  getch();
 }

  nilesh(x,y)
  {
   int t;
   t=x;
   x=y;
   y=t;
   printf("
 X=%d",x);
   printf("
 Y=%d",y);
   return;
  }
Modification of previous program to handle 10 customers

# include<iostream.h>
# include<conio.h>
# include<iomanip.h>

class bank
	{
	char name[20];
	int acno;
	char actype[4];
	float balance;
	public:
	void init();
	void deposit();
	void withdraw();
	void disp_det();
	};
// member functions
void bank :: init()
{
cout<<"

		New Account
";
cout<<"

Enter the Name of the depositor : ";
cin.get(name,19,'
');
cout<<"
Enter the Account Number : ";
cin>>acno;
cout<<"
Enter the Account Type : (CURR/SAVG/FD/RD/DMAT) ";
cin>>actype;
cout<<"
Enter the Amount to Deposit : ";
cin >>balance;
}
void bank :: deposit()
{
float more;
cout <<"
		Depositing
";
cout<<"

Enter the amount to deposit : ";
cin>>more;
balance+=more;
}
void bank :: withdraw()
{
float amt;
cout<<"
		Withdrwal
";
cout<<"

Enter the amount to withdraw : ";
cin>>amt;
balance-=amt;
}
void bank :: disp_det()
{
cout<<"

		Account Details

";
cout<<"Name of the depositor : "<<name<<endl;
cout<<"Account Number        : "<<acno<<endl;
cout<<"Account Type          : "<<actype<<endl;
cout<<"Balance               : $"<<balance<<endl;
}

void main(void)
{
clrscr();
bank obj[9]; //declaring an array of objects
int choice  =1;
int num = 0;
// user must enter 0 to exit
while (choice != 0 )
{
cout<<"

		Choose the customer ID between 0 and 9 : ";
cin >> num;
cout<<"

Enter 0 to exit
	1. Initialize a new acc.
	2. Deposit
	3.Withdraw
	4.See A/c Status";
cin>>choice;
switch(choice)
{
	case 0 :
		cout<<"

		EXITING PROGRAM.";
		break;
	case 1 : obj[num].init();
		break;
	case 2: obj[num].deposit();
		break;
	case 3 : obj[num].withdraw();
		break;
	case 4: obj[num].disp_det();
		break;
	default: cout<<"

Illegal Option"<<endl;
}
}
getch();
}
Number Game in C++.

#include<iostream.h>
#include<conio.h>
void main()
{
int s,a,t,o,x=2,c,r,i;
char ch;
s=t=0,r=22,c=2;
clrscr();
cout<<"                          This is a computer Game.

########################

There are 22 balls on  a table,you can take
either a
 ";
cout<<"maximum of 4 balls or a minimum of 1 at a time.If you take
";
cout<<" the last ball from the table you will WIN other wise Computer
..
";
cout<<"
Either You or Coputer can Take First ,Enter yr choice
I(you)/C(computer)
";
cin>>ch;
if (ch=='I'|| ch=='i')
{
i=1,o=1;
s:
for (;i<17;i++)
{
cout<<"

You:";
cin>>a;
   switch(a)
  {
    case 1:
    r=r-a;
    s=s+a;
    cout<<"Remaining ="<<r;
    break;

    case 2:
    s=s+a;
    r=r-a;
    cout<<"Remainig ="<<r;
    if(i==1)
     { cout<<"

VIJOY:"<<o;
      r=r-o;
      s=s+o;
      cout<<"
Remaining ="<<r;
      i=2; goto s;
     }
    break;

    case 3:
    s=s+a;
    r=r-a;
    cout<<"Remainig ="<<r;
    break;

    case 4:
    s=s+a;
    r=r-a;
    cout<<"Remaining ="<<r;
    if(i==2)
    { cout<<"

VIJOY:"<<o;
     r=r-o;
     s=s+o;
     cout<<"
Remaining ="<<r;
     i=3;goto s;}

     if(i==3)
     { cout<<"

VIJOY:"<<2;
       r=r-2;
       s=s+2;
       cout<<"
Remaining ="<<r;
       i=4;goto s;}
    break;
  default:
  cout<<"Wrong Withdrawl......
";
  cout<<"Exitting...";goto e;
   }

 j:
if(s<c)
 {
t=c-s;
  s=s+t;
  r=r-t;
  if(t==5)
   {cout<<"

Since I Have To WIN I Am Taking 5 Balls...";
    cout<<"
VIJOY:"<<t;
    cout<<"
Remainig ="<<r;
    cout<<"

Anyway Congrats To You
";
     goto e;}
  cout<<"

VIJOY:"<<t;
  cout<<"
Remainig ="<<r;

  if(r==0)
   {cout<<"

You Lost The Game........!!!! 
Think again....
";
    goto e;}

  c=c+5;
  i=5;
 }
  else
 { c=c+5;goto j;}
}
}
else
{
cout<<"
Coputer:"<<x;
r=r-x;
cout<<"
Remainig ="<<r;
s=s+x;
i=5;
goto s;
}
e:
getch();
clrscr();


for(i=1;i<20;i++)
cout<<"a";
getch();
}
Program for Overloading the difference operator for complex arithmetic

#include<iostream.h>
#include<conio.h>

class complex
{
float real;
float img;
public:
	complex()
	{
	real = 0; img = 0;
	}
	complex(float a,float b)
	{
	real  =a ; img = b;
	}
	complex operator -(complex );
	void disp();
};
// Fn.for overloading of - operator for complex arithmetic
complex complex::operator-(complex a)
{
	return complex(real-a.real,img-a.img);
}
// function for display of Real & Imaginary Parts
void complex::disp()
{
cout<<"
The real part is : "<<real;
cout<<"
The imaginary part is: "<<img;
}
void main(void)
{
complex c1(12.0,4.5),c2(8,6),c3;
cout<<"
The value of c1 is:
";
c1.disp();
cout<<"
The value of c2 is:
";
c2.disp();
cout<<"
The value of c3 is:
";
c3.disp();
c3=c1-c2;
cout<<"

After c3=c1-c2, c3 is : 
";
c3.disp();
getch();
}
Program for rotation of a string

:#include<stdio.h>
#include<conio.h>
#include<string.h>
void main()
{
                clrscr();
                char name[40],bubble,temp[40];
                int loop,size,count;
                printf("

		Enter the word ");
                scanf("%s",name);
                printf("

		");
                for(loop=0;loop<strlen(name);loop++)
                {
                                 temp[loop]=name[loop];
                                 printf("%c",temp[loop]);
                }
                for(count=1;count<strlen(name);count++)
                {
                                 for(loop=0;loop<(strlen(name));loop++)
                                 {
                                                  if(loop==0)
                                                                   bubble=temp[0];
                                                  temp[loop]=temp[loop+1];
                                                  temp[strlen(name)]=bubble;
                                 }
                                 printf("

		");
                                 for(loop=0;loop<(strlen(name));loop++)
                                                  printf("%c",temp[loop]);
                }
                getch();
}
Program illustrating function overloading

# include<iostream.h>
# include<conio.h>
int area(int side)
{
	return side*side;
}
int area(int l , int b)
{
	return l*b;
}

void main()
{
clrscr();
int (*p1)(int);
int (*p2)(int,int);

p1=area;
p2=area;

cout<<"Address of area(int)="<<(unsigned int)p1<<endl;
cout<<"Address of area(int,int)="<<(unsigned int)p2<<endl;

cout<<"Invoking area(int) via p1 "<<p1(20)<<endl;
cout<<"Invoking area(int,int) via p2 "<<p2(10,20);
getch();
}
Program to calculate area of geometric figures.

#include<iostream.h>
#include<math.h>
void main()
{
               char character;
               double area;
               cout<<"circle(c)
";
               cout<<"square(s)
";
               cout<<"rectangle(r)
";
               cout<<"triangle(t)
";
               cout<<"Select c,s,r or t:";
loop:
               cin>>character;
               if((character=='c')||(character=='C'))
               {
                                double r;
                                const double pi=3.142;
                                cout<<"Enter radius:";
                                cin>>r;
                                area=pi*pow(r,2);
               }
               else if((character=='s')||(character=='S'))
               {
                                double l;
                                cout<<"Enter length:";
                                cin>>l;
                                area=pow(l,2);
               }
               else if((character=='r')||(character=='R'))
               {
                                double l,w;
                                cout<<"Enter length:";
                                cin>>l;
                                cout<<"Enter width:";
                                cin>>w;
                                area=l*w;
               }
               else if((character=='t')||(character=='T'))
               {
                                double b,h;
                                cout<<"Enter base:";
                                cin>>b;
                                cout<<"Enter height:";
                                cin>>h;
                                area=h*b/2;
               }
               else
               {
                                cout<<"Select only c,s,r or t:";
                                goto loop;
               }
               cout<<"Area:"<<area<<endl;
}
Program to create a Class= time

#include<iostream.h>
# include<conio.h>
class time
{
	int hr,min,sec;
	public: //don't forget it !
	time()
	{
		hr=min=sec=0;
		cout<<"
Time reset to 00:00:00";
	}
	time(int h,int m,int s)
	{
		hr =h;
		min=m;
		sec=s;
		cout<<"
Time set to specified value.";
	}
	void display()
	{
		cout<<"
Time set is # "<<hr<<":"<<min<<":"<<sec;
	}
	void add(time t1,time t2)
	{
		sec = t1.sec + t2.sec;
		if (sec > 59)
		{sec -=60; min++;}
		min += t1.min +t2.min; //Note Operator Precedence
		if(min>59)
		{min-=60; hr++;}
		hr += t1.hr + t2.hr;
		// Excluding the possibility of hr being greater than
		// 24. We do not want digression...!
	}
};
void main()
{
clrscr();
time a(12,11,33);
time b(10,34,50);
time c;
a.display();
b.display();
c.add(a,b);
c.display();
getch();
}
Program to deal with denominations of any amount

//DENOMINATIONS
#include<stdio.h>
#include<iostream.h>
#include<conio.h>
#include<dos.h>
void main()
{
clrscr();
long r,x1,x2,d1,d2,d3,d4,d5,d6,d7,d8,d9,q1,q2,y1,y2,z1,z2,t1,t2,
											 p1,p2,s1,s2,k1,k2;
int li,lp;
for(li=10;li<71;li++)
{
gotoxy(li,15);
delay(30);
printf("/");
}
for(li=70;li>=10;li--)
{
gotoxy(li,22);
delay(30);
printf("\");
}
for(lp=16;lp<=21;lp++)
{
gotoxy(10,lp);
delay(100);
printf("-");
}
for(lp=21;lp>=16;lp--)
{
gotoxy(70,lp);
delay(100);
printf("-");
 }
gotoxy(16,17);
textcolor(BLINK+YELLOW);
cprintf("                 DENOMINATIONS");
gotoxy(36,28);
textcolor(LIGHTGREEN);
gotoxy(44,48);
textcolor(WHITE);
cout<<"
 please enter the number to be denominated:";
cin>>r;
x1=r/1000;
x2=r%1000;
d1=x1*1000;
y1=x2/500;
y2=x2%500;
d2=y1*500;
z1=y2/100;
z2=y2%100;
d3=z1*100;
s1=z2/50;
s2=z2%50;
d4=s1*50;
t1=s2/20;
t2=s2%20;
d5=t1*20;
p1=t2/10;
p2=t2%10;
d6=p1*10;
k1=p2/5;
k2=p2%5;
d7=k1*5;
q1=k2/2;
q2=k2%2;
d8=q1*2;
d9=q2*1;
textmode(BW40);
cout<<"
 The respective denomination is:




"
    <<"1000 *"<<x1<<"="<<d1<<"
"
    <<" 500 *"<<y1<<"="<<d2<<"
"
    <<" 100 *"<<z1<<"="<<d3<<"
"
    <<"  50 *"<<s1<<"="<<d4<<"
"
    <<"  20 *"<<t1<<"="<<d5<<"
"
    <<"  10 *"<<p1<<"="<<d6<<"
"
    <<"   5 *"<<k1<<"="<<d7<<"
"
    <<"   2 *"<<q1<<"="<<d8<<"
"
    <<"   1 *"<<q2<<"="<<d9<<"
"
    <<"               -----------
"
    <<"         Total="<<r<<"
"
    <<"               -----------
";
getch();
}
Program to find no. of Bytes in a text file

#include<fstream.h>
#include<process.h>
#include<stdio.h>
#include<iostream.h>
#include<process.h>
#include<conio.h>
main()
{
 clrscr();
 int c=0;
 char ch,file[30];
 cout<<"Enter the name of the file:";
 gets(file);
 fstream f1;
 f1.open(file,ios::in);
 if(f1.bad())
 {
 cout<<"File can not be opened.";
 exit(0);
 }
 if(f1.good())
 {
 cout<<"The current contents of the file are:

";
 while(f1)
 {
 f1.get(ch);
 c++;
 cout<<ch;
 }
 }
 cout<<"

Total no. of Bytes are  "<<c;
 f1.close();
 cout<<"

Press Enter key to continue...";
 getch();
 return(0);
}
Program To Know the Day of Birth from Date of Birth

#include<stdio.h>
#include<stdlib.h>
#include<conio.h>

main()
{
 clrscr();
 int d,m,y,year,month,day,i,n;
 printf("Enter how many times you want to run this program : ");
 scanf("%d",&n);
 for(i=1;i<=n;i++)
 {
 printf("

Enter the date :	");
 scanf("%d%d%d",&d,&m,&y);
 if( d>31 || m>12 || (y<1900 || y>=2000) )
  {
   printf("

INVALID INPUT
");
   getch();
   exit(0);
  }
 year = y-1900;
 year = year/4;
 year = year+y-1900;
 switch(m)
  {
   case 1:
   case 10:
		 		     month = 1;
		 		     break;
   case 2:
   case 3:
   case 11:
		 		     month = 4;
		 		     break;
   case 7:
   case 4:
		 		    month = 0;
		 		    break;
   case 5:
		 		    month = 2;
		 		    break;
   case 6:
		 		    month = 5;
		 		    break;
   case 8:
		 		    month = 3;
		 		    break;
   case 9:
   case 12:
		 		    month = 6;
		 		    break;
  }
 year = year+month;
 year = year+d;
 day  = year%7;
 switch(day)
  {
   case 0:
		 		    printf("

Day is SATURDAY
");
		 		    break;
   case 1:
		 		    printf("

Day is SUNDAY
");
		 		    break;
   case 2:
		 		    printf("

Day is MONDAY
");
		 		    break;
   case 3:
		 		    printf("

Day is TUESDAY
");
		 		    break;
   case 4:
		 		    printf("

Day is WEDNESDAY
");
		 		    break;
   case 5:
		 		    printf("

Day is THURSDAY
");
		 		    break;
   case 6:
		 		    printf("

Day is FRIDAY
");
		 		    break;
  }
}
 getch();
 return 0;
}
Program to open a file whose name is passed as command line argument

# include<iostream.h>
# include<conio.h>
# include<fstream.h>
# include<process.h>

void main(int argc,char *argv[])
{
if(argc < 2)
{
	cerr<<"Illegal Usage 
Correct Usage: size <file-name>";
	exit(1);
}
ifstream in(argv[1],ios::in|ios::binary);
if(!in)
{
	cerr<<"Error opening the input file";
	exit(1);
}
long int size=0;
char ch;
while(!in.eof())
{
	in>>ch;
//	cout<<ch;
	size++;
}
cout<<"The size of file "<<argv[1]<<" is "<<size<<" bytes.";

}
Program to represent a bank account (implemented as a Class)

# include<iostream.h>
# include<conio.h>
# include<iomanip.h>

class bank
	{
	char name[20];
	int acno;
	char actype[4];
	float balance;
	public:
	void init();
	void deposit();
	void withdraw();
	void disp_det();
	};
//member functions of bank class
void bank :: init()
{
cout<<"

		New Account
";
cout<<"

Enter the Name of the depositor : ";
cin.get(name,19,'
');
cout<<"
Enter the Account Number : ";
cin>>acno;
cout<<"
Enter the Account Type : (CURR/SAVG/FD/RD/DMAT) ";
cin>>actype;
cout<<"
Enter the Amount to Deposit : ";
cin >>balance;
}
void bank :: deposit()
{
float more;
cout <<"
		Depositing
";
cout<<"

Enter the amount to deposit : ";
cin>>more;
balance+=more;
}
void bank :: withdraw()
{
float amt;
cout<<"
		Withdrwal
";
cout<<"

Enter the amount to withdraw : ";
cin>>amt;
balance-=amt;
}
void bank :: disp_det()
{
cout<<"

		Account Details

";
cout<<"Name of the depositor : "<<name<<endl;
cout<<"Account Number        : "<<acno<<endl;
cout<<"Account Type          : "<<actype<<endl;
cout<<"Balance               : $"<<balance<<endl;
}
// main function , exectution starts here
void main(void)
{
clrscr();
bank obj;
int choice  =1;
while (choice != 0 )
{
cout<<"

Enter 0 to exit
	1. Initialize a new acc.
	2. Deposit
	3.Withdraw
	4.See A/c Status";
cin>>choice;
switch(choice)
{
	case 0 :obj.disp_det();
		cout<<"

		EXITING PROGRAM.";
		break;
	case 1 : obj.init();
		break;
	case 2: obj.deposit();
		break;
	case 3 : obj.withdraw();
		break;
	case 4: obj.disp_det();
		break;
	default: cout<<"

Illegal Option"<<endl;
}
}
getch();
}Project - Employees Management System

#include<iostream.h>
#include<string.h>
#include<iomanip.h>
#include<dos.h>
#include<conio.h>
#include<stdio.h>
#define max 20
struct employee
{
 char name[20];
 long int code;
 char designation[20];
 int exp;
 int age;
};
int num;
employee emp[max],tempemp[max],sortemp[max],sortemp1[max];
void main()
{
 clrscr();
 void build();
 void list();
 void insert();
 void deletes();
 void edit();
 void search();
 void sort();
 char option;
 void menu();
 menu();
 while((option=cin.get())!='q')
 {
  switch(option)
  {
   case 'b':
		     build();
		     break;
   case 'l':
		     list();
		     break;
   case 'i':
		     insert();
		     break;
   case 'd':
		     deletes();
		     break;
   case 'e':
		   edit();
		    break;
   case 's':
		    search();
		    break;
   case 'n':
		     sort();
		     break;
  }
   menu();
  }
 }
 void menu()
 {
  clrscr();
  highvideo();
cout<<"		      ";
cprintf("*****WelCome To Employee Data Centre*****
");
normvideo();
cout<<endl;
cout<<"		         ";
cout<<"Press  b---->Built The Employee Table 
";
cout<<"		         ";
cout<<"Press  l---->List The Employee Table
";
cout<<"		         ";
cout<<"Press  i---->Insert New Entry
";
cout<<"		         ";
cout<<"Press  d---->Delete An Entry
";
cout<<"		         ";
cout<<"Press  e---->Edit An Entry
";
cout<<"		         ";
cout<<"Press  s---->Search Arecord
";
cout<<"		         ";
cout<<"Press  n---->Sort The Table
";
cout<<"		         ";
cout<<"Press  q---------->QUIT 
";
cout<<"		         ";
cout<<"Option Please ----->";
}

void build()
{

 clrscr();
 highvideo();
 cprintf("Build The Table 
");
 cout<<endl;
 normvideo();
 cout<<"maximum number of entries  -----  >  20"<<endl;
 cout<<"how many do you want    ----->";
 cin>>num;
 cout<<"Enter The Following Items
";
 for(int i=0;i<=num-1;i++)
 {
  cout<<" Name	";
  cin>>emp[i].name;
  cout<<"Code	";
  cin>>emp[i].code;
  cout<<"Designation	";
  cin>>emp[i].designation;
  cout<<"Years of Experience	";
  cin>>emp[i].exp;
  cout<<"Age	";
  cin>>emp[i].age;
 }
  cout<<"going to main menu";
  delay(500);
}

void  list()
{
 clrscr();
 highvideo();
 cprintf("       ********List The Table********");
 cout<<endl;
 normvideo();
 cout<<"     Name		 Code		 Designation		 Years(EXP)		 Age
";
 cout<<"     ------------------------------------------------------
";
 for(int i=0;i<=num-1;i++)
 {
  cout<<setw(13)<<emp[i].name;
  cout<<setw(6)<<emp[i].code;
  cout<<setw(15)<<emp[i].designation;
  cout<<setw(10)<<emp[i].exp;
  cout<<setw(15)<<emp[i].age;
  cout<<endl;
 }
  cout<<"going to main menu";
 getch();
  }
  void insert()
  {
  clrscr();
  int i=num;
  num+=1;
  highvideo();
  cprintf("Insert New Record
");
  cout<<endl;
  normvideo();
  cout<<"Enter The Following Items
";
  cout<<"Name	";
  cin>>emp[i].name;
  cout<<"Code	";
  cin>>emp[i].code;
  cout<<"Designation	";
  cin>>emp[i].designation;
  cout<<"Years of Experience	";
  cin>>emp[i].exp;
  cout<<"Age	";
  cin>>emp[i].age;
  cout<<endl<<endl;
  cout<<"going to main menu";
  delay(500);

  }


  void deletes()
  {
   clrscr();
   highvideo();
   int code;
   int check;
   cprintf("Delete An Entry
");
   normvideo();
   cout<<endl;
   cout<<"Enter An JobCode To Delete That Entry	";
   cin>>code;
   int i;
   for(i=0;i<=num-1;i++)
   {
    if(emp[i].code==code)
    {
      check=i;
    }
   }
   for(i=0;i<=num-1;i++)
   {
    if(i==check)
    {
    continue;
    }
    else
    {
    if(i>check)
    {
     tempemp[i-1]=emp[i];
    }
    else
    {
     tempemp[i]=emp[i];
    }
     }
   }
  num--;

  for(i=0;i<=num-1;i++)
  {
   emp[i]=tempemp[i];
  }
 }

void edit()
{
 clrscr();
 int jobcode;
 highvideo();
 cprintf("          Edit An Entry           ");
 cout<<endl;
 cout<<endl;
 int i;
 void editmenu();
 void editname(int);
 void editcode(int);
 void editdes(int);
 void editexp(int);
 void editage(int);
 char option;
 normvideo();
 cout<<"Enter An jobcode To Edit An Entry----	";
 cin>>jobcode;
  editmenu();
 for(i=0;i<=num-1;i++)
   {
    if(emp[i].code==jobcode)
    {

while((option=cin.get())!='q')
{
      switch(option)
      {
       case 'n':
		 		   editname(i);
		 		   break;
       case 'c':
		 		   editcode(i);
		 		   break;
       case 'd':
		 		   editdes(i);
		 		   break;
       case 'e':
		 		   editexp(i);
		 		   break;
       case 'a':
		 		  editage(i);
		 		  break;
     }
   editmenu();
    }
  }
  }
  }
  void editmenu()
  {
   clrscr();
   cout<<"		 		 What Do You Want To edit
";
   cout<<"		 		 n--------->Name
";
   cout<<"		 		 c--------->Code
";
   cout<<"		 		 d--------->Designation
";
   cout<<"		 		 e--------->Experience
";
   cout<<"		 		 a--------->Age
";
   cout<<"              q----->QUIT
";
   cout<<"   Options Please ---->>>	";
  }
  void editname(int i)
  {
     cout<<"Enter New Name----->	";
     cin>>emp[i].name;
  }
  void editcode(int i)
  {
   cout<<"Enter New Job Code----->	";
   cin>>emp[i].code;
  }
  void editdes(int i)
  {
   cout<<"enter new designation----->	";
   cin>>emp[i].designation;
  }
  void editexp(int i)
  {
   cout<<"Enter new Years of Experience
";
   cin>>emp[i].exp;
  }
  void editage(int i)
  {
   cout<<"Enter new Age
";
   cin>>emp[i].age;
  }

void search()
{
 clrscr();
  highvideo();
  cprintf("Welcome To Search Of Employee Database
");
  normvideo();
  cout<<endl;
  cout<<endl;
  int jobcode;
  cout<<"You Can Search Only By Jobcode Of An Employee
";
  cout<<"Enter Code Of An Employee
";
 cin>>jobcode;
 for(int i=0;i<=num-1;i++)
   {
    if(emp[i].code==jobcode)
    {

    cout<<"     Name		 Code		 Designation		 Years(EXP)		 Age
";
 cout<<"     ------------------------------------------------------
";
  cout<<setw(13)<<emp[i].name;
  cout<<setw(6)<<emp[i].code;
  cout<<setw(15)<<emp[i].designation;
  cout<<setw(10)<<emp[i].exp;
  cout<<setw(15)<<emp[i].age;
  cout<<endl;
 }

  }
    cout<<"going to main menu";
 getch();


}

void sort()
{
 clrscr();
 highvideo();
 cprintf("Sort The Databse By JobCode
");
 normvideo();
 void sortmenu();
 void sortname();
 void sortcode();
 void sortdes();
 void sortexp();
 char option;
 void sortage();

 cout<<endl;
 cout<<endl;
 sortmenu();
 while((option=cin.get())!='q')
 {
  switch(option)
  {
   case 'n':
		 		 sortname();
		 		 break;
   case 'c':
		 		 sortcode();
		 		 break;
   case 'd':
		 		 sortdes();
		 		 break;
   case 'e':
		 		 sortexp();
		 		 break;
   case 'a':
		 		 sortage();
		 		 break;
   }
   sortmenu();
  }
 }


 void sortmenu()
 {
    clrscr();
   cout<<"		 		 What Do You Want To edit
";
   cout<<"		 		 n--------->Name
";
   cout<<"		 		 c--------->Code
";
   cout<<"		 		 d--------->Designation
";
   cout<<"		 		 e--------->Experience
";
   cout<<"		 		 a--------->Age
";
   cout<<"              q----->QUIT
";
   cout<<"   Options Please ---->>>	";
  }



void sortname()
{
 clrscr();
 int i,j;
 struct employee temp[max];
 for(i=0;i<=num-1;i++)
 {
  sortemp1[i]=emp[i];
 }
 for(i=0;i<=num-1;i++)
  {
   for(j=0;j<=num-1;j++)
   {
    if(strcmp(sortemp1[i].name,sortemp1[j].name)<=0)
    {
     temp[i]=sortemp1[i];
     sortemp1[i]=sortemp1[j];
     sortemp1[j]=temp[i];
    }
   }
 }

 for( i=0;i<=num-1;i++)
   {

    cout<<"     Name		 Code		 Designation		 Years(EXP)		 Age
";
 cout<<"     ------------------------------------------------------
";
 for( i=0;i<=num-1;i++)
 {
  cout<<setw(13)<<sortemp1[i].name;
  cout<<setw(6)<<sortemp1[i].code;
  cout<<setw(15)<<sortemp1[i].designation;
  cout<<setw(10)<<sortemp1[i].exp;
  cout<<setw(15)<<sortemp1[i].age;
  cout<<endl;
 }
  cout<<"Press Any Key To Go Back";
 getch();

} }

void sortcode()
{
 clrscr();
 int i,j;
 struct employee temp[max];
 for(i=0;i<=num-1;i++)
 {
  sortemp1[i]=emp[i];
 }
 for(i=0;i<=num-1;i++)
  {
   for(j=0;j<=num-1;j++)
   {
    if(sortemp1[i].code<sortemp1[j].code)
    {
     temp[i]=sortemp1[i];
     sortemp1[i]=sortemp1[j];
     sortemp1[j]=temp[i];
    }
   }
 }

 for( i=0;i<=num-1;i++)
   {

    cout<<"     Name		 Code		 Designation		 Years(EXP)		 Age
";
 cout<<"     ------------------------------------------------------
";
 for( i=0;i<=num-1;i++)
 {
  cout<<setw(13)<<sortemp1[i].name;
  cout<<setw(6)<<sortemp1[i].code;
  cout<<setw(15)<<sortemp1[i].designation;
  cout<<setw(10)<<sortemp1[i].exp;
  cout<<setw(15)<<sortemp1[i].age;
  cout<<endl;
 }
  cout<<"Press Any Key To Go Back";
 getch();

} }


void sortdes()
{
 clrscr();
 int i,j;
 struct employee temp[max];
 for(i=0;i<=num-1;i++)
 {
  sortemp1[i]=emp[i];
 }
 for(i=0;i<=num-1;i++)
  {
   for(j=0;j<=num-1;j++)
   {
    if(strcmp(sortemp1[i].designation,sortemp1[j].designation)<=0)
    {
     temp[i]=sortemp1[i];
     sortemp1[i]=sortemp1[j];
     sortemp1[j]=temp[i];
    }
   }
 }

 for( i=0;i<=num-1;i++)
   {

    cout<<"     Name		 Code		 Designation		 Years(EXP)		 Age
";
 cout<<"     ------------------------------------------------------
";
 for( i=0;i<=num-1;i++)
 {
  cout<<setw(13)<<sortemp1[i].name;
  cout<<setw(6)<<sortemp1[i].code;
  cout<<setw(15)<<sortemp1[i].designation;
  cout<<setw(10)<<sortemp1[i].exp;
  cout<<setw(15)<<sortemp1[i].age;
  cout<<endl;
 }
  cout<<"Press Any Key To Go Back";
 getch();

} }

void sortage()
{
 clrscr();
 int i,j;
 struct employee temp[max];
 for(i=0;i<=num-1;i++)
 {
  sortemp1[i]=emp[i];
 }
 for(i=0;i<=num-1;i++)
  {
   for(j=0;j<=num-1;j++)
   {
    if(sortemp1[i].age<sortemp1[j].age)
    {
     temp[i]=sortemp1[i];
     sortemp1[i]=sortemp1[j];
     sortemp1[j]=temp[i];
    }
   }
 }

 for( i=0;i<=num-1;i++)
   {

    cout<<"     Name		 Code		 Designation		 Years(EXP)		 Age
";
 cout<<"     ------------------------------------------------------
";
 for( i=0;i<=num-1;i++)
 {
  cout<<setw(13)<<sortemp1[i].name;
  cout<<setw(6)<<sortemp1[i].code;
  cout<<setw(15)<<sortemp1[i].designation;
  cout<<setw(10)<<sortemp1[i].exp;
  cout<<setw(15)<<sortemp1[i].age;
  cout<<endl;
 }
  cout<<"Press Any Key To Go Back";
 getch();

} }


void sortexp()
{
 clrscr();
 int i,j;
 struct employee temp[max];
 for(i=0;i<=num-1;i++)
 {
  sortemp1[i]=emp[i];
 }
 for(i=0;i<=num-1;i++)
  {
   for(j=0;j<=num-1;j++)
   {
    if(sortemp1[i].exp<sortemp1[j].exp)
    {
     temp[i]=sortemp1[i];
     sortemp1[i]=sortemp1[j];
     sortemp1[j]=temp[i];
    }
   }
 }

 for( i=0;i<=num-1;i++)
   {

    cout<<"     Name		 Code		 Designation		 Years(EXP)		 Age
";
 cout<<"     ------------------------------------------------------
";
 for( i=0;i<=num-1;i++)
 {
  cout<<setw(13)<<sortemp1[i].name;
  cout<<setw(6)<<sortemp1[i].code;
  cout<<setw(15)<<sortemp1[i].designation;
  cout<<setw(10)<<sortemp1[i].exp;
  cout<<setw(15)<<sortemp1[i].age;
  cout<<endl;
 }
  cout<<"Press Any Key To Go Back";
 getch();

} }
Queue Data Structure Class Example which uses Polymorphism

#include <dos.h>
#include <stdlib.h>
#include <iostream.h>
#include <conio.h>
#include <windows.h>

#define MAX 5           // MAXIMUM CONTENTS IN QUEUE

class task
{
   public:
    virtual void dotask(){}
    task(){}
    int exists;

};

class notep: public task
{

  public:
    notep(){exists=1;}

		  void dotask()
		  {
		 		  system("notepad");
		  }
};

class regt:public task
{
		 public:
		 regt(){exists=1;}

		 void dotask()
		 {
		   system("regedit");
		 }
};

class winex:public task
{
		 public:
		 winex(){exists=1;}

		 void dotask()
		 {
		   system("explorer");
		 }
};

class Bep:public task
{
  public:
  Bep(){exists=1;}

  void dotask()
  {
		 cout<<"a";
  }
};

class MsBox:public task
{
  private:
  char* text;
  char* caption;
  int style;

  public:
  MsBox(char* ext,char* cap,int no)
  {
   text=ext;
   caption=cap;
		 exists=1;
		 style=no;
  }

  void dotask()
  {
		 MessageBox(0,text,caption,style);
  }
};

class queue
{
 private:
 task *t[MAX];
 int al;
 int dl;

 public:
 int opt,opt1,a;
 char te[255],capt[40];

  queue()
 {
  dl=-1;
  al=-1;
 }

void del()
{
  task* tmp;
  if(dl==-1)
  {
		 cout<<"Queue is Empty";
   sleep(2);
  }
  else
  {
		 t[dl]->exists=0;
		 for(int j=0;j<=al;j++)
		 {
		   if((j+1)<=al)
		   {
		   tmp=t[j+1];
		   t[j]=tmp;
		   }
		   else
		   {
		   t[al]->exists=0;
		   al--;

		   if(al==-1)
		 		  dl=-1;
		 		  else
		 		  dl=0;
		   }
		 }
  }
}

void menu()
{
 clrscr();
 cout<<"1) Add Task 
2)Execute Tasks
3)Exit Program
";
// int opt;
 cin>>opt;
 switch(opt)
 {
  case 1:
  clrscr();
  cout<<"1) Open Notepad
";
  cout<<"2) Open Explorer
"
		 		 <<"3) Open Registry
"
		 		 <<"4) Sound a Beep
"
		 		 <<"5) MessageBox API
"
		 		 <<"6) Back
";


  cin>>opt1;
  if(opt1!=6)
  add(opt1);
  break;

  case 2:
  if(al!=-1 && dl!=-1)
  {
		 for(int k=0;k<=al;k++)
		  {
		 		 if(t[k]->exists==1)
		 		 t[k]->dotask();
		 		 t[k]->exists=0;
		  }
		  al=dl=-1;
  }
  else
  {
  cout<<"Queue is Empty";
  sleep(3);
  }
  break;

  case 3:
  exit(0);
  break;
 }
}

void add(int item)
{
 if(dl==-1 && al==-1)
 {
  dl++;
  al++;
 }
 else
 {
  al++;
  if(al<MAX){}
  else
  {
		 cout<<"Queue is Full
";
		 al--;
   sleep(3);
		 return;
  }
 }
 switch(item)
 {
  case 1:
  t[al]=new notep;
  break;

  case 2:
  t[al]=new winex;
  break;

  case 3:
  t[al]=new regt;
  break;

  case 4:
  t[al]=new Bep;
  break;

  case 5:
  cout<<"
 Enter Style Number:";
  cin>>a;
  t[al]=new MsBox("Task Performed.","Queue Implementation",a);
  break;

  default:
  cout<<"Programming Error"; // No Possibility of this executing
  };
  }

};

void main()
{
 queue a;
 while(1)
 {
 a.menu();
 }
}
simple adding of records using fstream.h

#include<fstream.h>
#include<conio.h>
#include<iostream.h>
#include<string.h>
#include<ctype.h>
#include<conio.h>

add();
main()
{
ifstream input_stream("rec.dat");
char p[30],ch,c;
int x,num;
clrscr();
	cout<<"[A]dd record "<<endl;
	cout<<"[S]earch record "<<endl;
	cout<<"[E]xit "<<endl;
	ch=getche();
	switch(toupper(ch))
	{
	case 'A':
			clrscr();
			add();
			break;
	case 'S':
			clrscr();
			cout<<"
Enter record number:";
			cin>>num;
			for(x=1;x<=num;x++)
			{
			input_stream>>x;
			input_stream>>p;
			}
			cout<<"Record number: "<<num<<endl;
			cout<<"Name: "<<p<<endl;
			break;
	case 'E':
			return 0;
      }
      input_stream.close();

getch();
return 0;
}

add()
{
char n[30],c;
int y=0;
ofstream out_stream("rec.dat");
	do{
	   cout<<"
Enter name:";
	   cin>>n;
	   {
	   y++;
	   }
	   out_stream<<y<<endl;
	   out_stream<<n<<endl;
	   cout<<"Enter another file again? [y/n]: ";
	   c=getche();
	   }while(c!='n');
out_stream.close();
getch();
return 0;
}
Stack implementation as a class

# include<iostream.h>
# include<process.h>
# include<conio.h>
# define SIZE 20

class stack
{
int a[SIZE];
int tos; // Top of Stack
public:
	stack();
	void push(int);
	int pop();
	int isempty();
	int isfull();
};
stack::stack()
{
tos=0; //Initialize Top of Stack
}

int stack::isempty()
{
return (tos==0?1:0);
}
int stack::isfull()
{
return (tos==SIZE?1:0);
}

void stack::push(int i)
{
if(!isfull())
{
a[tos]=i;
tos++;
}
else
{
 cerr<<"Stack overflow error !
Possible Data Loss !";
}
}
int stack::pop()
{
if(!isempty())
{
return(a[--tos]);
}
else
{
cerr<<"Stack is empty! What to pop...!";
}
return 0;
}

void main()
{
stack s;
int ch=1,num;
while(ch!=0)
{
	cout<<"Stack Operations Mani Menu
1.Push
2.Pop
3.IsEmpty
4.IsFull
0.Exit

";
	cin>>ch;
	switch(ch)
	{
	case 0:
		exit(1); //Normal Termination of Program
	case 1:
		cout<<"Enter the number to push";
		cin>>num;
		s.push(num);
		break;
	case 2:
		cout<<"Number popped from the stack is: "<<s.pop()<<endl;
		break;
	case 3:
		(s.isempty())?(cout<<"Stack is empty.
"):(cout<<"Stack is not empty.
");
		break;
	case 4:
		(s.isfull())?(cout<<"Stack is full.
"):(cout<<"Stack is not full.
");
		break;
	default:
		cout<<"Illegal Option.
Please try again
";
	}
}//end of while
getch();
}
To find if the given number is an armstrong number or not

# include <iostream.h>
# include <conio.h>
# include <math.h>
 void main ()
{ clrscr();
 int a,b=0,sum=0;
 long int n;
 cout<<"ENter the NO. : ";
 cin>>n;
 for(;n>0;)
//counts the digits
 { a=n%10;
   n=n/10;
   b++;
 }
 for(;n>0;)
 { a=n%10;
   sum=sum+pow(a,b);
   n=n/10;
 }
  if(sum==n)
 { cout<<"IT IS AN ARMSTRONG NUMBER...";
  getch();
 }
  else
 { cout<<"IT IS NOT AN ARMSTRONG NUMBER...";
   getch();
 }
}
To perform operations on complex number using operator

:#include<iostream.h>
#include<math.h>
#include<process.h>
#include<conio.h>
class comp
                {
                private:
                                 float real,image;
                public:
                                 comp operator +(comp a);
                                 comp operator -(comp a);
                                 comp operator *(comp a);
                                 comp operator /(comp a);
                                 void getdata();
                                 void show();
                };
void comp :: getdata()
                {
                cout<<"

		Enter real part=";
                cin>>real;
                cout<<"

		Enter imaginary part=";
                cin>>image;
                }
void comp :: show()
                {
                                 cout.precision(2);
                if(image<0)
                                 cout<<real<<image<<"i";
                else
                                 cout<<real<<"+"<<image<<"i";
                }
comp comp :: operator +(comp a)
                {
                comp temp;
                temp.real=real+a.real;
                temp.image=image+a.image;
                return temp;
                }
comp comp :: operator -(comp a)
                {
                comp temp;
                temp.real=a.real-real;
                temp.image=a.image-image;
                return temp;
                }
comp comp :: operator *(comp a)
                {
                comp temp;
                temp.real=(a.real*real)-(a.image*image);
                temp.image=(a.real*image)+(real*a.image);
                return temp;
                }
comp comp :: operator /(comp a)
                {
                comp temp;
                temp.real=((real*a.real)+(a.image*image))/((real*real)+(image*image));
                temp.image=((real*a.image)-(image*a.image))/((real*real)+(image*image));
                return temp;
                }

void main()
                {
                comp d,e,f;
                int ch;
                char ans;
                do
                {
                clrscr();
                cout<<"

		********** Menu **********
";
                cout<<"

		1>Addition";
                cout<<"

		2>Subtraction";
                cout<<"

		3>Multiplication";
                cout<<"

		4>Division";
                cout<<"

		5>Exit";
                d.getdata();
                e.getdata();
                cout<<"

		first no=>";
                d.show();
                cout<<"

		second no=>";
                e.show();
                cout<<"

		enter the choice=>";
                cin>>ch;
                switch(ch)
                                 {
                                 case 1:
                                 f=d-e;
                                 cout<<"

		addition of two no=>";
                                 f.show();
                                 break;
                                 case 2:
                                 f=d-e;
                                 cout<<"

		subtraction of two no=>";
                                 f.show();
                                 break;
                                 case 3:
                                 f=d*e;
                                 cout<<"

		multiplication of two no=>";
                                 f.show();
                                 break;
                                 case 4:
                                 f=d/e;
                                 cout<<"

		division of two no=>";
                                 f.show();
                                 break;
                                 case 5:
                                 exit(0);
                                 break;
                                 }
                                 cout<<"

		do you want to continue(y/n)?=";
                                 cin>>ans;
                                 }
                                 while(ans=='y'||ans=='Y');
                                 getch();
                                 }
A generic stack class

#include <iostream>
#include <new>
#include <string>
#include <sstream>

using namespace std;

#if !defined __STACK_H
#define __STACK_H

namespace stk{
	template<class T>
	class Stack; // Forward declaration of Stack class for overloaded <<
operator

	template<class T>
	ostream& operator<<(ostream &,Stack<T> &); // template declaration of 
<<
operator

	template<class T>
	class Stack{
		private:
			T *p;
			int top,length;

			string str()const;
		public:
			Stack();
			Stack(const int);
			Stack(const Stack<T>&);
			~Stack();

			void push(T);
			T pop();
			int get_length()const;
			bool is_empty()const;
			Stack<T> operator=(const Stack<T>&);

			// only for basic types
			friend ostream& operator<< <>(ostream&,Stack<T> &);

			class StackException{
				private:
					string desc;
				public:
					StackException(string exp){ desc="Exception : "+exp; }
					string get_exp(){ return desc; }
			};
	};

	template<class T>
	Stack<T>::Stack(){
		top=-1;
		length=0;
		p=0;
	}

	template<class T>
	Stack<T>::Stack(const int size){
		top=-1;
		length=size;
		try{
			p=new T[length];
		}catch(bad_alloc ba){
			cout<<"Memory can not be alllocated
";
			return;
		}
	}

	template<class T>
	Stack<T>::Stack(const Stack<T> &o){
		top=o.top;
		length=o.length;
		try{
			p=new T[length];
		}catch(bad_alloc ba){
			cout<<"Memory allocation failed
";
			return;
		}
		for(int i=0;i<length;i++)
			p[i]=o.p[i];
	}

	template<class T>
	Stack<T>::~Stack(){
		if(p!=0)
			delete [] p;
	}

	template<class T>
	void Stack<T>::push(T elem){
		if(p==0){
			try{
				p=new T[1];
			}catch(bad_alloc ba){
				throw StackException("Memory fault
");
			}
			length++;
			top++;
			p[top]=elem;
		}
		else if(top==(length-1)){
			T *q;
			try{
				q=new T[length+1];
			}catch(bad_alloc ba1){
				throw StackException("Memory fault
");
			}
			for(int i=0;i<length;i++)
				q[i]=p[i];
			length++;
			top++;
			q[top]=elem;
			delete [] p;
			p=q;
		}
		else{
			top++;
			p[top]=elem;
		}
	}

	template<class T>
	T Stack<T>::pop(){
		if(p==0 || top==-1){
			throw StackException("Stack empty!
");
		}
		T ret=p[top];
		top--;
		length--;

		if(top==-1){
			delete [] p;
			p=0;
		}
		else{
			T *q;
			try{
				q=new T[length];
			}catch(bad_alloc ba){
				throw StackException("Memory fault
");
			}
			for(int i=0;i<length;i++)
				q[i]=p[i];
			delete [] p;
			p=q;
		}

		return ret;
	}

	template<class T>
	int Stack<T>::get_length()const{
		return length;
	}

	template<class T>
	bool Stack<T>::is_empty()const{
		return ((p==0)? true : false);
	}

	template<class T>
	string Stack<T>::str()const{  // private member function
		if(p==0)
			return string("");
		stringstream ss;
		for(int i=0;i<length;i++){
			ss << p[i];
			if(i!=(length-1))
				ss << ", ";
		}
		//ss<<"
";
		return ss.str();
	}

	template<class T>
	Stack<T> Stack<T>::operator=(const Stack<T> &stk){
		length=stk.length;
		top=stk.top;

		if(p!=0)
			delete [] p;
		try{
			p=new T[length];
		}catch(bad_alloc ba){
			throw StackException("Memory fault in copying!
");
		}
		for(int i=0;i<length;i++)
			p[i]=stk.p[i];

		return *this;
	}

	template<class T>
	ostream& operator<<(ostream &o,Stack<T> &s){
		o<<s.str();
		return o;
	}

} // namespace stk;

#endif
This is a program of matrix capable of doing several works with two matrices.
It can add, subtract, multiply of two matrices and
if user wants to see the input entered in two matrices he can also see. It
provides the facility to user to do again some work on another matrix
without running the program twice.

Code :
#include<iostream.h>
#include<conio.h>
#include<iomanip.h>
#include<process.h>
#define sk 100
class matrix
{
public:
int i,j,k,sum,r1,r2,c1,c2;
int m1[sk][sk],m2[sk][sk];
char reply;
void getin(void);
void mply(void);
void add(void);
void minus(void);
void read(void);
void input(void);
};
void matrix::getin()
{
cout<<"

	 WELCOME TO SOLUTION OF TWO MATRICRES ";
cout<<"
	 -------------------------------------";

cout<<"

	 YOU CAN CALCULATE UPTO A LIMIT OF MATRIX 100 * 100 ";
cout<<"

	 YOU CAN DO THE FOLLOWING : 

	 ADDITION 
	 
SUBTRACTION
";
cout<<"
	 MULTIPLICATION AND 
	 READ ONLY ";
cout<<"


	 DO YOU WANT TO CONTINUE [Y/N] : ";
cin >>reply;
if(reply=='y'||reply=='Y')
{
cout<<"

	 Enter the number of rows and columns of matrix 1 : ";
cin>>r1>>c1;
cout<<"
 Enter the value of matrix 1 : "<<endl;
for(i=0;i<r1;i++)
   for(j=0;j<c1;j++)
   cin>>m1[i][j];
cout<<"
	 Enter the number of rows and columns of matrix 2 : ";
cin>>r2>>c2;
cout<<"
 Enter the value of matrix 2 : "<<endl;
for(i=0;i<r2;i++)
   for(j=0;j<c2;j++)
   cin>>m2[i][j];
}
else exit(0);
}
void matrix::mply()
{
cout<<"
 THE RESULT AFTER MULTIPLICATION IS : 
";
if(c1==r2)
{
for(i=0;i<r1;i++)
   {
   cout<<endl;
   for(j=0;j<c2;j++)
   {
   sum=0;
   for(k=0;k<c1;k++)
   sum+=m1[i][k]*m2[k][j];
   cout<<setw(6)<<sum;
   }
   }
}
else
	{
	cout<<"
	 INVALID INPUT ";
	cout<<"
	 MULTIPLICATION NOT POSSIBLE ";
	}
}
void matrix::add()
{
cout<<"
 THE RESULT AFTER ADDITION IS : 
";
if(r1==r2&&c1==c2)
{
for(i=0;i<r1;i++)
   {
   cout<<endl;
   for(j=0;j<c1;j++)
   cout<<setw(3)<<(m1[i][j]+m2[i][j]);
   }
}
else
	{
	cout<<"
	 INVALID INPUT ";
	cout<<"
	 ADDITION NOT POSIIBLE ";
	}
}
void matrix::minus()
{
cout<<"
 THE RESULT AFTER SUBTRACTION IS : 
";
if(r1==r2&&c1==c2)
{
for(i=0;i<r1;i++)
   {
   cout<<endl;
   for(j=0;j<c1;j++)
   cout<<setw(3)<<(m1[i][j]-m2[i][j]);
   }
}
else
	{
	cout<<"
	 INVALID INPUT ";
	cout<<"
	 SUBTRACTION NOT POSSIBLE ";
	}

}
void matrix::read()
{
cout<<"
 ENTERED MATRIX 1 IS : 
";
for(i=0;i<r1;i++)
   {
   cout<<endl;
   for(j=0;j<c1;j++)
   cout<<setw(3)<<m1[i][j];
   }
cout<<endl;
cout<<"
 ENTERED MATRIX 2 IS : 
";
for(i=0;i<r2;i++)
   {
   cout<<endl;
   for(j=0;j<c2;j++)
   cout<<setw(3)<<m2[i][j];
   }
}
void main()
{
int ans,option;
char response;
matrix m;
clrscr();
start :
m.getin();
again :
cout<<"
	 What you wish to do : "<<endl;
cout<<"
	 1.ADDITION ";
cout<<"
	 2.SUBTRACTION ";
cout<<"
	 3.MULTIPLY ";
cout<<"
	 4.READ ONLY ";
cout<<"
	 5.EXIT ";
cout<<"


	 ENTER YOUR CHOICE IN NUMBERS : ";
repeat :
cin>>ans;
switch(ans)
{
case 1 : m.add(); break;
case 2 : m.minus(); break;
case 3 : m.mply(); break;
case 4 : m.read(); break;
case 5 : goto exit ;
default :
{
cout<<"
	 INVALID ENTRY 
	 ENTER YOUR CHOICE AGAIN : ";
goto repeat;
}
}
cout<<"
	 DO YOU WANT TO DO IT FOR ANOTHER TIME [Y/N] : ";
cin>>response;
if(response=='y'||response=='Y')
{
wrong:
cout<<"
	 Enter your choice in number 
";
cout<<"
	 1.FOR Same matrix 
	 2.FOR Another matrix 

	 ";
cin>>option;
switch(option)
{
case 1 : goto again;
case 2 : goto start;
default: cout<<"

	 INVALID ENTRY "; goto wrong;
}
}
exit :
getch();
}


This program in CPP, demonstrates the array implementation of Circular Queue.

Code:

#include<iostream.h>
#include<stdlib.h>
#include<stdio.h>
#include<conio.h>

// Defining class CQUEUE
class cqueue
 {
   int q[10],num,front,rear;
   public :
	cqueue();
	void insert();
	void remove();
	void menu();
	void display();
 };

cqueue :: cqueue()
 {
   front=rear=0;
 }

void cqueue :: insert()
 {
   if(((rear+1)%10)==front)
    {
      cout<<"Queue is full
";
    }
   else
    {
      cout<<"Please enter a number : 
";
      cin>>
      q[rear];
      rear=(rear+1)%10;
    }
 }

void cqueue :: remove()
 {
   if(rear==front)
    {
      cout<<"Queue is empty
";
    }
   else
    {
      int num=q[front];
      cout<<"You deleted "<<num<<"
";
      front=(front+1)%10;
      getch();
    }

 }

void cqueue::display()
 {
   int i=front;
   if(front==rear)
    {
      cout<<"Queue is empty, No elements to display !!!!!! 
 ";
    }
   else
    {
      cout<<"Queue's elements are :
";
      cout<<"Front = ";
      while( i!=rear)
       {
	if(i==(rear-1)) cout<<"Rear = ";
	cout<<q[i]<<"
";
	i=i++%10;

       } // end while.
    }// end elseif.
   getch();
 }

void cqueue :: menu()
 {
   int ch=1;
   clrscr();
   while (ch)
    {
      clrscr();
      cout<<"Enter your Choice
1 : insert
2 : remove
3 : display
0 
:
exit
";

      cin >>ch;
      switch (ch)
       {
	 case 1 : insert();
		  break;
	 case 2 : remove();
		  break;
	 case 3 : display();
		  break;
	 case 0 : exit(0);
       }
    }
 }


void main()
 {
  cout<<"Program to demonstrate Circular Queue
";
  cqueue q1;
  q1.menu();
 }


Various data encoding techniques

Code :

# include <graphics.h>
# include <iostream.h>
# include <conio.h>
# include <string.h>
# include <dos.h>

int main(void)
{
   void drawgrid(int, int, int, int);
   void encode(char *,char *, int, int, int, int);
   void draw(int ,int ,char *, int);

   char *message;
   int len;

   clrscr();
   cout << "
DIGITAL ENCODING TECHNIQUES";
   cout << "


Enter the data to be encoded (max 24 bits) : ";

   do{
   cin >> message;
   len = strlen(message);
   if(len>24)
     cout << "Message is greater than 12 bits, please type new message: 
";
   }while(len>24);

   char *o_mess =new char[len];
   char *e_mess =new char[len*2];
   strcpy(o_mess,message);

   int gd=DETECT, gm, i, x, y;

   initgraph(&gd,&gm,"..\BGI");
   setcolor(8);
   settextstyle(DEFAULT_FONT,0,2);
   outtextxy(100,10,"DIGITAL ENCODING TECHNIQUES");
   setcolor(YELLOW);
   rectangle(0,30,630,450);
   rectangle(1,31,629,449);
   setcolor(WHITE);
   settextstyle(DEFAULT_FONT,0,0);
   drawgrid(120,60,len,20);
   outtextxy(10,50, "Message");

   x= 137;
   for(i=0; i<len; i++, x+=20)
   {
     if(o_mess[i]=='1')
	outtextxy(x,50,"1");
     else
	outtextxy(x,50,"0");
   }

   x=120;
   y=80;
   outtextxy(10,100, "NRZ - L");
   encode(o_mess,e_mess,len,0,2,0);
   draw(x,y,e_mess,len*2);
   y+=60;

   outtextxy(10,160, "NRZ - I");
   encode(o_mess,e_mess,len,3,4,0);
   draw(x,y,e_mess,len*2);
   y+=60;

   outtextxy(10,220, "Bipolar AMI");
   encode(o_mess,e_mess,len,3,1,0);
   draw(x,y,e_mess,len*2);
   y+=60;

   outtextxy(10,280, "Pseudo Tenary");
   encode(o_mess,e_mess,len,4,3,0);
   draw(x,y,e_mess,len*2);
   y+=60;

   outtextxy(10,340, "Manchester");
   encode(o_mess,e_mess,len,0,2,1);
   draw(x,y,e_mess,len*2);
   y+=60;

   outtextxy(10,400, "D-Manchester");
   encode(o_mess,e_mess,len,4,3,1);
   draw(x,y,e_mess,len*2);
   y+=60;

   getch();
   closegraph();

   return 0;
}

void drawgrid(int x, int y, int pulses, int width)
{
   line(x,y,x+(pulses*width),y);
   line(x,y,x,y+(width*12+150));

   for(int i=0; i<pulses; i++)
   {
      setcolor(LIGHTBLUE);
      line(x+width,y+1,x+width,y+(width*12+150));
      setcolor(BLUE);
      line(x+width/2,y+1,x+width/2,y+(width*12+150));
      x+=width;
   }
   setcolor(WHITE);

   return;
}

void draw(int x, int y, char *data, int len)
{
   int prev_y, curr_y;

   prev_y = y;

   for(int i=0; i<len; i++, x+=10)
   {
       if(data[i]=='2')
	  curr_y = y;
       if(data[i]=='1')
	  curr_y = y+20;
       if(data[i]=='0')
	  curr_y = y+40;


       line(x,curr_y,x+10,curr_y);
       sound(70);
       delay(50);
       nosound();

       if(prev_y != curr_y)
	  line(x,prev_y,x,curr_y);
	  sound(170);
	  delay(50);
	  nosound();

       prev_y = curr_y;
      delay(10);
   }
   return;
}

void encode(char *o_mess,char *e_mess,int len,int one,int zero, int 
mid)
{
   int i, j, previous=2;

   for(i=0, j=0; i<len; i++, j+=2)
   {
      if(o_mess[i]=='1')
      {
	 if(one==0)
	    e_mess[j]='0';
	 if(one==1)
	    e_mess[j]='1';
	 if(one==2)
	    e_mess[j]='2';
	 if(one==3)
	 {
	   if(previous==2)
	   {
	     previous=0;
	     e_mess[j]='0';
	   }
	   else
	   {
	     previous=2;
	     e_mess[j]='2';
	   }
	 }
	 if(one==4)
	 {
	   if(previous==2)
	     e_mess[j]='2';
	   else
	     e_mess[j]='0';
	 }
      }
      else
      {
	 if(zero==0)
	    e_mess[j]='0';
	 if(zero==1)
	    e_mess[j]='1';
	 if(zero==2)
	    e_mess[j]='2';
	 if(zero==3)
	 {
	   if(previous==2)
	   {
	     previous=0;
	     e_mess[j]='0';
	   }
	   else
	   {
	     previous=2;
	     e_mess[j]='2';
	   }
	 }
	 if(zero==4)
	 {
	   if(previous==2)
	     e_mess[j]='2';
	   else
	     e_mess[j]='0';
	 }
      }
      if(mid==1)
      {
	 if(e_mess[j]=='2')
	     e_mess[j+1]='0';
	 else
	     e_mess[j+1]='2';
	 if(previous==2)
	    previous=0;
	 else
	    previous=2;
      }
      else
	e_mess[j+1]=e_mess[j];
   }
   return;
}
Converts Decimal Numbers to Binary

#include <iostream.h>
#include <conio.h>
void main()


   {



     int i, ch;
                    cout<<"Enter an integer: ";
                    cin>>ch;
                    for(i=0x80;i;i=i>>1)
                                                  cout<<((ch&i)?'1':'0');


     getch();

                        cout<<endl;
   }
Drawing Pad - An Easy way to create circles, rectangles etc.


#include<iostream.h>
#include<stdio.h>
#include<string.h>
#include<string.h>
#include<stdlib.h>
#include<graphics.h>
#include<conio.h>
#include<dos.h>
#include<fstream.h>

	class mouse
	{
	union REGS i, o;
	public:

	mouse()
	{
	initmouse();
	showmouseptr();
	}

	void initmouse()
	{
	i.x.ax=0;
	int86(0x33,&i,&o);
	}

	void showmouseptr()
	{
	i.x.ax=1;
	int86(0x33,&i,&o);
	}

	void hidemouseptr()
	{
	i.x.ax=2;
	int86(0x33,&i,&o);
	}

	void getmousepos(int& button, int& x, int& y)
	{
	i.x.ax=3;
	int86(0x33,&i,&o);
	button=o.x.bx;
	x=o.x.cx;
	y=o.x.dx;
	}

	void restrictmouseptr(int x1, int y1, int x2, int y2)
	{
	i.x.ax=7;
	i.x.cx=x1;
	i.x.dx=x2;
	int86(0x33,&i,&o);
	i.x.ax=8;
	i.x.cx=y1;
	i.x.dx=y2;
	int86(0x33,&i,&o);
	}

	};

	class shapes
	{
	public:

	virtual void draw()
	{
	}

	virtual void save (ofstream &ft)
	{
	}

	virtual void open(ifstream &fs)
	{
	}

	};

	class myline:public shapes
	{
	int sx,sy,ex,ey,color;
	public:

	myline()
	{
	}

	myline(int x1,int y1,int x2,int y2,int clr)
	{
	sx=x1;
	sy=y1;
	ex=x2;
	ey=y2;
	color=clr;
	}

	void draw()
	{
	setcolor(color);
	moveto(sx,sy);
	lineto(ex,ey);
	}

	void save(ofstream &ft)
	{
	ft<<"L"<<"
";
	ft<<sx<<" "<<sy<<" "<<ex<<" "<<ey<<" "<<color<<"
";
	}

	void open(ifstream &fs)
	{
	fs>>sx>>sy>>ex>>ey>>color;
	}

	};

	class myrectangle:public shapes
	{
	int sx,sy,ex,ey,color;
	public:

	myrectangle()
	{
	}

	myrectangle(int x1,int y1,int x2,int y2,int clr)
	{
	sx=x1;
	sy=y1;
	ex=x2;
	ey=y2;
	color=clr;
	}

	void draw()
	{
	setcolor(color);
	rectangle(sx,sy,ex,ey);
	}

	void save(ofstream &ft)
	{
	ft<<"R"<<"
";
	ft<<sx<<" "<<sy<<" "<<ex<<" "<<ey<<" "<<color<<"
";
	}

	void open(ifstream &fs)
	{
	fs>>sx>>sy>>ex>>ey>>color;
	}

	};

	class mycircle:public shapes
	{
	int sx,sy,radius,color;
	public:

	mycircle()
	{
	}

	mycircle(int x1,int y1,int r,int clr)
	{
	sx=x1;
	sy=y1;
	radius=r;
	color=clr;
	}

	void draw()
	{
	setcolor(color);
	circle(sx,sy,radius);
	}

	void save(ofstream &ft)
	{
	ft<<"C"<<"
";
	ft<<sx<<" "<<sy<<" "<<radius<<" "<<color<<"
";
	}

	void open(ifstream &fs)
	{
	fs>>sx>>sy>>radius>>color;
	}

	};

	struct node
	{
	void *obj;
	node *link;
	};

	class objarray
	{
	node *head;
	public:

	objarray()
	{
	head =NULL;
	}

	void add(void *o)
	{
	node *temp =new node;
	temp->obj=o;
	temp->link=NULL;
	if(head==NULL)
	head=temp;
	else
	{
	node *q;
	q=head;
	while(q->link!=NULL)
		q=q->link;
	q->link=temp;
	}
	}

	void *getobj(int i)
	{
	node *q;
	q=head;
	for(int n=1; n<i;n++)
		q=q->link;
	return(q->obj);
	}

	int getcount()
	{
	int n=0;
	node *q;
	q=head;
	while(q!=NULL)
	{
	q=q->link;
	n++;
	}
	return n;
	}

	~objarray()
	{
	node *q;
	q=head;
	while(q!=NULL)
	{
	head=head->link;
	delete q;
	q=head;
	}
	}

	};

	void mainscreen()
	{
	cleardevice();
	rectangle(0,0,639,479);
	line(0,30,640,30);
	char *names[]={"Clear","Open","Save","Line","Rect","Circ","Exit"};
	int x,i;
	for(x=5,i=0;x<=7*90;x+=90,i++)
	{
	setcolor(WHITE);
	rectangle(x,5,x+70,25);
	floodfill(x+1,6,WHITE);
	settextstyle(1,0,3);
	setcolor(BLACK);
	outtextxy(x+10,0,names[i]);
	}
	}
	void DisplayName(int ycor)
	{
		 char *name[] = {"D","R","A","W","I","N","G"," ","P","A","D"};
		 int i;
		 settextjustify(1,1);
		 settextstyle(4,0,7);
		 for(i=0;i<11;i++)
		 {
				 setcolor(i+2);
				 outtextxy(40+i*45,ycor, name[i]);
		 }
	}
	music()
	{
	int i  ;
	float octave[7] = { 830.81, 846.83, 864.81, 674.61, 596, 420, 1046.94 
} ;
	for ( i = 0 ; i < 7 ; i++ )
	{
		sound ( octave[i] * 5 ) ;
		delay ( 30 ) ;
	}
	nosound();
	}

	void Welcome()
	{
		 char pattern[8] = {0x00, 0x70, 0x12, 0x27, 0x00, 0x27, 0x20, 0x70};
		 int i;

		 setfillpattern(pattern,BLUE);
		 for(i=0;i<=320;i++)
		 {
			bar(320-i,240-i*0.75,320+i,240+i*0.75);
			delay (0.3) ;
		 }
		 settextjustify(1,1);
		 DisplayName(100);
		 settextstyle(5,0,4);
		 outtextxy(100,300,"Hello ");
		 settextstyle(7,0,6);
		 setcolor(11);
		 outtextxy(320,350,"World");
		 music();
		 delay(1000);
	}

	void main()
	{
	ifstream fs;
	ofstream ft;
	int gd= DETECT,gm;
	initgraph(&gd,&gm,"C:\tc\bgi");
	mainscreen();
	music();
	setviewport(1,31,638,478,1);
	mouse m;
	int button,x,y,flag=0;
	int t,i,index;
	int strptx,strpty,endptx,endpty;
	objarray arr;
	while(1)
	{
	button=0;
	m.getmousepos(button,x,y);
	if(((button &1)==1)&&(flag==0))
		for(t=5,i=0;t<=7*90;t+=90,i++)
			if(x>=t && x<=t+70 && y>=5 && y<=25)
			{
			index=i;
			flag=1;
			break;
			}
	int clmum=random(16);
	int sx=random(638);
	int sy=random(478);
	int ex=random(638);
	int ey=random(478);
	int r=random(200);

	switch(index)
	{
	case 0:
		m.getmousepos(button,x,y);
		if(((button &1)==0)&&(flag==1))
		{
		clearviewport();
		flag=0;
		}
		break;
	case 1:
		m.getmousepos(button,x,y);
		if(((button &1)==0)&&(flag==1))
		{
		fs.open("output.txt",ios::in);
		shapes *ptr;
		char a[2];
		while(fs)
		{
			fs>>a;
			if(strcmp(a,"L")==0)
			{
			myline *l=new myline();
			l->open(fs);
			arr.add(l);
			}

			if(strcmp(a,"R")==0)
			{
			myrectangle *r=new myrectangle();
			r->open(fs);
			arr.add(r);
			}

			if(strcmp(a,"C")==0)
			{
			mycircle *c=new mycircle();
			c->open(fs);
			arr.add(c);
			}
		}
		fs.close();
		int count=arr.getcount();
		for(int i=1;i<=count;i++)
		{
		ptr=(shapes*)arr.getobj(i);
		ptr->draw();
		}
		flag=0;
		}
		break;
	case 2:
		m.getmousepos(button,x,y);
		if(((button &1)==0)&&(flag==1))
		{
		ft.open("output.txt",ios::out);
		int count=arr.getcount();
		shapes *ptr;
		for(i=1;i<=count;i++)
		{
		ptr=(shapes*)arr.getobj(i);
		ptr->save(ft);
		}
		ft.close();
		flag=0;
		}
		break;

	case 3:
		m.getmousepos(button,x,y);
		if(((button &1)==0)&&(flag==1))
		{
		setcolor(clmum);
		moveto(sx,sy);
		lineto(ex,ey);
		myline *l=new myline(sx,sy,ex,ey,clmum);
		if(l==NULL)
			exit(1);
		arr.add(l);
		flag=0;
		}
		break;

	case 4:
		m.getmousepos(button,x,y);
		if(((button &1)==0)&&(flag==1))
		{
		setcolor(clmum);
		rectangle(sx,sy,ex,ey);
		myrectangle *r=new myrectangle(sx,sy,ex,ey,clmum);
		if(r==NULL)
			exit(1);
		arr.add(r);
		flag=0;
		}
		break;

	case 5:
		m.getmousepos(button,x,y);
		if(((button &1)==0)&&(flag==1))
		{
		setcolor(clmum);
		circle(sx,sy,r);
		mycircle *c=new mycircle(sx,sy,r,clmum);
		if(r==NULL)
			exit(1);
		arr.add(c);
		flag=0;
		}
		break;
	}
	if(index==6)
		break;
	}
	Welcome();
	closegraph();
	restorecrtmode();
	}
Hospital management database - Project Program for Hospital Database Queue array.

Code :


#include<iostream.h>
#include<conio.h>
#include<string.h>
#include<stdlib.h>

// define maximum number of patients in a queue
#define MAXPATIENTS 100

// define structure for patient data
struct patient
{
   char FirstName[50];
   char LastName[50];
   char ID[20];
};


// define class for queue
class queue
{
   public:
   queue (void);
   int AddPatientAtEnd (patient p);
   int AddPatientAtBeginning (patient p);
   patient GetNextPatient (void);
   int RemoveDeadPatient (patient * p);
   void OutputList (void);
   char DepartmentName[50];
   private:
   int NumberOfPatients;
   patient List[MAXPATIENTS];
};


// declare member functions for queue

queue::queue ()
{
   // constructor
   NumberOfPatients = 0;
}


int queue::AddPatientAtEnd (patient p)
{
   // adds a normal patient to the end of the queue.
   // returns 1 if successful, 0 if queue is full.
  if (NumberOfPatients >= MAXPATIENTS)
   {
      // queue is full
      return 0;
   }
      // put in new patient
      else
      List[NumberOfPatients] = p;  NumberOfPatients++;
      return 1;
}


int queue::AddPatientAtBeginning (patient p)
{
   // adds a critically ill patient to the beginning of the queue.
   // returns 1 if successful, 0 if queue is full.
   int i;
   if (NumberOfPatients >= MAXPATIENTS)
   {
      // queue is full
      return 0;
   }

   // move all patients one position back in queue
   for (i = NumberOfPatients-1; i >= 0; i--)
   {
      List[i+1] = List[i];
   }
   // put in new patient
   List[0] = p;  NumberOfPatients++;
   return 1;
}


patient queue::GetNextPatient (void)
{
   // gets the patient that is first in the queue.
   // returns patient with no ID if queue is empty

   int i;  patient p;
   if (NumberOfPatients == 0) {
   // queue is empty
   strcpy(p.ID,"");
   return p;}
   // get first patient
   p = List[0];
   // move all remaining patients one position forward in queue
   NumberOfPatients--;
   for (i=0; i<NumberOfPatients; i++)
   {
      List[i] = List[i+1];
   }
   // return patient
   return p;
}


int queue::RemoveDeadPatient (patient * p)
{
   // removes a patient from queue.
   // returns 1 if successful, 0 if patient not found
   int i, j, found = 0;
   // search for patient
   for (i=0; i<NumberOfPatients; i++)
	{
      		if (stricmp(List[i].ID, p->ID) == 0)
		{
	 	// patient found in queue
	 	*p = List[i];  found = 1;
	 	// move all following patients one position forward in queue
	 	NumberOfPatients--;
	 		for (j=i; j<NumberOfPatients; j++)
				{
	    				List[j] = List[j+1];
				}
		}
	}
   return found;
}


void queue::OutputList (void)
{
   // lists entire queue on screen
   int i;
   if (NumberOfPatients == 0)
	{
      		cout << "
Queue is empty";
	}
   else
	{

		for (i=0; i<NumberOfPatients; i++)
		{
			cout << "
" << List[i].FirstName;
	 		cout << " " << List[i].LastName;
	 		cout << " " << List[i].ID;
		}
	}
}


// declare functions used by main:

patient InputPatient (void)
{
   // this function asks user for patient data.
   patient p;
   cout << "

Please enter data for new patient
First name: ";
   cin.getline(p.FirstName, sizeof(p.FirstName));
   cout << "
Last name: ";
   cin.getline(p.LastName, sizeof(p.LastName));
   cout << "
Social security number: ";
   cin.getline(p.ID, sizeof(p.ID));
   // check if data valid
   if (p.FirstName[0]==0 || p.LastName[0]==0 || p.ID[0]==0)
	{
      		// rejected
      		strcpy(p.ID,"");
      		cout << "

Error: Data not valid. Operation cancelled.";
      		getch();
	}
   return p;
}


void OutputPatient (patient * p)
{
   // this function outputs patient data to the screen
   if (p == NULL || p->ID[0]==0)
	{
      		cout << "
No patient";
      		return;
	}
   else
   cout << "

Patient data:";
   cout << "

First name: " << p->FirstName;
   cout << "

Last name: " << p->LastName;
   cout << "

Social security number: " << p->ID;
}


int ReadNumber()
{
   // this function reads an integer number from the keyboard.
   // it is used because input with cin >> doesn't work properly!
   char buffer[20];
   cin.getline(buffer, sizeof(buffer));
   return atoi(buffer);
}


void DepartmentMenu (queue * q)
{
   // this function defines the user interface with menu for one
department
   int choice = 0, success;  patient p;
   while (choice != 6)
	{
      	   // clear screen
      	   clrscr();
      	   // print menu
      	   cout << "


Welcome to department: " << q->DepartmentName;
      	   cout << "

Please enter your choice:";
      	   cout << "

1:  Add normal patient";
      	   cout << "
2:  Add critically ill patient";
      	   cout << "
3:  Take out patient for operation";
      	   cout << "
4:  Remove dead patient from queue";
      	   cout << "
5:  List queue";
      	   cout << "
6:  Change department or exit
";
      	   // get user choice
      	   choice = ReadNumber();
      		// do indicated action
      	switch (choice)
	  {
      		case 1:   // Add normal patient
	 	p = InputPatient();
	 	if (p.ID[0])
		   {
	    		success = q->AddPatientAtEnd(p);
	    		clrscr();
	    		  if (success)
			    {
	       			cout << "
Patient added:

";

			    }
	        else
		   {
	       		// error
	       		cout << "

Error: The queue is full. Cannot add patient:";
		   }
	    		OutputPatient(&p);
	    		cout << "

Press any key";
	    		getch();
	  }
	 break;

      case 2:   // Add critically ill patient
	 p = InputPatient();
	 if (p.ID[0])
	     {
	    	success = q->AddPatientAtBeginning(p);
	    	clrscr();
	    	  if (success)
			{
	       		  cout << "
Patient added:

";
	     		}
	 	  else
	     		{
	       		  // error
	       		  cout << "

Error: The queue is full. Cannot add 
patient:";
			}

			  OutputPatient(&p);
	    		  cout << "

Press any key";
	    		  getch();
	     }
	 break;

      case 3:   // Take out patient for operation
	 p = q->GetNextPatient();
	 clrscr();
	 if (p.ID[0])
	    {
	       cout << "
Patient to operate:

";
	       OutputPatient(&p);}
	 else
	    {
	       cout << "
There is no patient to operate.";
	    }
	       cout << "

Press any key";
	       getch();
	       break;

      case 4:   // Remove dead patient from queue
	 p = InputPatient();
	 if (p.ID[0])
	   {
	        success = q->RemoveDeadPatient(&p);
	        clrscr();
	          if (success)
		      {
	       		cout << "
Patient removed:

";
		      }
	    	  else
		      {
	       		// error
	       		cout << "

Error: Cannot find patient:

";
		      }
	   	OutputPatient(&p);
	    	cout << "

Press any key";
	    	getch();
	   }
	 break;

      case 5:   // List queue
	 clrscr();
	 q->OutputList();
	 cout << "

Press any key";
	 getch();  break;
	 }
      }
}


// main function defining queues and main menu
void main ()
{
   int i, MenuChoice = 0;
   // define three queues
   queue departments[3];
   // set department names
   strcpy (departments[0].DepartmentName, "Heart clinic");
   strcpy (departments[1].DepartmentName, "Lung clinic");
   strcpy (departments[2].DepartmentName, "Plastic surgery");

   while (MenuChoice != 4)
	{
      	   // clear screen
      	   clrscr();
      	   // print menu
      	   cout << "


Welcome to Software City Hospital";
      	   cout << "

Please enter your choice:
";
          for (i = 0; i < 3; i++)
		{
	 	   // write menu item for department i
	 	   cout << "
" << (i+1) << ":  " << departments[i].DepartmentName;
		}
      	  cout << "
4:  Exit
";
      	  // get user choice
      	  MenuChoice = ReadNumber();
      	  // is it a department name?
      		if (MenuChoice >= 1 && MenuChoice <= 3)
		    {
	 		// call submenu for department
	 		// (using pointer arithmetics here:)
	 		DepartmentMenu (departments + (MenuChoice-1));
		    }
	}
}


Office management

It is a simple project made in c++,it has not got ny type of
graphics as simple as stick so plz try and use the software in ur
office frontier to ad or modify or delete the employyers details
try once.......... give me ur reply on my email 

#include<DOS.h>
#include<fstream.h>
#include<conio.h>
#include<string.h>
#include<stdio.h>
int count =0;
class emp
{
char name[40];
char jobdeg[40],phno[20];
float salary,srno;
public:
void getdata(void);
void display(void);
void mod_data();
};
void emp::getdata(void)
{
char ch;
cin.get(ch);
clrscr();
gotoxy(15,10);
cout<<"Add student data
";
gotoxy(17,12);
cout<<"Record #"<<(++count)<<endl;
gotoxy(1,14);
for(int i=0;i<40;i++)name[i]=' ';
salary=0.0;srno=0.0;
//jobdeg=;phno='asd';
cout<<"
 Enter the Serial no";cin>>srno;
cout<<"
 Enter Name";
gets(name);
cout<<"
 Enter Job designation";gets(jobdeg);
cout<<"
 Enter Phone number";gets(phno);
cout<<"
 Enter the Salary";cin>>salary;
cout<<"
";
}
void emp::display(void)
{
clrscr();
gotoxy(15,10);
cout<<"Student Details
 ";
gotoxy(1,12);
cout<<"
 Sr. NO  "<<srno<<"
 Name  "<<name<<""<<"
 Salary
"<<salary<<"
 Job designation  "<<jobdeg<<"	
 Phone no  "<<phno;
}
void emp::mod_data(void)
{
char nm[40],jd[40],ph[20];
float sal,sr;
clrscr();
gotoxy(15,8);
cout<<"Modify Employee's data";
char ch=cin.get();cout<<ch;
clrscr();
gotoxy(17,10);
cout<<"Current details are";
gotoxy(17,12);
cout<<"
 Sr.No. :-"<<srno<<"	
	Name:-"<<name<<"	
Job
designation"<<jobdeg<<"	
Salary"<<salary<<"	
Contact no"<<phno;
gotoxy(17,18);
cout<<"
Enter the new details";
cout<<"
 Serial no";cin>>sr;
cout<<"
 Name";gets(nm);
cout<<"
 Job designation ";gets(jd);
cout<<"
 Salary";cin>>sal;
cout<<"
 Phone number";gets(ph);
if(strlen(nm)!=0)strcpy(name,nm);
if(strlen(jd)!=0)strcpy(jobdeg,jd);
if(strlen(ph)!=0)strcpy(phno,ph);
if(sal>salary||sal<salary)salary=sal;
if(sr>srno||sr<srno)srno=sr;
clrscr();
}
int main()
{
clrscr();
emp empl;
fstream finout;
finout.open("empdl.dat",ios::in|ios::out|ios::binary);
if(!finout)
{
cout<<"Cannot open the file!!!";
return 1;
}
int choice ,merc=0,offset=0;
char ans;
do
{
clrscr();
if(count==0)
{
int r,c;
		clrscr();
	       /* Introduction with Swastik*/
		 textcolor(YELLOW);
	clrscr();

	for(r=5;r<20;r++)
       {
	 delay(100);
	  gotoxy(34,r);
	    cout<<"*";
	     }

  for(c=16;c<55;c=c+2)
  {
   delay(100);
   gotoxy(c,12);
    cout<<"*";
    }

for(c=35;c<55;c=c+2)
 {
  delay(100);
  gotoxy(c,5);
   cout<<"*";
  }

 for(c=34;c>15;c=c-2)
  {
   delay(100);
   gotoxy(c,20);
    cout<<"*";
 }

 for(r=12;r<21;r++)
  {
   delay(100);
   gotoxy(55,r);
    cout<<"*";
  }

 for(r=12;r>4;r=r-1)
  {
     delay(100);
     gotoxy(15,r);
      cout<<"*";
   }

for(r=8;r<=8;r++)
  {
    delay(10);
    gotoxy(25,r);
     cout<<"*";
  }

for(r=8;r<=8;r++)
  {
   delay(10);
   gotoxy(45,r);
    cout<<"*";
  }

for(r=16;r<=16;r++)
  {
    delay(10);
    gotoxy(25,r);
     cout<<"*";
  }

  for(r=16;r<=16;r++)
  {
   delay(10);
   gotoxy(45,r);
    cout<<"*";
  }
  delay(1400);
  clrscr();
/* OFFICE MANAGEMENT */
delay(300);
		cout<<"









			O ";
		delay(300);
		cout<<"F ";
		delay(300);
		cout<<"F ";
		delay(300);
		cout<<"I ";
		delay(300);
		cout<<"C ";
		delay(300);
		cout<<"E ";
		delay(300);
		cout<<"  M ";
		delay(300);
		cout<<"A ";
		delay(300);
		cout<<"N ";
		delay(300);
		cout<<"A ";
		delay(300);
		cout<<"G";
		delay(300);
		cout<<" E";
		delay(300);
		cout<<" M";
		delay(300);
		cout<<" E";
		delay(300);
		cout<<" N";
		delay(300);
		cout<<" T ";
		delay(300);
		cout<<" ****** ";
		delay(300);
		cout<<"   ... ";
		delay(1400);
cout<<"a
 






			 PRESS ANY KEY ........ ";

for(c=1;c<80;c++)
{
  delay(10);
  gotoxy(c,1);
  cout<<"&";
  }

for(r=1;r<26;r++)
 {
  delay(10);
  gotoxy(1,r);
  cout<<"&&";
 }

for(c=26;c<102;c++)
{
  delay(10);
  gotoxy(c,26);
  cout<<"&";
}

for(r=1;r<26;r++)
{
  delay(10);
  gotoxy(78,r);
  cout<<"&&";
}
getch();
}
clrscr();
textcolor(CYAN);
cout<<"
	

 Main menu";
cout<<"		______________";
cout<<"
 1.Add record";
cout<<"
 2.Modify record";
cout<<"
 3.Display record";
cout<<"
 4.Exit.......
 ";
cin>>choice;
switch(choice)
{
case 1:empl.getdata();
       merc=count;
       offset=((merc-1)*sizeof(emp));
       finout.seekp(offset,ios::beg);
       finout.write((char*) &empl,sizeof(emp));
       break;
case 2:if(!count)
{      gotoxy(20,20);
       cout<<" No record has been added yet!!!!
 plz run option 1
first!!!!";
       cout<<"Press any key to continue.........";
       getch();
       break;
}
       cout<<"Modify which record";
       cin>>merc;
       if( merc>count)
{
       cout<<"


 Only  "<<count<<"  These many records are added";
       cout<<"
 
 Invalid record number!!!!";
       gotoxy(20,20);
       cout<<"Press any key to continue!!!!!";
       getch();
       break;
}
       else
       {
       offset=(merc-1)*sizeof(emp);
       finout.seekg(offset,ios::beg);
       finout.read((char*)&empl,sizeof(emp));
       empl.display();
       cout<<"Modify this record?(y/n)";
       cin>>ans;
       if(ans=='y'||ans=='Y')
       {
       cout<<"Enter new details";
       empl.mod_data();
       finout.seekp(offset,ios::beg);
       finout.write((char*) &empl,sizeof(emp));
       cout<<"Record modified!!!!!";
       gotoxy(20,20);
       cout<<"Press any key to continue!!!!!!!!";
       getch();
       }
       break;
       }
case 3:
       if(!count)
       {
       cout<<"


 No record has been added yet";
       cout<<"Please run the optionm 1 first on the main screen";
       gotoxy(10,20);
       cout<<"press any key to continue";
       getch();
       break;
       }
       cout<<"
 
 Display which record";
       cin>>merc;
       cout<<endl;
       if( merc>count)
{
       cout<<"


 Only  "<<count<<"  These many records are added";
       cout<<"
 
 Invalid record number!!!!";
       gotoxy(20,20);
       cout<<"Press any key to continue!!!!!";
       getch();
       break;
}
       else
       {
       offset=(merc-1)*sizeof(emp);
       finout.seekg(offset,ios::beg);
       finout.read((char*)&empl,sizeof(emp));
       empl.display();
       gotoxy(10,20);
       cout<<"Press any key to continue!!!!!!!";
       getch();
       }
       break;
case 4:break;
default :cout<<"Wrong choice!!!! valid choice ar only 1-4";
	 break;
}
}while(choice>=1&& choice<=3);
finout.close();
return 0;
}

This is program which can be used by distributor to maintain the stock & account.

#include <iostream.h>
#include <graphics.h>
#include <dos.h>
#include <conio.h>
#include <stdlib.h>
#include <stdio.h>


class SHOP
{

private :
	int z,P1,P2,P3,P4,P5,P6,P7,P8,totalP;
	int S1,S2,S3,S4,S5,S6,S7,S8,S9,totalS;
	int D1,D2,D3,D4,D5,D6,D7,D8,totalD;
	int s1,s2,s3,s4,s5,s6,s7,s8,totals;
	int p1,p2,p3,p4,p5,p6,p7,p8,totalp;

public :
	void FRONT()
  {
	totals=totalp=totalP=totalS=0;
	P1=P2=P3=P4=P5=P6=P7=P8=0;
	S1=S2=S3=S4=S5=S6=S7=S8=0;
	p1=p2=p3=p4=p5=p6=p7=p8=0;
	s1=s2=s3=s4=s5=s6=s7=s8=0;
	z=0;

//MAIN
SCREEN********************************************************************

switching:

    {
	int gdriver = DETECT, gmode;
	initgraph(&gdriver, &gmode, "C:\TC\BGI");
	cleardevice();
	setcolor(getmaxcolor());
	textcolor(getmaxcolor());
	settextjustify(CENTER_TEXT, CENTER_TEXT);
	settextstyle(10,0,4);
	outtextxy(320,25,"ZINNIA DISTRIBUTOR");
	setcolor(13);
	rectangle(0,0,639,70);
	rectangle(2,2,637,68);
	rectangle(4,4,635,66);
	rectangle(220,140,420,340);
	rectangle(223,143,417,337);
	gotoxy(33,12);
	cout<<"1)  PURCHASE";
	gotoxy(33,14);
	cout<<"2)  SALES";
	gotoxy(33,16);
	cout<<"3)  REPORT";
	gotoxy(33,18);
	cout<<"4)  EXIT";
	gotoxy(32,28);
	cout<<"YOUR CHOICE IS : ";
	rectangle(200,420,440,460);
	rectangle(202,422,438,458);
	setfillstyle(10,13);
	floodfill(1,75,13);
	cin>>z;
	cleardevice();

switch(z)

      {
case 1:
//PURCHASE***************************************************************
	{

cout<<"
_________________________________________________________________
_______________";
	cout<<"

 SNO               ITEM                   RATE		    QTY
AMOUNT   ";

cout<<"
_________________________________________________________________
_______________";
	cout<<"

 1]                WHOLE                   55      ";
	cout<<"

 2]                PRE-CUT                 60      ";
	cout<<"

 3]                ASSORTED                35      ";
	cout<<"

 4]                SOUP                    10      ";
	cout<<"

 5]                WINGS                   55      ";
	cout<<"

 6]                GIZZARD                 45      ";
	cout<<"

 7]                TWO LEGS                90      ";
	cout<<"

 8]                FOUR DRUMS              30      ";

cout<<"

_______________________________________________________________
_________________";
	cout<<"


                                                  TOTAL ----->     
Rs.";

cout<<"

_______________________________________________________________
_________________";
	rectangle(0,0,639,479);
	rectangle(530,400,635,440);
	settextstyle(10,0,4);
	outtextxy(210,410,"PURCHASE");
	gotoxy(62,8);
	cin>>P1;
	p1=p1+P1;
	gotoxy(62,10);
	cin>>P2;
	p2=p2+P2;
	gotoxy(62,12);
	cin>>P3;
	p3=p3+P3;
	gotoxy(62,14);
	cin>>P4;
	p4=p4+P4;
	gotoxy(62,16);
	cin>>P5;
	p5=p5+P5;
	gotoxy(62,18);
	cin>>P6;
	p6=p6+P6;
	gotoxy(62,20);
	cin>>P7;
	p7=p7+P7;
	gotoxy(62,22);
	cin>>P8;
	p8=p8+P8;
	gotoxy(75,8);
	D1=P1*55;
	cout<<D1;
	gotoxy(75,10);
	D2=P2*60;
	cout<<D2;
	gotoxy(75,12);
	D3=P3*35;
	cout<<D3;
	gotoxy(75,14);
	D4=P4*10;
	cout<<D4;
	gotoxy(75,16);
	D5=P5*55;
	cout<<D5;
	gotoxy(75,18);
	D6=P6*45;
	cout<<D6;
	gotoxy(75,20);
	D7=P7*90;
	cout<<D7;
	gotoxy(75,22);
	D8=P8*30;
	cout<<D8;
	gotoxy(75,27);
	totalP=D1+D2+D3+D4+D5+D6+D7+D8;
	totalp=totalp+totalP;
	cout<<totalP;
	getch();
	goto switching;
	}

case 2:
//SALES*******************************************************************
**
	{

cout<<"
_________________________________________________________________
_______________";
	cout<<"

 SNO               ITEM                   RATE		    QTY
AMOUNT   ";

cout<<"
_________________________________________________________________
_______________";
	cout<<"

 1]                WHOLE                   60      ";
	cout<<"

 2]                PRE-CUT                 65      ";
	cout<<"

 3]                ASSORTED                40      ";
	cout<<"

 4]                SOUP                    15      ";
	cout<<"

 5]                WINGS                   60      ";
	cout<<"

 6]                GIZZARD                 50      ";
	cout<<"

 7]                TWO LEGS                95      ";
	cout<<"

 8]                FOUR DRUMS              35      ";

cout<<"

_______________________________________________________________
_________________";
	cout<<"


                                                  TOTAL ----->     
Rs.";

cout<<"

_______________________________________________________________
_________________";
	rectangle(0,0,639,479);
	rectangle(530,400,635,440);
	settextstyle(10,0,4);
	outtextxy(210,410,"SALES");
	gotoxy(62,8);
	cin>>S1;
	s1=s1+S1;
	gotoxy(62,10);
	cin>>S2;
	s2=s2+S2;
	gotoxy(62,12);
	cin>>S3;
	s3=s3+S3;
	gotoxy(62,14);
	cin>>S4;
	s4=s4+S4;
	gotoxy(62,16);
	cin>>S5;
	s5=s5+S5;
	gotoxy(62,18);
	cin>>S6;
	s6=s6+S6;
	gotoxy(62,20);
	cin>>S7;
	s7=s7+S7;
	gotoxy(62,22);
	cin>>S8;
	s8=s8+S8;
	gotoxy(75,8);
	D1=S1*60;
	cout<<D1;
	gotoxy(75,10);
	D2=S2*65;
	cout<<D2;
	gotoxy(75,12);
	D3=S3*40;
	cout<<D3;
	gotoxy(75,14);
	D4=S4*15;
	cout<<D4;
	gotoxy(75,16);
	D5=S5*60;
	cout<<D5;
	gotoxy(75,18);
	D6=S6*50;
	cout<<D6;
	gotoxy(75,20);
	D7=S7*95;
	cout<<D7;
	gotoxy(75,22);
	D8=S8*35;
	cout<<D8;
	gotoxy(75,27);
	totalS=D1+D2+D3+D4+D5+D6+D7+D8;
	totals=totals+totalS;
	cout<<totalS;
	getch();
	cleardevice();
	goto switching;
	}

case 3:
//REPORT******************************************************************
*
	{

cout<<"___________________________________________________________________
_____________";
	cout<<"
 SNO                ITEM             PURCHASE         SALES
STOCK LEFT";

cout<<"
_________________________________________________________________
_______________";
	cout<<"
 1]                WHOLE		"<<p1<<"		"<<s1<<"		"<<p1-s1;
	cout<<"
 2]                
PRE-CUT		"<<p2<<"		"<<s2<<"		"<<p2-s2;
	cout<<"
 3]                
ASSORTED		"<<p3<<"		"<<s3<<"		"<<p3-s3;
	cout<<"
 4]                
SOUP			"<<p4<<"		"<<s4<<"		"<<p4-s4;
	cout<<"
 5]                WINGS		"<<p5<<"		"<<s5<<"		"<<p5-s5;
	cout<<"
 6]                
GIZZARD		"<<p6<<"		"<<s6<<"		"<<p6-s6;
	cout<<"
 7]                TWO 
LEGS		"<<p7<<"		"<<s7<<"		"<<p7-s7;
	cout<<"
 8]                FOUR
DRUMS		"<<p8<<"		"<<s8<<"		"<<p8-s8;

cout<<"
_________________________________________________________________
_______________";
	cout<<"


	PURCHASE           : Rs."<<totalp;
	cout<<"

	SALES              : Rs."<<totals;
	cout<<"

	PROFIT             : Rs."<<(s1+s2+s3+s4+s5+s6+s7+s8)*5;
	cout<<"


	BALANCE ON COUNTER : Rs. ";
	if((totals-totalp)<0)
	  {
	  cout<<-(totals-totalp)<<" CREDIT

";
	  }
	else
	  {
	  cout<<(totals-totalp)<<" DEBIT

";
	  }
	rectangle(0,0,639,479);
	rectangle(50,300,370,470);
	rectangle(55,425,365,455);
	rectangle(52,302,368,468);
	settextstyle(10,0,4);
	outtextxy(320,20,"REPORT");
	getch();
	cleardevice();
	goto switching;
	}

case 4:
//EXIT THE
PROGRAM******************************************************************
	{
	exit(0);
	}

default :
//DEFAULT*****************************************************************
*
	{
	goto switching;
	}
      }
    }
  }
};


//MAIN
PROGRAM******************************************************************

void main()
{
clrscr();
SHOP a;
a.FRONT();
getch();
}
Program to convert decimal no. to binary, gray code & its

It is an program to convert an decimal no. entered by the user into its equivalent binary no.,
gray code& excess3 code useful in the microelectronics.

Code :
/* Program to convert decimal no.
 to its equivalent binary ,gray code & excess3 code

*/
#include<iostream.h>
#include<conio.h>
int deci,bits=0,deci_x3,bits_x3;
int array[100][20];
int array1[100][20];
int array2[100][20];
void binary(int [100][20],int,int,int);
void gray(int);
void display(int);
int find_bits(int);

void main()
{
textcolor(GREEN);
textbackground(BLUE);
clrscr();
cout<<"Enter the no. upto which gray code and excess 3 code is to be
generated :  ";
cin>>deci;
bits=find_bits(deci);
deci_x3=deci+3;
bits_x3=find_bits(deci_x3);
for(int i2=0;i2<=deci;i2++)
{
for(int j2=0;j2<=bits;j2++)
{
array[i2][j2]=0;
array1[i2][j2]=0;
}
}
array2[0][bits_x3-1]=1;
array2[0][bits_x3-2]=1;
for( i2=1;i2<=deci_x3;i2++)
{
for(int j2=0;j2<=bits_x3;j2++)
{
array2[i2][j2]=0;
}
}
cout<<"    DECI NO.       BINARY EQ.         GRAY CODE       EXCESS 3";
cout<<endl<<"-------------------------------------------------------------
--";
display(0);
getch();
for(int i=1;i<=deci;i++)
{
binary(array,i,bits,0);
gray(i);
binary(array2,i,bits_x3,1);
display(i);
getch();
}
}


void binary(int array_bin[20][20],int i,int bits2,int flag)
{
int ix;
if(flag==1)
ix=i+3;
else
ix=i;
array_bin[i][bits2-1]=(array_bin[i-1][bits2-1]==0?1:0);
for(int k1=2,i1=2;k1<=bits2;k1++,i1*=2)
{
if((ix/i1)%2==0)
array_bin[i][bits2-k1]=0;
else
array_bin[i][bits2-k1]=1;
}
}



void gray(int i)
{
		  //FIXING THE HIGHEST ORDER BIT FIRST
array1[i][0]=array[i][0];
for(int j=1;j<bits;j++)
{
if((array[i][j-1]==0&&array[i][j]==0)||(array[i][j-1]==1&&array[i][j]==1))
array1[i][j]=0;
else
array1[i][j]=1;
}
}

void display(int m)
{
cout<<endl;
if(m<=9)
cout<<"    "<<m<<"                "   ;
else
cout<<"    "<<m<<"               "   ;
for(int j=0;j<bits;j++)
cout<<array[m][j];
cout<<"               " ;
for( j=0;j<bits;j++)
cout<<array1[m][j];
cout<<"             ";
for( j=0;j<bits_x3;j++)
cout<<array2[m][j];
}



int find_bits(int m)
{
int k,bits1=0;
do
{
bits1++;
 k=1;
for(int i=1;i<=bits1;i++)
k=k*2;
}
while(k<=m);
return(bits1);
}


Program to Print Some Special Characters.

Program is compiled in Visual C++ 6.0. If you have this
one then compile it and you can see the codes of the some special
characters which are not available on keyboard.........

#include<iostream.h>
void main()
{cout<<"	xAA	xAB	xAC	xAD	xAE	xAF
";
 cout<<"	xBA	xBB	xBC	xBD	xBE	xBF
";
 cout<<"	xCA	xCB	xCC	xCD	xCE	xCF
";
 cout<<"	xDA	xDB	xDC	xDD	xDE	xDF
";
 cout<<"	xEA	xEB	xEC	xED	xEE	xEF
";
 cout<<"	xFA	xFB	xFC	xFD	xFE	xFF
";
}
Program to set on off the caps lock, scrolllock, numlock.

	#include"stdio.h"
	#include"conio.h"

	void main()
	{
		char ch;
		char far *memory1=(char far *)0x417;
		char far *memory2=(char far *)0x418;

		clrscr();
		printf("

		  'C' -=:=- CapsLock.");
		printf("
		  'N' -=:=- NumLock.");
		printf("
		  'S' -=:=- ScrollLock.");
		printf("
		<ESC> -=:=- Escape");

		while(1)
		{
			ch=getch();
			if(ch==0x1b)
				break;

			switch(ch)
			{
				case 'c':
				case 'C':
					*memory1=*memory1 ^ 64;
					break;
				case 'n':
				case 'N':
					*memory1=*memory1 ^ 32;
					break;
				case 's':
				case 'S':
					*memory1=*memory1 ^ 16;
					break;
			}
		}
	}
Railway seat reservation question which comes in sapient

#include<iostream.h>
#include<conio.h>
#include<stdio.h>

struct rail
{

	int seatNo;
	int isEmpty;

}seat[67];

void reserve(int n);
int arrRowState[15];

void main()
{
	for(int i = 0 ; i <67 ; i++)
	{
	   seat[i].seatNo=(i+1);
	   seat[i].isEmpty=1;
	}
	for(i=0 ; i<13 ; i++)
	   arrRowState[i]=5;

	arrRowState[13]=2;
	arrRowState[14]=67;

	char res='y';
	do
	{
		int n;
		clrscr();
		cout<<"Enter d no of seats u want to reserve : ";
		cin>>n;
		reserve(n);
		cout<<"


Do u want to reserve more seats?";
		res=getchar();
	}while(res!='n');
}

void reserve(int n)
{
	if(n>arrRowState[14])
	{
		cout<<"Too large group to accomodate";
		getch();
		return;
	}

	int flag=0;
	int seatbook;
	for(int i = 0 ; flag==0&&i<=13 ; i++)
	{
		if(arrRowState[i] >= n)
		{
			flag=1;
		    //	cout<<"Following Seats Alloted";
			seatbook=(((i)*5)+(6-arrRowState[i]));
			for(int j = 0 ; j < n ; j++)
			{
				cout<<"
"<<seatbook+j<<"
";
				seat[(seatbook+j)].isEmpty=0;
			}
			arrRowState[i]=arrRowState[i]-n;
			arrRowState[14]=arrRowState[14]-n;
		}
	}
	if(flag==0)
	{
		while(n!=0)
		{
			int max,rowNo=0;
			max=arrRowState[0];
			for( int j = 0 ; j<14 ; j++)
			{
				if(arrRowState[j] > max)
				{
					max=arrRowState[j];
					rowNo=j;
				}

			}
			if(n>max)
			{
				n=n-max;
				seatbook=(((rowNo)*5)+(6-arrRowState[rowNo]));
				arrRowState[rowNo]=arrRowState[rowNo]-max;
				for( int j = 0 ; j<max ; j++)
				{
				   cout<<"
"<<(seatbook+j)<<"
";
				   seat[(seatbook+j)].isEmpty=0;
				}
			}
			else
			{
			    reserve(n);
			    n=0;
			}

		}

	}

	getch();
}
Simple calculater program

Code :
#include <iostream>
#include <conio.h>
#include <stdlib.h>
#include <dos.h>
#include <math.h>


using namespace std;
int main(int argc, char* argv[])
{

        float input1;
        float input2;
        double output;
        char what;
        char num1[34];
        char num2[34];
        gotoxy(15,1);
        cout<<"welcome to the calculater program"<<endl;
        sleep(5);
        clrscr();

        clrscr();
        for(;;)
        {
        clrscr();
        cout<<"enter the first number:"<<endl;
        cin>>num1;
        input1=atof(num1);
        clrscr();
        cout<<"enter the second number:"<<endl;
        cin>>num2;
        input2=atof(num2);
        clrscr();
        cout<<"enter
opearation
+.add
-.minus
*.multiply
/.divide
s.square
root
e.exitt"<<endl;
        cin>>what;
        switch(what)
        {
                case'+':
                output=input1+input2;
                clrscr();
                cout<<input1<<what<<input2<<"="<<output<<endl;
                system("PAUSE");;
                break;

                case'-':
                output=input1-input2;
                clrscr();
                cout<<input1<<what<<input2<<"="<<output<<endl;
                system("PAUSE");
                break;

                case'*':
                output=input1*input2;
                clrscr();
                cout<<input1<<what<<input2<<"="<<output<<endl;
                system("PAUSE");
                break;

                case'/':
                output=input1/input2;
                clrscr();
                cout<<input1<<what<<input2<<"="<<output<<endl;
                system("PAUSE");
                break;

                case's':
                case'S':
                output=sqrt(input1);
                clrscr();
                cout<<"the square root of "<<input1<<" is 
"<<output<<endl;
                system("PAUSE");
                break;

                default:
                cout<<"ok"<<endl;
                system("PAUSE");
                exit(0);
        }
        }
        system("PAUSE");

        return 0;
Simple Calculator in C++


#include"stdio.h"
#include"conio.h"
#include"dos.h"
#include"stdlib.h"
#include"string.h"

void DISPNUM(char *);
void main()
{
	clrscr();

	_setcursortype(0);
	gotoxy(30,19);
	textcolor(GREEN+BLINK);
	cprintf("SIMPLE CALCULATOR");
	gotoxy(50,21);
	textcolor(BLUE+BLINK);
	cprintf("Hello World");
	getch();
//	clrscr();

	int x=30,y=10;

	textcolor(WHITE);
	gotoxy(x,y);
	cprintf("7    8    9");
	gotoxy(x,y+2);
	cprintf("4    5    6");
	gotoxy(x,y+4);
	cprintf("1    2    3");
	gotoxy(x,y+6);
	cprintf("0");

	textcolor(RED);
	gotoxy(x+5,y+6);
	cprintf(".    =");


	textcolor(GREEN);
	x=x+15;
	gotoxy(x,y);
	cprintf("/");

	gotoxy(x,y+2);
	cprintf("*");

	gotoxy(x,y+4);
	cprintf("-");

	gotoxy(x,y+6);
	cprintf("+");

//Draw The For Calc//
	x=28;y=5;
	gotoxy(x,y);

	textcolor(WHITE);

	//  ?	     & 		? //
	cprintf("%c",218);
	gotoxy(28+20,y);
	cprintf("%c",191);
	//  ?	     & 		? //

//Horiz. Boundary
	for(x=29;x<=28+19;x++)
	{
		gotoxy(x,y);
		cprintf("%c",196);
		gotoxy(x,y+12);
		cprintf("%c",196);
	}
//End of Horiz. Bound

//  ?  		    &           ?  //
	cprintf("%c",217);
	x=28;y=y+12;
	gotoxy(x,y);
	cprintf("%c",192);
//End of  ?  		    &           ?  //

//Vertic. Bound.

	for(y=6;y<=16;y++)
	{
		gotoxy(x,y);
		cprintf("%c",179);
		gotoxy(x+20,y);
		cprintf("%c",179);
	}
//End of Vertic Bou.

	y=6;

	for(x=30;x<=30+16;x++)
	{
		gotoxy(x,y);
		cprintf("%c",196);
		gotoxy(x,y+2);
		cprintf("%c",196);
	}

	gotoxy(30,y+1);
	cprintf("%c               %c",179,179);

	gotoxy(30,y);
	cprintf("%c",218);
	gotoxy(30+16,y);
	cprintf("%c",191);


	gotoxy(30,y+2);
	cprintf("%c",192);
	gotoxy(30+16,y+2);
	cprintf("%c",217);


//End of Vertic Bound.

	//OutPut at X=30,Y=8//


	char ch;
char operand1[15]="",operand2[15]="",BLANK[15]="            ";
	char operator1,first='y';
	long double num1=0,num2=0;
	int i=0,ERROR=0; //Digits
	int MAX=10;
	DISPNUM(0);
	do
	{
		ch=getch();
		if(ch=='x1b')
		{
			for(int i=1000;i>=200;i=i-50)
			{
				sound(i);
				delay(100);
			}
			nosound();
			break;
		}

		//Numeric//
		if((ch>='0')&&(ch<='9'))
		{
			if(i<MAX)
			{
				if(first=='y')
				{
					operand1[i]=ch;
					DISPNUM(operand1);
					i++;
				}
				else
				{
					operand2[i]=ch;
					DISPNUM(operand2);
					i++;
				}
			}
			else		//More than 8 digit
			{
				ERROR=1;
			}
		}
		else if(ch=='.')
		{
			if(first=='y')
			{
				if(strchr(operand1,'.')==NULL)
				{
					operand1[i]=ch;
					i++;
				}
				DISPNUM(operand1);
			}
			else
			{
				if(strchr(operand2,'.')==NULL)
				{
					operand2[i]=ch;
					i++;
				}
				DISPNUM(operand2);
			}
		}
		//Non Numeric
		else if (ch=='*')
		{
			operator1='*';
			first='n';
			i=0;
		}
		else if (ch=='/')
		{
			operator1='/';
			first='n';
			i=0;
		}
		else if (ch=='+')
		{
			operator1='+';
			first='n';
			i=0;
		}
		else if (ch=='-')
		{
			operator1='-';
			first='n';
			i=0;
		}
		else if ((ch=='=')||(ch=='
'))
		{
			//Store in Floating
			if(strcmpi(operand1,BLANK)!=0)
			{
				num1=_atold(operand1);
			}
			if(strcmpi(operand2,BLANK)!=0)
			{
				num2=_atold(operand2);
			}
			//Now Calculate
			switch (operator1)
			{
				case '+':
					num1=num1+num2;
					break;
				case '-':
					num1=num1-num2;
					break;
				case '*':
					num1=num1*num2;
					break;
				case '/':
					num1=num1/num2;
					break;
			}
			//ltoa(num1,operand1,10);
			gcvt(num1,12,operand1);
			DISPNUM(operand1);
			i=0;
			first='y';

			strcpy(operand1,BLANK);
			strcpy(operand2,BLANK);
		}
		else              //Invalid Choice
		{
			ERROR=1;
		}

//Beep On ERROR else ------ //
		if (ERROR==0)
		{
			sound(920);
		}
		else
		{
			sound(100);
			ERROR=0;
		}
		delay(250);
		nosound();

		gotoxy(1,1);
		cprintf("%d",i);

	}while(1);


//	clrscr();
	gotoxy(30,19);
	textcolor(GREEN+BLINK);
	cprintf("SIMPLE CALCULATOR");
	gotoxy(50,21);
	textcolor(BLUE+BLINK);
	cprintf("Hello World");
//	getch();
}
void DISPNUM(char *num)
{
	textbackground(RED);
	gotoxy(31,7);
	cprintf("               ");
	gotoxy(31,7);
	cprintf("%s",num);
}
To calculate percentile

Write a program for the problem: the array of
inetegers indicating the marks of the students is
given, U have to calculate the percentile of the
students aaccording to this rule: the percentile of a
student is the %of no of student having marks less
then him. For eg:
suppose

Student Marks
A 12
B 60
C 80
D 71
E 30
F 45


percentile of C = 5/5 *100 = 100 (out of 5 students 5
are having marks less then him)

percentile of B = 3/5*100 = 60% (out of 5, 3 have
markses less then him)

percentile of A = 0/5*100 = 0%.

#include<iostream.h>
#include<conio.h>

  void main()
  {
    clrscr();
    int a[10],n,i,j;
    int percent;
    int count;
    cout<<"
 enter the size of array";
    cin>>n;
   cout<<"
 enter the values";
    for(i=0;i<=n-1;i++)
    {
       cout<<" a["<<i<<"]"<<"=";
       cin>>a[i];
    }

    for( i=0;i<=n-1;i++)
     { count=0;
     for(j=0;j<=n-1;j++)
     {  if(a[i]>a[j])
	{
	count=count+1;
	}
	}
	percent=(count*100)/(n-1);
     cout<<"

 the percentile of"<<"a["<<i<<"]"<<percent;
     }
     getch();

     }
Program to perform various operation on a vector using operator overloading

This Program deals with the basic operation like
Addition(+),
Subtraction(-), Dot Product, Cross Product etc. on Two 3-D vectors.


#include "Vector.cpp"

void main()
{
	system("cls");
	Vector A,B,C;
	int k,ch;
	char choice = 'y';
	do
	{
		if(choice == 'y' || choice == 'Y')
		{
			cout<<"
	INPUT VECTOR
";
			cout<<"
ENTER THE FIRST VECTOR.
";
			A.GetData();
			cout<<"
ENTER THE SECOND VECTOR.
";
			B.GetData();
		}

		system("cls");
		cout<<"
		PROGRAM FOR VECTOR OPERATIONS.
";
		cout<<"

First Vector(A)= "<<A<<"	Second Vector(B)= "<<B<<"

";
		cout<<"	1.Addition Of Two Vectors.
";
		cout<<"	2.Subtraction Of Two Vectors.
";
		cout<<"	3.Multiplication Of A Vector With The Scalar.
";
		cout<<"	4.Cross Product Of Two Vectors.
";
		cout<<"	5.Scalar(or Dot) Product Of Two Vectors.
";
		cout<<"	6.Negative Of Vectors.
";
		cout<<"	7.Exit
";
		cout<<"	
Enter The Choice. ";
		cin>>ch;
	    switch(ch)
		{
			case 1:
				cout<<"
ADDITION OF TWO VECTORS.
";
				C = A + B;
				cout<<"
The Value Of A+B Is: "<<C;
				break;
			case 2:
				cout<<"
SUBTRACTION OF TWO VECTORS.
";
				C = A - B;
				cout<<"
The Value Of A-B Is: "<<C;
				break;
			case 3:
				cout<<"
MULTIPLICATION OF A VECTOR WITH A SCALAR.
";
				cout<<"
Enter The Value Of The Scalar: ";
				cin>>k;
				C = A * k;
				cout<<"
The Value Of Ak Is (k Is the Scaler): "<<C;
				C = k * B;
				cout<<"
The Value Of kB Is (k Is the Scaler): "<<C;
				break;
			case 4:
				cout<<"
CROSS PRODUCT OF TWO VECTORS.
";
				C = A * B;
				cout<<"
The Value Of A*B(Cross Product) Is: "<<C;
				break;
			case 5:
				cout<<"
SCALAR(OR DOT) PRODUCT OF TWO VECTORS.
";
				A.DotProd(B);
				break;
			case 6:
				cout<<"
NEGATIVE OF A VECTOR.
";
				C = -A;
				cout<<"The Value Of -A Is: "<<C;
				C = -B;
				cout<<"
The Value Of -B Is: "<<C;
				break;
			case 7:
				return;
			default:
				cout<<"
WRONG CHOICE.
";
				break;
				getch();
		}
		cout<<"

DO YOU WANT TO ENTER A NEW VECTOR (y/n): ";
		cin>>choice;
		system("cls");
	}while(1);
}
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
                             //VECTOR.CPP

#include"Vector.h"


Vector::Vector():x(0),y(0),z(0)
{
	//cout<<"This Is A Default Constructor.";
}

Vector Vector::operator +(const Vector &v)const  //Addition
{
	Vector res;
	res.x = x + v.x;
	res.y = y + v.y;
	res.z = z + v.z;
	return res;
}

Vector Vector::operator -(const Vector &v)const  //Subtraction
{
	Vector res;
	res.x = x - v.x;
	res.y = y - v.y;
	res.z = z - v.z;
	return res;
}

Vector Vector::operator *(const int k)const  //Multiplication By Scalar
{
	Vector res;
	res.x = k * x;
	res.y = k * y;
	res.z = k * z;
	return res;
}

void Vector::GetData()			//Input The Vector
{
	cout<<"
Enter The Value Of x : ";
	cin>>x;
	cout<<"
Enter The Value Of y : ";
	cin>>y;
	cout<<"
Enter The Value Of z : ";
	cin>>z;
}

Vector operator *(int k,const Vector &v)
{
	return v * k;
}

Vector Vector::operator -()const   //Negative Of A Vector
{
	Vector res;
	res.x = -x;
	res.y = -y;
	res.z = -z;
	return res;
}

Vector Vector::operator *(const Vector &v)const //Cross (or Vector)
Product
{
	Vector res;
	res.x = (y * v.z) - (z * v.y);
	res.y = (z * v.x) - (x * v.z);
	res.z = (x * v.y) - (y * v.x);
	return res;
}

void Vector::DotProd(Vector v2)    //Dot(Or Scalar) Product
{
	int v1v2;
	v1v2 = (x * v2.x)+(y * v2.y)+(z * v2.z);
	cout<<"
The Value Of A.B Is: "<<v1v2;
}

ostream & Vector::Show(ostream & out)const
{
	if((x<0) && (y<0) && (z<0))
	out<<x<<"I"<<y<<"J"<<z<<"K";

	if((x<0) && (y<0) && (z>=0))
	out<<x<<"I"<<y<<"J+"<<z<<"K";

	if((x<0) && (y>=0) && (z<0))
	out<<x<<"I+"<<y<<"J"<<z<<"K";

	if((x<0) && (y>=0) && (z>=0))
	out<<x<<"I+"<<y<<"J+"<<z<<"K";

	if((x>=0) && (y<0) && (z<0))
	out<<x<<"I"<<y<<"J"<<z<<"K";

	if((x>=0) && (y<0) && (z>=0))
	out<<x<<"I"<<y<<"J+"<<z<<"K";

	if((x>=0) && (y>=0) && (z<0))
	out<<x<<"I+"<<y<<"J"<<z<<"K";

	if((x>=0) && (y>=0) && (z>=0))
	out<<x<<"I+"<<y<<"J+"<<z<<"K";

	return out;
}


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
                       // VECTOR.H

#include<iostream>
#include<conio.h>
#include<stdlib.h>

using namespace std;

class Vector
{
private:
	int x,y,z;
public:
	Vector(int,int,int);
	Vector();
	void GetData();
	Vector operator+(const Vector &v)const;
	Vector operator-(const Vector &v)const;

	Vector operator*(const int k)const;		//Multiplication by Scalar
	Vector operator*(const Vector &v)const; //Cross Product
	Vector operator-()const;				//Negative Of A Scaler
	void DotProd(Vector);					//Dot Product

	ostream & Show(ostream & out)const;
	friend Vector operator*(const int k,const Vector &v);
	friend ostream & operator<<(ostream & out,const Vector &v)
	{
		v.Show(out);
	    return out;
	}
};



Area of rectangle

#include <iostream> 
using namespace std; 

const double pi = 3.14159; 

int main() 
{ 
float length, width, area; 

cout << "Enter The Length Of The Rectangle: "; 
cin >> length; 
cout << "Enter The Width Of Rectangle: "; 
cin >> width; 
area = length*width; 

cout <<"The area of the rectangle is : "<< area << endl;

return 0; 
}
Average function

#include <iostream>
#include <stdlib.h> 
int Average(int i)
{
static int sum = 0, count = 0; 
sum = sum + i; 
count++; 
return sum / count; 
}

int main()
{

int num;
do{

cout<<"Enter numbers ( -1 to quit )"<<endl;
cin>>num;
/*if number is not -1 print the average*/
if(num != -1)
cout<<"The average is "<<Average(num)<<endl;


}while(num>-1);
return 0;
}
Average

#include <iostream.h>
#include <math.h> 
int main()
{
int number1,number2,number3;
double average;

cout<<"Enter three integers and I will display the average"<<endl;
cin>>number1>>number2>>number3;
average = (number1 + number2 + number3) / 3.0;
cout<<"The average is "<<average<<endl;

return 0;
}
Cin example

#include <iostream.h>

int main(void)
{
int number,highNumber;

cout<<"Please enter a whole number (ctrl q) to quit";
while(cin>>number)
{
if(number > highNumber)
highNumber = number;
cout<<"Please enter a whole number (ctrl q) to quit";

}
cout<<"High number is :"<<highNumber<<endl;
return 0;
}
Cin getline example

#include <iostream.h>

int main(void)
{
const SIZE = 100;
char msg[SIZE];
cout<<"Enter a string."<<endl;
cin.getline(msg,SIZE);
cout<<"The sentence you entered was"<<endl;
cout<<msg<<endl;

return 0;
}
Cout and cin examples

//read a character using cin 
#include <iostream.h>
#include <stdlib.h>

int main()
{
char mychar[100];
int i = 0;
//while the character is not a new line
while((mychar[i] = cin.get()) != '\n')
i++;

mychar[i] = NULL;
//display characters
cout<<mychar<<endl;

return 0;
}

//write a character using cout

#include <iostream.h>
#include <stdlib.h>

int main()
{
char *url = "WWW";
while(*url)
cout.put (*url++);

cout<<endl;
return 0;
}
Cout width example

//illustrates setting cout width 
#include <iostream.h>
#include <stdlib.h>
#include <iomanip.h>

int main()
{

cout<<setw(20)<<"setw(20)"<<endl;
cout<<setw(10)<<"setw(10)"<<endl;
cout<<setw(15)<<"setw(15)"<<endl;

return 0;
}
Creates a file using fstream

//this example creates a file called myfile.txt
//and adds some text message to it
#include <fstream.h> 
int main()
{
ofstream MyFile("myfile.txt");
MyFile<<"This is some test message";
MyFile.close();

return 0;
}
Enum example

An enum example in C++

#include <iostream.h> 
int main()
{
enum Days{Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday};

Days TheDay;
int j;
cout<<"Please enter the day of the week (0 to 6)";
cin>>j;
TheDay = Days(j);

if(TheDay == Sunday || TheDay == Saturday)
cout<<"Hurray it is the weekend"<<endl;
else
cout<<"Curses still at work"<<endl;

return 0;
}
Fahrenheit to celsius conversion

#include <iostream.h> 
int main()
{
double fahr , celsius;
cout<<"Enter the temperature in degrees fahrenheit: ";
cin>>fahr;
//convert to celsius
celsius = (5.0 / 9.0) * (fahr - 32.0);
cout<<"The temperature in celsius is "<<celsius<<endl;

return 0;
}
File example using fstream.h functions

#include<iostream.h>
#include<fstream.h> 
int main()

{
// first lets output to a file
ofstream fout("sample.txt");
fout << "WWW" << endl;
fout.close();
char str[20];
//read in the file
ifstream fin("sample.txt");
fin >> str;
fin.close();
//display sample.txt contents
cout << "data read from file: " << str << endl;
return 0;
}
Function example

Create your first function in C++
#include <iostream.h> 
int AddIt(int x,int y)
{
return (x + y);
}

int main()
{
int a,b,c;
cout<<"Please enter two integers to add :\n";
//get the two integers
cin>>a;
cin>>b;
//call the AddIt function
c = AddIt(a , b);
//display the answer
cout<<"The answer is : "<<c<<endl;

return 0;
}
If - Else example

#include <iostream.h>
#include <math.h> 
int main()
{
double radius;
//get user input
cout<<"Please enter the radius : ";
cin>>radius;
//act on user input
if(radius < 0.0)
cout<<"Cannot have a negative radius"<<endl;
else
cout<<"The area of the circle is "<<3.1416 * pow(radius,2)<<endl;

return 0;
}
Launch notepad using C++

#include <iostream.h>
#include <windows.h> 
int main(void)
{

cout<<"Explorer will launch.\n"<<endl;
/*replace with the path to your explorer.exe*/
system("h:\\windows\\explorer.exe");

return 0;
}
Multiply a number by a power

#include <iostream> 
using namespace std; 
int main() 
{ 
int number,power,count,i; 

cout << "Enter Number: "; cin >> number; 
cout << "Enter the power: "; cin >> power; 

count = 1; 
for (i=1; i <=power; i++) 
count = count*number; 

cout << count << endl; 

return 0; 
}
Octal - Hexadecimal - Decimal conversion

#include <iostream.h>
#include <iomanip.h> 
int main()
{
cout<<"The decimal value of 15 is "<<15<<endl;
cout<<"The octal value of 15 is "<<setiosflags(ios::oct)<<15<<endl;
cout<<"The hex value of 15 is "<<setiosflags(ios::hex)<<15<<endl;

return 0;

}
Octal, hex and decimal conversion example 2

#include <iostream.h>

int main()
{
cout<<"The decimal value of 15 is "<<15<<endl;
cout<<"The octal value of 15 is "<<oct<<15<<endl;
cout<<"The hex value of 15 is "<<hex<<15<<endl;

return 0;
}
Open a file and display contents on the screen

//this example opens a file called myfile.txt
//and reads the text message to it
#include <fstream.h> 
int main()
{
ifstream MyFile("myfile.txt");
char ch;

while(!MyFile.eof())
{
MyFile.get (ch);
cout<<ch;
}
MyFile.close();
return 0;
}
Get the OS version on your PC

#include <windows.h>
#include <iostream>
#include <dos.h>
#include <string.h> 
int main(void)

{
OSVERSIONINFO osver;
osver.dwOSVersionInfoSize = sizeof(osver);
if (GetVersionEx(&osver))

{
if (osver.dwPlatformId == VER_PLATFORM_WIN32s)
cout <<"Win32 ";
else if (osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)

{
if (osver.dwMinorVersion == 0 && (strchr(osver.szCSDVersion,'B') == NULL)
&& (strchr(osver.szCSDVersion,'C') == NULL))
cout <<"Windows 95 ";
else if (osver.dwMinorVersion == 0 && (strchr(osver.szCSDVersion,'B') != NULL))
cout <<"Windows 95 OSR 2 ";
else if (osver.dwMinorVersion == 0 && (strchr(osver.szCSDVersion,'C') != NULL))
cout <<"Windows 95 OSR 2.5 ";
else if (osver.dwMinorVersion == 10 && (strchr(osver.szCSDVersion,'A') == NULL))
cout <<"Windows 98 ";
else if (osver.dwMinorVersion == 10 && (strchr(osver.szCSDVersion,'A') != NULL))
cout <<"Windows 98 Second Edition ";
else if (osver.dwMinorVersion == 90)
cout <<"Windows Millenium Edition ";
else
cout<<"Unknown Windows ";
}
else if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
cout <<"Windows NT ";
cout <<osver.dwMajorVersion<<"."<<osver.dwMinorVersion<<"."
<<(osver.dwBuildNumber & 0xffff)<<osver.szCSDVersion<<endl;
}
else


{
cout <<"Cannot gain version information."<<endl;
}
system("pause");
return 0;
}
Read a character using cin

#include <iostream.h>
#include <stdlib.h>

int main()
{
char mychar[100];
int i = 0;
//while the character is not a new line
while((mychar[i] = cin.get()) != '\n')
i++;

mychar[i] = NULL;
//display characters
cout<<mychar<<endl;

return 0;
}
Write a character using cout

#include <iostream.h>
#include <stdlib.h>

int main()
{
char *url = "WWW";
while(*url)
cout.put (*url++);

cout<<endl;
return 0;
}
Write text to a file

#include <iostream.h>
#include <fstream.h>
const char *FILENAME = "myfile.txt";

int main() 
{
//create output object associated w/ file
ofstream fout(FILENAME);
cout << "Enter your text: ";
char str[100];
cin >> str;
//write the text to the file
fout << "here is your text\n";
fout <<str<<endl;
//close file
fout.close();

ifstream fin(FILENAME);
char ch;
while (fin.get(ch))
cout << ch;
fin.close(); 
return 0;
}
A C++ program with several functions
#include <iostream>
using namespace std;
void line(), message();
int main()
{
   cout << "The program starts in main()." << endl;
   line();
   message();
   line();
   cout << "At the end of main()." << endl;
   return 0;
}
void line()
{
   cout << "line();" << endl;
}
void message()
{
   cout << "In function message()." << endl;
}
A classical stack operation using a string of characters.
#include <iostream>
#include <string.h>
using namespace std;
#define maxlen 80

class stack {
 char str1[maxlen];
 int  first;   
public:
 void clear(void);
 char top(void);
 int  empty(void);
 int  full(void);
 void push(char chr);
 char pop(void);
};

void stack::clear(void)
{
 first=0;
}   
  char stack::top(void)
{
 return (str1[first]);
}

int stack::empty(void)
{
 return (first==0);
}

int stack::full(void)
{
 return (first==maxlen-1);
}

void stack::push(char chr)
{
 str1[++first]=chr;
}   
char stack::pop(void)
{
 return (str1[first-1]);
}

main( )
{
 stack mystack;
 char str[11]="0123456789";

 mystack.clear( );
  
 for(int i=0; (int) i<strlen(str);i++) {
   if (!mystack.full( ))
     mystack.push(str[i]);
     cout << str[i] << endl;
 }
 while (!mystack.empty( ))
   cout << mystack.pop( ) << endl;
 
 return (0);
}
A Closer Look at the I/O Operators
#include <iostream>

using namespace std;

int main()
{

  float f;

  char str[80];

  double d;

  cout << "Enter two floating point numbers: ";

  cin >> f >> d;

  cout << "Enter a string: ";

  cin >> str;

  cout << f << " " << d << " " << str;

  return 0;
}
A copy constructor to allow StringClass objects to be passed to functions.
#include <iostream>
#include <cstring>
#include <cstdlib>
using namespace std;

class StringClass {
  char *p;
public:
  StringClass(char *s);           // constructor
  StringClass(const StringClass &o);  // copy constructor
  ~StringClass() {                // destructor
     delete [] p; 
  } 
  char *get() { 
     return p; 
  }
};


StringClass::StringClass(char *s)     // "Normal" constructor
{
  int l;

  l = strlen(s)+1;

  p = new char [l];
  if(!p) {
    cout << "Allocation error\n";
    exit(1);
  }

  strcpy(p, s);
}


StringClass::StringClass(const StringClass &o)   // Copy constructor
{
  int l;

  l = strlen(o.p)+1;

  p = new char [l];                  // allocate memory for new copy
  if(!p) {
    cout << "Allocation error\n";
    exit(1);
  }

  strcpy(p, o.p);                    // copy string into copy
}

void show(StringClass x)
{
  char *s;
   
  s = x.get();
  cout << s << endl;
}

int main()
{
  StringClass a("Hello World"), b("Hello World");

  show(a);
  show(b);

  return 0;
}
A dynamic output array
#include <strstream>
#include <iostream>
using namespace std;
int main()
{
  char *p;
  ostrstream outs;                       // dynamically allocate array
  outs << "C++ array-based I/O ";
  outs << -10 << hex << " ";
  outs.setf(ios::showbase);
  outs << 100 << ends;
  p = outs.str();                        // Freeze dynamic buffer and return
                                         // pointer to it.
  cout << p;
  return 0;
}
A filter to remove white-space characters at the ends of lines.
#include <iostream>
#include <string>
using namespace std;
void cutline( void );         
string line;                  
int main()
{
   while( getline(cin, line)) {
     cutline();               
     cout << line << endl;    
   }
   return 0;
} 

void cutline()
{
   int i = line.size();       
                              
   while( i-- >= 0 )
     if(   line[i] != ' ' && line[i] != '\t' )
       break;                   
   line.resize(++i);            
}
A four-function postfix calculator.
#include <iostream>
#include <stack>
#include <string>
#include <cmath>
using namespace std;

int main()
{
  stack<double> stackObject;
  double a, b;
  string s;

  do {
    cout << ": ";
    cin >> s;
    switch( s[ 0 ]) {
      case 'q': // quit the calculator
        break;
      case '.': // show top-of-stack
        cout << stackObject.top() << endl;
        break;
      case '+': // add
        if(stackObject.size() < 2) {
          cout << "Operand Missing\n";
          break;
        }

        a = stackObject.top();
        stackObject.pop();
        b = stackObject.top();
        stackObject.pop();
        cout << a + b << endl;
        stackObject.push(a + b);
        break;
      case '-': // subtract
        // see if user entering a negative number
        if(s.size() != 1) {
          // push value onto the stack
          stackObject.push(atof(s.c_str()));        
          break;
        }

        // otherwise, is a subtraction
        if(stackObject.size() < 2) {
          cout << "Operand Missing\n";
          break;
        }

        a = stackObject.top();
        stackObject.pop();
        b = stackObject.top();
        stackObject.pop();
        cout << b - a << endl;
        stackObject.push(b - a);
        break;
      case '*': // multiply
        if(stackObject.size() < 2) {
          cout << "Operand Missing\n";
          break;
        }

        a = stackObject.top();
        stackObject.pop();
        b = stackObject.top();
        stackObject.pop();
        cout << a*b << endl;
        stackObject.push(a*b);
        break;
      case '/': // divide
        if(stackObject.size() < 2) {
          cout << "Operand Missing\n";
          break;
        }

        a = stackObject.top();
        stackObject.pop();
        b = stackObject.top();
        stackObject.pop();
        cout << b/a << endl;
        stackObject.push(b/a);
        break;
      default:      
        // push value onto the stack
        stackObject.push(atof(s.c_str()));        
        break;
    }
  } while(s != "q");

  return 0;
}
A function object that computes an integer sum.
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

class sum : unary_function<int, void> {
public:
  argument_type sum;

  sum() { sum = 0; }

  result_type operator()(argument_type i) {
  sum += i;
  }
};

int main()
{
  vector<int> v;

  for(int i=1; i < 11; i++) v.push_back(i);

  for(unsigned i=0; i < v.size(); ++i){
    cout << v[i] << endl;
  }
  sum s;

  s = for_each(v.begin(), v.end(), sum());
  cout << "sum of v: " << s.sum << endl;

  return 0;
}
A generic bubble sort.
#include <iostream>
using namespace std;


template <class X> void bubble(X *data, int size)
{
  register int a, b;
  X t;

  for(a=1; a < size; a++)
    for(b=size-1; b >= a; b--)
      if(data[b-1] > data[b]) {
        t = data[b-1];
        data[b-1] = data[b];
        data[b] = t;
      }
}

int main()
{
  int i[] = {3, 2, 5, 6, 1, 8, 9, 3, 6, 9};
  double d[] = {1.2, 5.5, 2.2, 3.3};
  int j;

  bubble(i, 10); // sort ints
  bubble(d, 4);  // sort doubles

  for(j=0; j<10; j++) 
     cout << i[j] << ' ';
  cout << endl;

  for(j=0; j<4; j++) 
     cout << d[j] << ' ';
  cout << endl;

  return 0;
}
A generic mode finding function.
#include <iostream>
#include <cstring>
using namespace std;


template <class X> X mode(X *data, int size)
{
  register int t, w;
  X md, oldmd;
  int count, oldcount;

  oldmd = 0;
  oldcount = 0;
  for(t=0; t<size; t++) {
    md = data[t];
    count = 1;
    for(w = t+1; w < size; w++) 
      if(md==data[w]) count++;
    if(count > oldcount) {
      oldmd = md;
      oldcount = count;
    }
  }
  return oldmd;
}

int main()
{
  int i[] = { 1, 2, 3, 4, 2, 3, 2, 2, 1, 5};
  char *p = "this is a test";

  cout << "mode of i: " << mode(i, 10) << endl;
  cout << "mode of p: " << mode(p, (int) strlen(p));

  return 0;
}
A generic stack that holds two values.
#include <iostream>
using namespace std;

#define SIZE 10

template <class StackType> class stack {
  StackType stck[SIZE][2]; 
  int topOfStack;          

public:
  void init() { topOfStack = 0; } 
  void push(StackType ob, StackType object2); 
  StackType pop(StackType &object2); 
};

template <class StackType>
void stack<StackType>::push(StackType ob, StackType object2)
{
  if(topOfStack==SIZE) {
    cout << "Stack is full.\n";
    return;
  }
  stck[topOfStack][0] = ob;
  stck[topOfStack][1] = object2;
  topOfStack++;
}

template <class StackType> 
StackType stack<StackType>::pop(StackType &object2)
{
  if(topOfStack==0) {
    cout << "Stack is empty.\n";
    return 0; 
  }
  topOfStack--;
  object2 = stck[topOfStack][1];
  return stck[topOfStack][0];
}

int main()
{
  stack<char> stack1, stackObject2;
  int i;
  char ch;

  stack1.init();
  stackObject2.init();

  stack1.push('a', 'b');
  stackObject2.push('x', 'z');
  stack1.push('b', 'd');
  stackObject2.push('y', 'e');
  stack1.push('c', 'a');
  stackObject2.push('z', 'x');

  for(i = 0; i <3; i++) {
    cout << "Pop stack1: " << stack1.pop(ch);
    cout << ' ' << ch << endl;
  }
  for(i = 0; i <3; i++) {
    cout << "Pop stackObject2: " << stackObject2.pop(ch);
    cout << ' ' << ch << endl;
  }

  // demonstrate double stacks
  stack<double> doubleValueStack1, doubleValueStack2;  // create two stacks
  double d;

  doubleValueStack1.init();
  doubleValueStack2.init();

  doubleValueStack1.push(1.1, 2.0);
  doubleValueStack2.push(2.2, 3.0);
  doubleValueStack1.push(3.3, 4.0);
  doubleValueStack2.push(4.4, 5.0);
  doubleValueStack1.push(5.5, 6.0);
  doubleValueStack2.push(6.6, 7.0);

  for(i = 0; i <3; i++) {
    cout << "Pop doubleValueStack1: " << doubleValueStack1.pop(d);
    cout << ' '<< d << endl;
  }

  for(i = 0; i <3; i++) {
    cout << "Pop doubleValueStack2: " << doubleValueStack2.pop(d);
    cout << ' '<< d << endl;
  }

  return 0;
}
A generic stack that includes exception handling.
#include <iostream>
using namespace std;

#define SIZE 10

template <class StackType> class stack {
  StackType stck[SIZE]; 
  int topOfStack;       

public:
  void init() { 
     topOfStack = 0; 
  } 
  void push(StackType ch); 
  StackType pop();         
};

template <class StackType>
void stack<StackType>::push(StackType ob)
{
  try {
    if(topOfStack==SIZE) throw SIZE;
  } catch(int) {
    cout << "Stack is full.\n";
    return;
  }
  stck[topOfStack] = ob;
  topOfStack++;
}

template <class StackType> 
StackType stack<StackType>::pop()
{
  try {
    if( topOfStack == 0) 
      throw 0;
  } catch(int) {
    cout << "Stack is empty.\n";
    return 0;              
  }
  topOfStack--;
  return stck[topOfStack];
}

int main()
{
  stack<char> stack1, stack2;  
  int i;

  stack1.init();
  stack2.init();

  stack1.push('a');
  stack2.push('x');
  stack1.push('b');
  stack2.push('y');
  stack1.push('c');
  stack2.push('z');

  for(i = 0; i <3; i++) 
     cout << "Pop stack1: " << stack1.pop() << endl;
  for(i = 0; i <4; i++) 
     cout << "Pop stack2: " << stack2.pop() << endl;

  // demonstrate double stacks
  stack<double> doubleValueStack1, doubleValueStack2;  // create two stacks

  // initialize the stacks
  doubleValueStack1.init();
  doubleValueStack2.init();

  doubleValueStack1.push(1.1);
  doubleValueStack2.push(2.2);
  doubleValueStack1.push(3.3);
  doubleValueStack2.push(4.4);
  doubleValueStack1.push(5.5);
  doubleValueStack2.push(6.6);

  for(i = 0; i <3; i++) 
     cout << "Pop doubleValueStack1: " << doubleValueStack1.pop() << endl;
  for(i = 0; i <4; i++) 
     cout << "Pop doubleValueStack2: " << doubleValueStack2.pop() << endl;

  return 0;
}
A generic version of myabs().
#include <iostream>
using namespace std;

template <class X> X myabs(X val)
{
  return val < 0 ? -val : val;
}

int main()
{
  cout << myabs(-10) << '\n';    // integer abs

  cout << myabs(-10.0) << '\n';  // double abs

  cout << myabs(-10L) << '\n';   // long abs

  cout << myabs(-10.0F) << '\n'; // float abs

  return 0;
}
A list splicing example.
#include <iostream>
#include <list>
#include <string>
#include <algorithm>
using namespace std;

int main()
{
  list<string> sentence;
  list<string> phrase;
  list<string>::iterator p;
  
  string s1[] = {"A", "B", ""};
  string s2[] = {"C", "D", ""};
  string s3[] = {"E", "F", "G.", ""};
  string s4[] = {"A", "C,", "E", "G", ""};
  int i;

  for(i = 0; s1[ i ] != ""; i++)
    sentence.push_back(s1[i]);


  for(i = 0; s2[ i ] != ""; i++)
    phrase.push_back(s2[ i ]);

  cout << "Original sentence:\n";
  p = sentence.begin();
  while(p != sentence.end())
    cout << *p++ << " ";
  cout << endl;

  sentence.splice(sentence.begin(), phrase);

  cout << "Sentence after splicing at the front:\n";
  p = sentence.begin();
  while(p != sentence.end())
    cout << *p++ << " ";
  cout << endl;

  for(i = 0; s3[ i ] != ""; i++)
    phrase.push_back(s3[ i ]);

  sentence.splice(sentence.end(), phrase);

  cout << "Sentence after splicing at the end:\n";
  p = sentence.begin();
  while(p != sentence.end())
    cout << *p++ << " ";
  cout << endl;

  for(i = 0; s4[ i ] != ""; i++)
    phrase.push_back(s4[ i ]);


  p = find(sentence.begin(), sentence.end(), "or");
  sentence.splice(p, phrase);

  cout << "Sentence after splicing in the middle:\n";
  p = sentence.begin();
  while(p != sentence.end())
    cout << *p++ << " ";

  return 0;
}
A map: insert pair, find, end
#include <iostream>
#include <map>
using namespace std;

int main()
{
  map<char, int> mapObject;
  int i;

  for(i = 0; i <10; i++) {
    mapObject.insert(pair<char, int>('A'+i, i));
  }

  char ch;
  cout << "Enter key: ";
  cin >> ch;

  map<char, int>::iterator p;
  
  p = mapObject.find(ch);
  if(p != mapObject.end()) 
    cout << p->second;
  else
    cout << "Key not in map.\n";

  return 0;
}
A map of opposites.
#include <iostream>
#include <map>
#include <cstring>
using namespace std;

class StringClass {
  char str[20];
public:
  StringClass() { 
     strcpy(str, ""); 
  }
  StringClass(char *s) { 
     strcpy(str, s); 
  }
  char *get() { 
     return str; 
  }
};

// must define less than relative to StringClass objects
bool operator<(StringClass a, StringClass b)
{
   return strcmp(a.get(), b.get()) < 0;
}

class opposite {
  char str[20];
public:
  opposite() { 
     strcmp(str, ""); 
  }
  opposite(char *s) { 
     strcpy(str, s); 
  }
  char *get() { 
     return str; 
  }
};


int main()
{
  map<StringClass, opposite> mapObject;

  mapObject.insert(pair<StringClass, opposite>(StringClass("yes"), opposite("no")));
  mapObject.insert(pair<StringClass, opposite>(StringClass("good"), opposite("bad")));
  mapObject.insert(pair<StringClass, opposite>(StringClass("left"), opposite("right")));
  mapObject.insert(pair<StringClass, opposite>(StringClass("up"), opposite("down")));

  char str[80];
  cout << "Enter word: ";
  cin >> str;

  map<StringClass, opposite>::iterator p;
  
  p = mapObject.find(StringClass(str));
  if(p != mapObject.end()) 
    cout << "Opposite: " <<  p->second.get();
  else
    cout << "Word not in map.\n";

  return 0;
}
A map of word opposites, using strings.
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main()
{
  map<string, string> mapObject;
  int i;

  mapObject.insert(pair<string, string>("yes", "no"));
  mapObject.insert(pair<string, string>("up", "down"));
  mapObject.insert(pair<string, string>("left", "right"));
  mapObject.insert(pair<string, string>("good", "bad"));

  string s;
  cout << "Enter word: ";
  cin >> s;

  map<string, string>::iterator p;
  
  p = mapObject.find(s);
  if(p != mapObject.end()) 
    cout << "Opposite: " << p->second;
  else
    cout << "Word not in map.\n";

  return 0;
}
A namespace can be nested within another
#include <iostream>
using namespace std;
namespace MyNameSpace1 {
  int i;
  namespace MyNameSpace2 { // a nested namespace
    int j;
  }
}
int main()
{
  MyNameSpace1::i = 19;

  MyNameSpace1::MyNameSpace2::j = 10;
  cout << MyNameSpace1::i << " "<<  MyNameSpace1::MyNameSpace2::j << "\n";

  using namespace MyNameSpace1;
  cout << i * MyNameSpace2::j;
  return 0;
}
A shared resource example.
#include <iostream>
#include <cstring>
using namespace std;

class output {
  static char sharedResource[255]; // this is the shared resource
  static int inuse;        // buffer available if 0; in use otherwise
  static int oindex;       // index of sharedResource
  char str[80];
  int i;                   // index of next char in str
  int who;                 // identifies the object, must be > 0
public:
  output(int w, char *s) { 
     strcpy(str, s); 
     i = 0; 
     who = w; 
  }

  int putbuf() 
  {
    if(!str[ i ]) {         // done outputting
      inuse = 0;            // release buffer
      return 0;             // signal termination
    }
    if(!inuse)              // get buffer
        inuse = who; 
    if(inuse != who)        // in use by someone else
        return -1; 
    if(str[ i ]) {          // still chars to output
      sharedResource[oindex] = str[ i ];
      i++; oindex++;
      sharedResource[oindex] = '\0';// always keep null-terminated
      return 1;
    }
    return 0;
  }
  void show() { 
     cout << sharedResource << '\n'; 
  }
};

char output::sharedResource[255];   // this is the shared resource
int output::inuse = 0;      // buffer available if 0; in use otherwise
int output::oindex = 0;     // index of sharedResource

int main()
{
  output object1(1, "This is a test"), object2(2, " of statics");

  while(object1.putbuf() | object2.putbuf()) ; // output chars

  object1.show();

  return 0;
}
A short string demonstration.
#include <iostream>
#include <string>
using namespace std;
   
int main()
{
  string str1("A");
  string str2("B");
  string str3("O");
  string str4;
   
  str4 = str1;
  cout << str1 << "\n" << str3 << "\n";
   
  str4 = str1 + str2;
  cout << str4 << "\n";
   
  str4 = str1 + " to " + str3;
  cout << str4 << "\n";
   
  if(str3 > str1) 
     cout << "str3 > str1\n";
  if(str3 == str1+str2)
    cout << "str3 == str1+str2\n";
   
  str1 = "This is a null-terminated string.\n";
  cout << str1;
   
  string str5(str1);
  cout << str5;
   
  cout << "Enter a string: ";
  cin >> str5;
  cout << str5;
   
  return 0;
}
A short string demonstration
#include <iostream>
#include <string>
using namespace std;
int main()
{
  string stringObject1("stringObject1");
  string stringObject2("stringObject2");
  string stringObject3("stringObject3");
  string stringObject4;
  stringObject4 = stringObject1;
  cout << stringObject1 << "\n" << stringObject3 << "\n";
  stringObject4 = stringObject1 + stringObject2;
  cout << stringObject4 << "\n";
  stringObject4 = stringObject1 + " to " + stringObject3;
  cout << stringObject4 << "\n";
  if(stringObject3 > stringObject1) 
     cout << "stringObject3 > stringObject1\n";
  if(stringObject3 == stringObject1+stringObject2)
    cout << "stringObject3 == stringObject1+stringObject2\n";
  stringObject1 = "This is a null-terminated string.\n";
  cout << stringObject1;
  string str5(stringObject1);
  cout << str5;
  cout << "Enter a string: ";
  cin >> str5;
  cout << str5;
  return 0;
}
A simple bounded 2-d array example.
#include <iostream>
#include <cstdlib>
using namespace std;

class MyArray {
  int isize, jsize;
  int *p;
public:
  MyArray(int i, int j);
  int &put(int i, int j);
  int get(int i, int j);
};

MyArray::MyArray(int i, int j)
{
  p = new int [i*j];
  if(!p) {
    cout << "Allocation error\n";
    exit(1);
  }
  isize = i;
  jsize = j;
}

int &MyArray::put(int i, int j)
{
  if(i <0 || i>=isize || j<0 || j>=jsize) {
    cout << "Bounds error!!!\n";
    exit(1);
  }
  return p[i*jsize + j];
}

int MyArray::get(int i, int j)
{
  if(i <0 || i>=isize || j<0 || j>=jsize) {
    cout << "Bounds error!!!\n";
    exit(1);
  }
  return p[i*jsize +j]; 
}
  
int main()
{
  MyArray a(2, 3);
  int i, j;

  for(i = 0; i <2; i++)
    for(j=0; j<3; j++)
      a.put(i, j) = i+j;

  for(i = 0; i <2; i++)
    for(j=0; j<3; j++)
      cout << a.get(i, j) << ' ';

  a.put(10, 10);

  return 0;
}
A simple class with member variable, constructor, destructor
#include <iostream>
using namespace std;

class who {
  char name;
public:
  who(char c) { 
     name = c;
     cout << "Constructing who";
     cout << name << endl;
  }
  ~who() { 
     cout << "Destructing who: " << name << endl; 
  }
};

who makewho()
{
  who temp('B');
  return temp;
}

int main()
{
  who ob('A');

  makewho();

  return 0;
}
Write a simple class called Cube.
The object should calculate the total area and the volume based on the side measurement.
If the program supplies a side equal or lower than 0, reset the side to 1.
Create an empty constructor and an empty destructor.

Implement the object in different files.

Header File: cube.h

#ifndef CUBE_H
#define CUBE_H

class Cube
{
public:
	Cube();
	~Cube();
	void setSide(double s);
	double getSide();
	double Area();
	double Volume();
	void Properties();
private:
	double Side;
};

#endif

Source File cube.cpp

#include <iostream.h>
#include "cube.h"

Cube::Cube()
{
}

Cube::~Cube()
{
}

void Cube::setSide(double s)
{
	Side = s <= 0 ? 1 : s;
}

double Cube::getSide()
{
	return Side;
}

double Cube::Area()
{
	return 6 * Side * Side;
}

double Cube::Volume()
{
	return Side * Side * Side;
}

void Cube::Properties()
{
	cout << "Characteristics of this cube";
	cout << "\nSide   = " << getSide();
	cout << "\nArea   = " << Area();
	cout << "\nVolume = " << Volume() << "\n\n";
}

Main File: Exo.cpp

#include "cube.h"

void main()
{
	Cube cube;
	cube.setSide(-12.55);
	cube.Properties();

	Cube de;
	de.setSide(28.15);
	de.Properties();
}

Here is an example of the result:

Characteristics of this cube
Side   = 1
Area   = 6
Volume = 1

Characteristics of this cube
Side   = 28.15
Area   = 4754.53
Volume = 22306.7
A simple conversion function example.
#include <iostream>
using namespace std;

class MyClass {
  int x, y;
public:
  MyClass(int i, int j) { 
     x = i; 
     y = j; 
  }
  operator int() { 
     return x*y; 
  }
};

int main()
{
  MyClass object1(2, 3), object2(4, 3);
  int i;

  i = object1;                 // automatically convert to integer
  cout << i << '\n';

  i = 100 + object2;           // convert object2 to integer
  cout << i << '\n';

  return 0;
}
A simple example of inheritance.
#include <iostream>
using namespace std;

class BaseClass {
  int i;
public:
  void setInt(int n);
  int getInt();
};

class DerivedClass : public BaseClass {
  int j;
public:
  void setJ(int n);
  int mul();
};

void BaseClass::setInt(int n)
{
  i = n;
}

int BaseClass::getInt()
{
  return i;
}

void DerivedClass::setJ(int n)
{
  j = n;
}

int DerivedClass::mul()
{
  return j * getInt();
}

int main()
{
  DerivedClass ob;

  ob.setInt(10);        // load i in BaseClass
  ob.setJ(4);          // load j in DerivedClass

  cout << ob.mul();     // displays 40

  return 0;
}
A simple example using a virtual function.
#include <iostream>
using namespace std;

class BaseClass {
public:
  int i;
  BaseClass(int x) { 
     i = x; 
  }
  virtual void myFunction()
  {
    cout << "Using BaseClass version of myFunction(): ";
    cout << i << '\n';
  }
};

class DerivedClass1 : public BaseClass {
public:
  DerivedClass1(int x) : BaseClass(x) {}
  void myFunction() 
  {
    cout << "Using DerivedClass1's version of myFunction(): ";
    cout << i*i << '\n';
  }
};

class DerivedClass2 : public BaseClass {
public:
  DerivedClass2(int x) : BaseClass(x) {}
  void myFunction() 
  {
    cout << "Using DerivedClass2's version of myFunction(): ";
    cout << i+i << '\n';
  }
};

int main()
{
  BaseClass *p;
  BaseClass ob(10);  
  DerivedClass1 derivedObject1(10);   
  DerivedClass2 derivedObject2(10); 

  p = &ob;
  p->myFunction();                         // use BaseClass's myFunction()

  p = &derivedObject1;
  p->myFunction();                         // use DerivedClass1's myFunction()

  p = &derivedObject2;
  p->myFunction();                         // use DerivedClass2's myFunction()

  return 0;
}
A Simple for Statement - generate the square root of 1 to 10

#include <iostream>
#include <math.h> // for newer compilers, use <cmath>
using namespace std;

int main()
{
  int num;
  double sq_root;

  for(num=1; num < 10; num++) {
    sq_root = sqrt((double) num); //casting num from integer to double 
    				  // then taking its square root
    cout << num << "  " << sq_root << '\n';
  }

  return 0;
}
A simple generic linked list.
#include <iostream>
using namespace std;

template <class dataType> class list {
  dataType data;
  list *next;
public:
  list(dataType d);
  void add(list *node) {
     node->next = this; 
     next = 0; 
  }
  list *getnext() { 
     return next; 
  }
  dataType getdata() { 
     return data; 
  }
};

template <class dataType> list<dataType>::list(dataType d)
{
  data = d;
  next = 0;
}

int main()
{
  list<char> start('a'); 
  list<char> *p, *last;
  int i;
  
  last = &start;
  for(i=1; i <26; i++) {
    p = new list<char> ('a' + i);
    p->add(last);
    last = p;
  }

  p = &start;
  while(p) {
    cout << p->getdata();
    p = p->getnext();
  }

  return 0;
}
A Simple if Statement
This program illustrates a simple if statement.
It reads in two integers and prints out a
message on the screen according to their values.

#include <iostream>
using namespace std;

int main()
{
  int a, b;

  cout << "Enter first number: ";
  cin >> a;
  cout << "Enter second number: ";
  cin >> b;

  if(a < b) 
	  cout << "First number is less than second.\n";

  return 0;
}
This program illustrates a simple if-else statement.

#include <iostream>
using namespace std;

int main()
{
  int a, b;

  cout << "Enter first number: ";
  cin >> a;
  cout << "Enter second number: ";
  cin >> b;

  if(a < b) 
	  cout << "First number is less than second.\n";
  else
	  cout << "First number is greater than or equal to second.\n";

  return 0;

}
A simple map: char and int
#include <iostream>
#include <map>
using namespace std;

int main()
{
  map<char, int> mapObject;
  int i;

  for(i = 0; i <26; i++) {
    mapObject.insert(pair<char, int>('A'+i, 65+i));
  }

  char ch;
  cout << "Enter key: ";
  cin >> ch;

  map<char, int>::iterator p;
  
  p = mapObject.find(ch);
  if(p != mapObject.end()) 
    cout << "Its ASCII value is  " << p->second;
  else
    cout << "Key not in map.\n";

  return 0;
}
A simple output manipulator: sethex
#include <iostream>
#include <iomanip>
using namespace std;


ostream &sethex(ostream &stream)
{
  stream.setf(ios::showbase);
  stream.setf(ios::hex, ios::basefield);

  return stream;
}

int main()
{
  cout << 256 << " " << sethex << 256;

  return 0;
}
Demonstrates the use of a simple C++ class

#include <iostream>
using namespace std;

class cl {
  int i; // private by default
public:
  int get_i();
  void put_i(int j);
};

int cl::get_i()
{
  return i;
}

void cl::put_i(int j)
{
  i = j;
}

int main()
{
  cl s;

  s.put_i(10);
  cout << s.get_i() <<endl;

  return 0;
}
A simple program showing inheritance

#include <iostream>
using namespace std;

class base {
  int i, j;
public:
  void set(int a, int b) { i = a; j = b; }
  void show() { cout << i << " " << j << "\n"; }
};

// inheritance
class derived : public base {
  int k;
public:
  derived(int x) { k = x; }
  void showk() { cout << k << "\n"; }
};

int main()
{
  derived ob(3);

  ob.set(1, 2); // access member of base
  ob.show();    // access member of base

  ob.showk();   // uses member of derived class

  return 0;
}
A simple program demonstrating the use of reference

#include <iostream>
using namespace std;

int main()
{
	int Len, Wid;     // declare int variables

	// Create references to int variables.
        // Now rLen and Len are aliases to each other,
        // and rWid and Wid are also aliases to each other.
	int &rLen = Len;
	int &rWid = Wid; 
	
	// Initialized the two int variables
	Len = 10;         // rLen is also initialized to be 10
	Wid = 20;         // rWid is also initialized to be 20

	// Printing out the values for int and int references
	cout << "Len is: " << Len << ", and  Wid is: " << Wid << endl;
	cout << "rLen is: " << rLen << ", and rWid is: " << rWid << endl;
	cout << endl;
	
	// Printing out the address of int and references to int
	cout << "Address of Len is: " << &Len << endl;
	cout << "Address of rLen is: "  << &rLen << endl;
	if(&Len == &rLen)
	{
		cout << "Address of Len is equal to address of rLen!" << endl;
	}
	cout << "Address of Wid is: " << &Wid << endl;
	cout << "Address of rWid is: "  << &rWid << endl;
	if(&Wid == &Wid)
	{
		cout << "Address of Wid is equal to address of rWid!" << endl;
	}

	return 0;
}
A Templated Stack Data Structure Example

#include <dos.h>           // For sleep()
#include <iostream.h>     // For I/0
#include <windows.h>     // FOR MessageBox() API
#include <conio.h>

#define MAX 10        // MAXIMUM STACK CONTENT

template <class T>    // Using Templates so that any type of data can be
           		 		 		 		 // stored in Stack without multiple defination of class
class stack
{

  protected:

  T arr[MAX];       // Contains all the Data

  public:
    T item,r;
    int top;        //Contains location of Topmost Data pushed onto Stack
		  stack()         //Constructor
		   {
		 		   for(int i=0;i<MAX;i++)
		 		 		 {
		 		 		   arr[i]=NULL;             //Initialises all Stack Contents to NULL
		 		 		 }

		 		   top=-1;      //Sets the Top Location to -1 indicating an empty stack
		   }

		 void push(T a)  // Push ie. Add Value Function
		  {
		 		 top++;        // increment to by 1
		 		 if(top<MAX)
		 		  {
		 		 		 arr[top]=a;          //If Stack is Vacant store Value in Array
		 		  }
		 		  else    // Bug the User
		 		  {
		 		 		 MessageBox(0,"STACK IS FULL","STACK WARNING!",MB_ICONSTOP);
		 		 		 top--;
		 		  }
		  }

		 T pop()                  // Delete Item. Returns the deleted item
		  {
		 		 if(top==-1)
		 		 {
		 		 		 MessageBox(0,"STACK IS EMPTY
","WARNING",MB_ICONSTOP);
		 		 		 return NULL;
		 		 }
		 		 else
		 		 {
		 		 		 T data=arr[top];     //Set Topmost Value in data
		 		 		 arr[top]=NULL;       //Set Original Location to NULL
		 		 		 top--;               // Decrement top by 1
		 		 		 return data;         // Return deleted item
		 		 }
		  }
};


void main()
{
 stack <int>a;    // Create object of class a with int Template
 int opt=1;
 while (opt!=3)
 {
 clrscr();
 cout<<" MAX STACK CAPACITY="<<((MAX-a.top)-1)<<"



";
 cout<<"1) Push Item
";
 cout<<"2) Pop Item
";
 cout<<"3) Exit

";
 cout<<"Option?";
 cin>>opt;
 switch(opt)
 {
  case 1:
  cout<<"Which Number should be pushed?";
  cin>>a.item;
  a.push(a.item);
  break;

  case 2:
  a.r=a.pop();
  cout<<"Item popped from Stack is:"<<a.r<<endl;
  sleep(2);
  break;
 }
 }
 }
Binary tree implementation

#include <iostream.h>
#include <conio.h>
#include <stdlib.h>


struct node
{
node *left;
int value;
node *right;
};
node *curr=NULL;


int addnode(node *, node *);
int inorder(node *);
int preorder(node *);
int postorder(node *);


void main()
{
  char c;
  int v;
  clrscr();
  do
  {
  cout<<"
Select any one
";
  cout<<"
0 ->Exit
";
  cout<<"1 ->Add node
";
  cout<<"2 ->Inorder traversal
";
  cout<<"3 ->Preorder traversal
";
  cout<<"4 ->Postorder trversal : ";

  cin>>c;

  switch(c)
   {
    case '0':
                  exit(1);
    case '1':
                  node *temp;
                  temp = new node;
                  cout<<"  Enter the value of the node : ";
                  cin>>temp->value;
                  if(curr==NULL)
                   {
                    curr=new node;
                    curr->value=temp->value;
                    curr->left=NULL;
                    curr->right=NULL;
                    cout<<"  The root node is added
";
                   }
                  else
                    v=addnode(curr,temp);
                  if(v==1)
                    cout<<"  The node is added to the left
";
                  else if(v==2)
                    cout<<"  The node is added to the right
";
                  else if(v==3)
                    cout<<"  The same value exists
";
                  break;
    case '2':
                   v=inorder(curr);
                   if(v==0)
                   cout<<"   
The tree is empty
";
                   break;
    case '3':
                   v=preorder(curr);
                   if(v==0)
                   cout<<"   
The tree is empty
";
                   break;
    case '4':
                   v=postorder(curr);
                   if(v==0)
                   cout<<"   
The tree is empty
";
                   break;
    default:
                   cout<<"   
Invalid entry
";
                   break;
    }
   }while(c!='0');
   getch();
}


int addnode(node *fcurr, node *fnew )
{
  if(fcurr->value==fnew->value)
   {
     return 3;
   }
 else
   {
    if(fcurr->value > fnew->value)
     {
      if(fcurr->left != NULL)
                addnode(fcurr->left, fnew);
      else
                {
                fcurr->left = fnew;
                (fcurr->left)->left=NULL;
                (fcurr->left)->right=NULL;
                return 1;
                }
     }
    else
     {
      if(fcurr->right != NULL)
                addnode(fcurr->right, fnew);
      else
                {
                fcurr->right = fnew;
                (fcurr->right)->left=NULL;
                (fcurr->right)->right=NULL;
                return 2;
                }
     }
   }
}


int inorder(node *fincurr)
  {
    if(fincurr == NULL)
                return 0;
    else
     {
                 if(fincurr->left != NULL)
                  inorder(fincurr->left);
                  cout<<fincurr->value<<"	";
                 if(fincurr->right != NULL)
                  inorder(fincurr->right);
      }
  }


int preorder(node *fprcurr)
  {
    if(fprcurr == NULL)
                return 0;
    else
     {
                cout<<fprcurr->value<<"	";
                if(fprcurr->left != NULL)
                  preorder(fprcurr->left);
                if(fprcurr->right != NULL)
                  preorder(fprcurr->right);
      }
  }

int postorder(node *fpocurr)
  {
    if(fpocurr == NULL)
                return 0;
    else
     {
                if(fpocurr->left != NULL)
                  postorder(fpocurr->left);
                if(fpocurr->right != NULL)
                  postorder(fpocurr->right);
                  cout<<fpocurr->value<<"	";
      }
  }
Do you want a diomond

#include<iostream.h>
#include<conio.h>
void main()
{
int i,j,k;
clrscr();
for(i=1;i<=15;i++){
for(j=i;j<15;j++)
cout<<" ";
k=2*i-1;
while(k>=1){
cout<<"*";
k--;
}
cout<<"
";
}
for(i=14;i>=1;i--){
for(j=i;j<15;j++)
cout<<" ";
k=2*i-1;
while(k>=1)
{
cout<<"*";
k--;
}
cout<<"
";
}
getch();
}
Employee Management Database System

#include<fstream.h>
#include<dos.h>
#include<conio.h>
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<iomanip.h>
#include<graphics.h>

	 class group
	 {
	 private:
		struct person
		{
		 char flag;
		 char empcode[5];
		 char name[40];
		 int age;
		 float sal;
		 int day;
		 int month;
		 int year;
		 }p;
		 fstream file;
		 public:
	group();

	void addrec();
	void listrec();
	void modirec();
	void delrec();
	void recallrec();
	void packrec();
	void exit();
	};


	void main()

	{
	 char choice,v;
	 group g;
	 do
	 {
	 clrscr();
	 struct dosdate_t d;
	_dos_getdate(&d);
		 //	 p.day=d.day;
		//	 p.month=d.month;
		//	 p.year=d.year;
		//	 _dos_getdate(&d);
	 gotoxy(12,5);
	 textcolor(6);
		cprintf("Todays date:");
		printf("%d",d.day);
		cout<<"/";
		printf("%d",d.month);
		cout<<"/";
		cout<<d.year;
		gotoxy(12,9);
	 cout<<"Srknec.corporation pvt.ltd";
	 gotoxy(12,12);
	 cout<<"1.Add record";
	 gotoxy(12,15);
	 cout<<"2.List Record";
	 gotoxy(12,17);
	 cout<<"3.Modify record";
	 gotoxy(12,19);
	 cout<<"4.Delete record";
	 gotoxy(12,21);
	 cout<<"5.Recall record";
	 gotoxy(12,23);
	 cout<<"6.Pack record";
	 gotoxy(12,25);
	 cout<<"0.Exit";
	 gotoxy(12,28);
	 cout<<"Your choice"<<"  ";
	 cin>>choice;
		clrscr();

	 switch(choice)
	 {
	 case '1':
	 g.addrec();
	 break;
	 case'2':
	 g.listrec();
	 break;

	 case'3':
	 g.modirec();
	 break;

	 case'4':
	 g.delrec();
	 break;

	 case'5':
	 g.recallrec();
	 break;

	 case'6':
	 g.packrec();
	 break;

	 case'0':
	 g.exit();
	 exit(1);

	 }
		 }
		 while(choice!=0);
	 }


	 void group::group()
	 {
		file.open("Emp.dat",ios::binary|ios::in|ios::out);
		p.flag=' ';
		if(!file)
		{
		cout<<endl<<"Unable to open file";
		exit();
		}

	 }
		void group::addrec()
	 {
		char ch;
		file.seekp(0L,ios::end);
	struct dosdate_t d;
	 _dos_getdate(&d);
		p.day=d.day;
		p.month=d.month;
		p.year=d.year;

		cout<<"Make shure that no employee has the same code"<<endl;
		do
		{
	 cout<<endl<<"Enter employee  code, name, age & salary 
:"<<endl<<endl;
	 cout<<"OR"<<endl<<endl;
	 cout<<"To return to the Main menu press'm' key else press'a':";
	 cin>>ch;
	 if(ch=='m'||ch=='M')
	 {
		 main();
		}
	 cin>>p.empcode>>p.name>>p.age>>p.sal;
	 p.flag=' ';
	 file.write((char*)&p,sizeof(p));
	 cout<<"Add another record ?(y/n) :";
	 cin>>ch;
	 }
	 while(ch=='y'||ch=='Y');
		 }
		 void group::listrec()
	 {
		int j=0,a;
		file.seekg(0L,ios::beg);

	cout<<"List of records present are as under>>>"<<endl<<endl;
	cout<<"             "<<"|CODE|"<<"           "<<"|NAME|"<<"
"<<"|AGE|"<<" "<<"|SALARY|"<<" "<<"|DATED|"<<endl;
		 //Donot touch Above Line Any Way it is set to give Some Nice Look
		while(file.read((char*)&p,sizeof(p)))
	 {
		if(p.flag!='*')

cout<<endl<<"Record#"<<"
"<<j++<<setw(6)<<p.empcode<<setw(20)<<p.name<<setw(4)<<p.age<<setw(9)<<p.sal<<"
 "<<p.day<<"/"<<p.month<<"/"<<p.year<<endl;
}
file.clear();

if(j==0)
{
 gotoxy(10,10);
 cout<<"No record exit";
 gotoxy(10,11);
 cout<<"Press any key...";
 getch();
}
else
{
 cout<<endl<<"Press any key...";
 getch();
}
}
void group::modirec()
{
char code[5];
int count=0;
long int pos;
cout<<"Enter employee code whose record is to be modified :";
cin>>code;
file.seekg(0L,ios::beg);
while(file.read((char*)&p,sizeof(p)))
{
 if(strcmp(p.empcode,code)==0)
 {
 cout<<endl<<"Enter new record "<<endl;
 cout<<endl<<"Enter employee name,age & salary :"<<endl;
 cin>>p.name>>p.age>>p.sal;
 struct dosdate_t d;
 _dos_getdate(&d);
 p.day=d.day;
 p.month=d.month;
 p.year=d.year;
 p.flag=' ';
 pos=count*sizeof(p);
 file.seekp(pos,ios::beg);
 file.write((char*)&p,sizeof(p));
 return;
}
 count++;
}
cout<<endl<<"No employee in file with code= "<<code;
getch();
file.clear();
}
void group::delrec()
	{
	char code[5];
	long int pos;
	int count=0;
	cout<<"Enter employee code to be deleted :";
	cin>>code;
	file.seekg(0L,ios::beg);
	while(file.read((char*)&p,sizeof(p)))
	{
	 if (strcmp(p.empcode,code)==0)
	 {
	 p.flag='*';
	 pos=count*sizeof(p);
	 file.seekp(pos,ios::beg);
	 file.write((char*)&p,sizeof(p));
	 return;
	 }
	 count++;
	 }
	 cout<<endl<<"No employee in file with code="<<code;
	 cout<<endl<<"Press any key...";
	 getch();
	 file.clear();
	 }
	void group::recallrec()
	 {
		 char code[5];
		 long int pos;
		 int count=0;

		 cout<<"Enter employee code to be recalled :";
		 cin>>code;

		 file.seekg(0L,ios::beg);

		 while(file.read((char*)&p,sizeof(p)))
		 {
		if(strcmp(p.empcode,code)==0)
		{
		p.flag=' ';
		pos=count*sizeof(p);
		file.seekp(pos,ios::beg);
		file.write((char*)&p,sizeof(p));
		return;
		}

		count++;
	}
	cout<<endl<<"No employee in the file with code="<<code;
	cout<<endl<<"Press any key...";
	getch();
	file.clear();
		 }
		 void group::packrec()
		{
		 ofstream outfile;
	outfile.open("TEMP",ios::out);
	file.seekg(0,ios::beg);
	while(file.read((char*)&p,sizeof(p)))
	{
	 if(p.flag!='*')
	 outfile.write((char*)&p,sizeof(p));
	 }
	 outfile.close();
	 file.close();
	 remove("Emp.DAT");
	 rename("TEMP","EMP.DAT");
	 
file.open("EMP.DAT",ios::binary|ios::in|ios::out|ios::nocreate);
 gotoxy(10,10);
 cout<<"Marked records to be deleted are all removed";
 gotoxy(10,11);
 cout<<"press any key....";
 getch();
 }
 void group::exit()
 {
 file.close();
}
Files and Folders using Data structure

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<conio.h>
#include<dir.h>
#include<dos.h>

struct node
{
 char *name;   /* used to get file / folder name. */
 int attrib;   /* used to get it's attribute.  */
 struct node *next;  /* concept of Linked list */
};
void main()
{
 struct node *head,*head1;
 struct node *list,*list1;
 struct node * place(struct ffblk ff,struct node *first,int don);
 void display(struct node *first);
 void print(struct node *list,int *i);
 int i,c,c1,done,done1;
 struct ffblk f,f1;
 head=NULL;
 head1=NULL;
 clrscr();
 done=findfirst("*.*",&f,FA_DIREC|FA_RDONLY|FA_HIDDEN|FA_SYSTEM|FA_ARCH);
 /* struct variable "f" contains all files and folders information */
 done1=findfirst("*.*",&f1,FA_RDONLY|FA_HIDDEN|FA_SYSTEM|FA_ARCH);
 /* struct variable "f1" contains all files information */
 head=place(f,head,done);  /* content of f is placed in struct head */
 display(head);
 /*
  Note : f contains name of files and folders with their attributes
  in f.ff_name, f.ff_attrib which is assigned to name, attrib in
  the struct node
 */
 printf("
*************************************************
");
 getch();
 head1=place(f1,head1,done1); /* content of f1 is placed in struct head1
*/
 display(head1);
 /*
  Note : f1 contains name of files and folders with their attributes
  in f1.ff_name, f1.ff_attrib which is assigned to name, attrib in
  the struct node
 */
 printf("
*************************************************

");
 getch();
 i=0;
 c1=0;
 /*
  Here, head and head1 are compared so that we could extract only
  the folders.
 */
 list=head;   /* head is assigned to list */
 while(list!=NULL)
 {
   list1=head1;  /* head1 is assigned to list1 */
   if(list1==NULL)   /* if there are 0 files */
    print(list,&i);   /* then display content of list */
   else
   {
    while(list1!=NULL)
    {
    if(strcmp(list->name,list1->name)==0)  /* compare list and list1 */
     c1=1;
    list1=list1->next;
    }
    if(c1==0)      /* if folder found both in list and list1*/
     print(list,&i);  /* then display content of list */
   }
   c1=0;
   list=list->next;
  }
 printf("
		 FOLDERS = %d",i);
 printf("
*************************************************
");
 printf("
		Where,");
 printf("
			H - Hidden");
 printf("
			D - Directory");
 printf("
			R - Read only");
 printf("
			S - System");
 printf("
			A - Archive");
 getch();
 free(list1);
 free(list);
 free(head);
 free(head1);
}

void print(struct node *list,int *i)
{
 void property(struct node *list);
 /* to display folders other than default folders (. and ..)  */
 if((strcmp(list->name,"."))!=0 && (strcmp(list->name,".."))!=0)
 {
  *i=*i+1;     /* counts number of folders */
  property(list);
  printf(" %s
",list->name);
 }
}

void property(struct node *list)
{    /* finds their attribute */
  if(list->attrib & FA_HIDDEN)
   printf("(H)");
  if(list->attrib & FA_DIREC)
   printf("(D)");
  if(list->attrib & FA_RDONLY)
   printf("(R)");
  if(list->attrib & FA_SYSTEM)
   printf("(S)");
  if(list->attrib & FA_ARCH)
   printf("(A)");
}

struct node * place(struct ffblk ff,struct node *first,int don)
{
 static int j;
 void create(struct node *first,char *ch,int d);
 void insert(struct node *first,char *ch,int d);
 int i=0,c=0;
 char *p;
 if(don!=0)
  first=NULL;
 else
 {
 while(don==0)
 {
  if(i==0)
  {
   first=(struct node *)malloc(sizeof(struct node));
   if ((p = (char *) malloc(14)) == NULL)
    exit(1);
   strcpy(p,ff.ff_name);
   create(first,p,ff.ff_attrib);
   i=1;
  }
  else
  {
   if ((p = (char *) malloc(14)) == NULL)
    exit(1);
   strcpy(p,ff.ff_name);
   insert(first,p,ff.ff_attrib);
  }
  don=findnext(&ff);
  c=c+1;
 }
 }
 if(j==0)
 {
 printf("
*************************************************
");
 printf("
		 %d FILES & FOLDERS

",c);
 j+=1;
 }
 else
 printf("
		 %d FILES

",c);
 return(first);
}

void create(struct node *first,char *ch,int d)
{
 char *p;
 if ((p = (char *) malloc(sizeof(ch))) == NULL)
  exit(1);
 p=ch;
 first->name=p;
 first->attrib=d;
 first->next=NULL;
 return;
}

void insert(struct node *first,char *ch,int d)
{
 struct node *temp,*list;
 char *p;
 list=first;
 while(list->next!=NULL)
  list=list->next;
 if ((p = (char *)malloc(sizeof(ch))) == NULL)
  exit(1);
 p=ch;
 temp=(struct node *)malloc(sizeof(struct node));
 temp->name=p;
 temp->attrib=d;
 temp->next=NULL;
 list->next=temp;
 return;
}

void display(struct node *first)
{
 struct node *list;
 void property(struct node *list);
 list=first;
 if(list==NULL)
  printf("
NULL");
 else
 {
 while(list->next!=NULL)
 {
  property(list);
  printf("%s %d
",list->name,list->attrib);
  list=list->next;
 }
  property(list);
  printf("%s %d
",list->name,list->attrib);
 }
 return;
}
Graphs program

#include <iostream.h>
#include <conio.h>

class graph
{
	private:int n;
		int **a;
		int *reach;
		int *pos;
	public:graph(int k=10);
		void create();
		void dfs();
		void dfs(int v,int label);
		int begin(int v);
		int nextvert(int v);
};
void graph::graph(int k)
{
	n=k;
	a=new int *[n+1];
	reach=new int[n+1];
	pos=new int [n+1];
	for(int i=1;i<=n;i++)
		pos[i]=0;
	for(int j=1;j<=n;j++)
		a[j]=new int[n+1];
}
void graph::create()
{
	for(int i=1;i<=n;i++)
	{
		cout<<"Enter the "<<i<<"th row of matrix a:
";
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	}
	for(int k=1;k<=n;k++)
		reach[k]=0;
}
void graph::dfs()
{
	int label=0;
	for(int i=1;i<=n;i++)
		if(!reach[i])
		{
			label++;
			dfs(i,label);
		}
	cout<<"
The contents of the reach array is:
;
	for(int j=1;j<=n;j++)
		cout<<reach[j]<<"	";
}
void graph::dfs(int v,int label)
{
	cout<<v<<"	";
	reach[v]=label;
	int u=begin(v);
	while(u)
	{
		if(!reach[u])
			dfs(u,label);
		u=nextvert(v);
	}
}
int graph::begin(int v)
{
	if((v<1)&&(v>n))
		cout<<"Bad input
";
	else
		for(int i=1;i<=n;i++)
			if(a[v][i]==1)
			{
				pos[v]=i;
				return i;
			}
	return 0;
}
int graph::nextvert(int v)
{
	if((v<1)&&(v>n))
		cout<<"Bad input
";
	else
		for(int i=pos[v]+1;i<=n;i++)
			if(a[v][i]==1)
			{
				pos[v]=i;
				return i;
			}
	return 0;
}
void main()
{
	clrscr();
	int x;
	cout<<"Enter the no of vertices:
";
	cin>>x;
	graph g(x);
	g.create();
	cout<<"dfs is.....";
	g.dfs();
	getch();
}
Implementing Queue as a Class

# include<iostream.h>
# include<conio.h>
# define SIZE 20

class queue
{
	int a[SIZE];
	int front;
	int rear;
public:
	queue();
	~queue();
	void insert(int i);
	int remove();
	int isempty();
	int isfull();
};

queue::queue()
{
front=0;
rear=0;
}
queue::~queue()
{
delete []a;
}
void queue::insert(int i)
{
if(isfull())
{
	cout<<"

******
Queue is FULL !!!
No insertion allowed further.
******
";
	return;
}
a[rear] = i;
rear++;
}
int queue::remove()
{
if(isempty())
{
	cout<<"

******
Queue Empty !!!
Value returned will be garbage.
******
";
	return (-9999);
}

return(a[front++]);
}
int queue::isempty()
{
if(front == rear)
	return 1;
else
	return 0;
}
int queue::isfull()
{
if(rear == SIZE)
	return 1;
else
	return 0;
}

void main()
{
clrscr();
queue q;
q.insert(1);
q.insert(2);
cout<<"
"<<q.remove();
cout<<"
"<<q.remove();
cout<<"
"<<q.remove();
getch();
}
Implementing Stack using Class (with constructor etc).

# include<iostream.h>
# include<conio.h>
# define SIZE 20

class stack
{
int a[SIZE];
int tos; // Top of Stack
public:
	stack();
	void push(int);
	int pop();
	int isempty();
	int isfull();
};
stack::stack()
{
tos=0; //Initialize Top of Stack
}

int stack::isempty()
{
return (tos==0?1:0);
}
int stack::isfull()
{
return (tos==SIZE?1:0);
}

void stack::push(int i)
{

if(!isfull())
{
cout<<"Pushing "<<i<<endl;
a[tos]=i;
tos++;
}
else
{
 cerr<<"Stack overflow error !
Possible Data Loss !";
}
}
int stack::pop()
{
if(!isempty())
{
cout<<"Popping "<<a[tos-1]<<endl;
return(a[--tos]);
}
else
{
cerr<<"Stack is empty! What to pop...!";
}
return 0;
}

void reverse(stack s)
{
stack s2;
while(!s.isempty())
{
	s2.push(s.pop());
}
cout<<"Reversed contents of the stack..."<<endl;
while(!s2.isempty())
{
	cout<<s2.pop()<<endl;
}
}//end of fn.
void main()
{
clrscr();
stack s;

s.push(1);
s.push(2);
s.push(3);

reverse(s);
getch();
}
Matrics Addition

#include<iostream.h>
#include<conio.h>
#include<stdio.h>

struct matrics
{
int a[4][4], m, n;
};

matrics add_mat(matrics m1, matrics m2);		//prototype declared

int main()
{
matrics x1, x2, x3;
int i, j;
cout<<"
Enter the size of matrics
";
cout<<"
Enter rows 
";
cin>>x1.m;
cout<<"
Enter columns 
";
cin>>x1.n;
cout<<"
Enter the elements (Row-wise & Column-wise)
	for(i=0; i<x1.m; i++)
	{
		for(j=0; j<x1.n; j++)
		cin>>x1.a[i][j];
	}
cout<<"
Enter the size of 2nd matrics
";
cout<<"
Enter rows
";
cin>>x2.m;
cout<<"
Enter columns
";
cin>>x2.n;
cout<<"
Enter the elements (Row-wise & column-wise)
	for(i=0; i<x2.m; i++)
	{
		for(j=0; j<x2.n; j++)
		cin>>x2.a[i][j];
	}
x3=add_mat(x1,x2);
cout<<"
The added matrics is
";
	for(i=0; i<x3.m; i++)
	{
		for(j=0; j<x3.n; j++)
		cout<<x3.a[i][j]<<" ";
	}

matrics add_mat(matrics m1, matrics m2)
{
matrics m3;		//object of matrics type
int k, l;
if((m1.m==m2.m) && (m1.n==m2.n))
	{  m3.m=m1.m+m2.m;
	   m3.n=m1.n+m2.n;
	}

	for(k=0; k<m1.m; k++)
	{
		for(l=0; l<m1.n; l++)
		m3.a[k][l]=m1.a[k][l]+m2.a[k][l];
	return (m3);
	}
}//		end of If loop

else
cout<<"
Addition is not possible
";
}
Queue implementation using linked list

#include <iostream.h>
#include <conio.h>
#include <stdlib.h>

struct node
 {  char name[20];
    int age;
    float height;
    node *nxt;
 };
node *start_ptr=NULL;

int main()
{

  void push ();
  void pop();
  char ch;
  clrscr();
  cout<<"Queue
";
  cout<<"-----";

  do
  {
   cout<<"
Select an operation";
   cout<<"
u->push
";
   cout<<"o->pop
";
   cout<<"e->exit
";

   cin>>ch;

   switch(ch)
   {
    case 'u':
                     push();
                     break;
    case 'o':
                     pop();
                     break;
    case 'e':
                     exit(0);
   }
   }while(ch!='e');

                return 0;

}

void pop()
{
 node *temp1,*temp2;
 if(start_ptr==NULL)
   cout<<"The list is empty
";
 else
  {
   temp1=start_ptr;
   temp2=temp1;
  while(temp1->nxt!=NULL)
   {
    temp2=temp1;
    temp1=temp1->nxt;
   }
  if(temp1==temp2)
    {
     cout<<temp1->name<<",";
     cout<<temp1->age<<", ";
     cout<<temp1->height;
     start_ptr=NULL;
    }
  else
    {
     cout<<temp1->name<<", ";
     cout<<temp1->age<<", ";
     cout<<temp1->height;
     temp2->nxt=NULL;
     delete temp1;
    }
 }
}

void push ()
 {
    node *temp;

    temp = new node;
    cout << "Please enter the name of the person: ";
    cin >> temp->name;
    cout << "Please enter the age of the person: ";
    cin >> temp->age;
    cout << "Please enter the height of the person: ";
    cin >> temp->height;
    if (start_ptr == NULL)
                {
                 temp->nxt=NULL;
                 start_ptr = temp;
                }
    else
                {
      temp->nxt=start_ptr;
      start_ptr=temp;

                }
  }
Quick Sort Implementation

#include<process.h>
#include<iostream.h>
#include<conio.h>
#include<stdlib.h>

int Partition(int low,int high,int arr[]);
void Quick_sort(int low,int high,int arr[]);

void main()
{
int *a,n,low,high,i;
clrscr();
cout<<"/**************************Quick Sort Algorithm
Implementation*****************/

";
cout<<"Enter number of elements:
";
cin>>n;

a=new int[n];
/* cout<<"enter the elements:
";
for(i=0;i<n;i++)
cin>>a;*/
for(i=0;i<n;i++)
a[i]=rand()%100;
clrscr();
cout<<"
Initial Order of elements
";
 for(i=0;i<n;i++)
  cout<<a[i]<<"	";
  cout<<"
";

high=n-1;
low=0;
Quick_sort(low,high,a);
cout<<"
Final Array After Sorting:
";

  for(i=0;i<n;i++)
  cout<<a[i]<<"	";

getch();
}

/*Function for partitioning the array*/

int Partition(int low,int high,int arr[])
{ int i,high_vac,low_vac,pivot/*,itr*/;
   pivot=arr[low];
   while(high>low)
{ high_vac=arr[high];

  while(pivot<high_vac)
  {
    if(high<=low) break;
    high--;
    high_vac=arr[high];
  }

  arr[low]=high_vac;
  low_vac=arr[low];
  while(pivot>low_vac)
  {
    if(high<=low) break;
    low++;
    low_vac=arr[low];
  }
  arr[high]=low_vac;
}
  arr[low]=pivot;
   return low;
}

void Quick_sort(int low,int high,int arr[])
{
  int Piv_index,i;
  if(low<high)
  {
   Piv_index=Partition(low,high,arr);
   Quick_sort(low,Piv_index-1,arr);
   Quick_sort(Piv_index+1,high,arr);
  }
}
Stack implementation as a class.

# include<iostream.h>
# include<process.h>
# include<conio.h>
# define SIZE 20

class stack
{
int a[SIZE];
int tos; // Top of Stack
public:
	stack();
	void push(int);
	int pop();
	int isempty();
	int isfull();
};
stack::stack()
{
tos=0; //Initialize Top of Stack
}

int stack::isempty()
{
return (tos==0?1:0);
}
int stack::isfull()
{
return (tos==SIZE?1:0);
}

void stack::push(int i)
{
if(!isfull())
{
a[tos]=i;
tos++;
}
else
{
 cerr<<"Stack overflow error !
Possible Data Loss !";
}
}
int stack::pop()
{
if(!isempty())
{
return(a[--tos]);
}
else
{
cerr<<"Stack is empty! What to pop...!";
}
return 0;
}

void main()
{
stack s;
int ch=1,num;
while(ch!=0)
{
	cout<<"Stack Operations Mani Menu
1.Push
2.Pop
3.IsEmpty
4.IsFull
0.Exit

";
	cin>>ch;
	switch(ch)
	{
	case 0:
		exit(1); //Normal Termination of Program
	case 1:
		cout<<"Enter the number to push";
		cin>>num;
		s.push(num);
		break;
	case 2:
		cout<<"Number popped from the stack is: "<<s.pop()<<endl;
		break;
	case 3:
		(s.isempty())?(cout<<"Stack is empty.
"):(cout<<"Stack is not empty.
");
		break;
	case 4:
		(s.isfull())?(cout<<"Stack is full.
"):(cout<<"Stack is not full.
");
		break;
	default:
		cout<<"Illegal Option.
Please try again
";
	}
}//end of while
getch();
}
Stack With OOP and Exception Handling Concept

#ifndef STACK_H
#define STACK_H

template <class A>
class Stack
{
public:
	virtual void makeNewStack(int) = 0 ;
	virtual void push(A) = 0 ;
	virtual A pop() = 0 ;
	virtual bool isEmpty() = 0 ;
	virtual bool isFull() = 0 ;
	virtual A topOfStack() = 0 ;
	virtual void display() = 0 ;
	virtual ~Stack(){}
	virtual A traverse() = 0 ;
	virtual bool endTrav() = 0 ;
	virtual void resetTrav() = 0 ;
} ;
#endif

#ifndef STATICSTACK_H
#define STATICSTACK_H

#include <stdlib.h>
#include "Stack.h"
#include "StackExceptions.h"
#include <iostream>
#include<string>
using namespace std ;

template <class T>
class StaticStack : public Stack<T>
{
private:
	int top ;
	int size ;
	T* array ;
	int trav;

public:

	StaticStack()
	{
	top = -1 ;
	size = 0 ;
	array = NULL ;
	trav = 0 ;

	}

	StaticStack(int s)
	{
	top = -1 ;
	size = s ;
	array = new T[size] ;
	trav = 0 ;
	}

	virtual void makeNewStack(int s)
	{
	delete[] array ;
	top = -1 ;
	trav = 0 ;
	size = s ;
	array = new T[size] ;

	}

	virtual void push(T arg)
	{
	if(isFull())
	{
	throw StackFull("The Stack is Full") ;
	}
	else
	{
	if(top == -1)
	{
	top = top + 1 ;
	array[top] = arg;
	top++;
	}
	else
	{
	array[top] = arg ;
	top++ ;
	}
	}
	}

	virtual T pop()
	{
	if(isEmpty())
	{
	throw StackEmpty("The Stack is Empty") ;
	}

	else
	{
	top-- ;
	if(top == -1)
	{
	throw StackEmpty("The Stack is Empty") ;
	}
	else
	{

	return array[top] ;
	}
	}
	}

	virtual T traverse()
	{
	/*	if( trav == top )
	{
	char ch;
	cout<<"

	 The value of Traverse reach at it`s Peak";
	cout<<"
		 May you Want to Reset The Traverse (y/n) : ";
	cin>>ch;
	if(ch=='y')
	resetTrav();*/
	}
	if(endTrav())
	{
	throw CantTrav("Transverse Cant Proceed");
	}
	else
	{
	if( trav > top )
	{
	trav = trav - 2 ;
	if(trav == -1)
	throw CantTrav("Transverse Cant Proceed Because The Stack Is Empty");
	else
	{
	return array[trav++];
	}
	}
	else if(trav == top)
	{
	trav = trav - 2 ;
	if(trav == -1)
	throw CantTrav("Transverse Cant Proceed Because The Stack Is Empty");
	else
	{
	return array[trav];
	}

	}
	else
	{
	if(trav == -1)
	throw CantTrav("Transverse Cant Proceed Because The Stack Is Empty");
	else
	{
	return array[trav++];
	}
	}
	}
	}

	virtual bool endTrav()
	{
	if(top == -1)
	{
	return (trav == top + 1) ;
	}
	else
	return (trav == top) ;
	}

	virtual void resetTrav()
	{
	trav = 0;
	}

	virtual bool isEmpty()
	{
	return (top == -1) ;
	}

	virtual bool isFull()
	{
	return (top == size) ;
	}

	virtual T topOfStack()
	{
	if(isEmpty())
	{
	throw StackEmpty("The Stack is Empty") ;
	}
	else
	{
	return (array[top - 1]) ;
	}
	}

	virtual void display()
	{
	int i = -1;
	cout << endl ;
	for(i = i+1 ; i < top ; i++)
	{
	cout << array[i] << '	' ;
	}
	cout << endl ;
	}

	virtual ~StaticStack()
	{

	delete[] array ;
	top = 0 ;
	size = 0 ;
	array = NULL ;
	}
} ;

#endif

#ifndef STACKEXCEPTIONS_H
#define STACKEXCEPTIONS_H

#include <exception>
using namespace std ;

class StackEmpty : public exception
{
public:
	StackEmpty(char* c) : exception(c)
	{}
} ;

class StackFull : public exception
{
public:
	StackFull(char* c) : exception(c)
	{}
} ;
class CantTrav : public exception
{
public:
	CantTrav(char* c) : exception(c)
	{}
};

#endif
#include "StaticStack.h"
//#include "StackExceptions.h"
#include <iostream>
using namespace std ;

void main()
{
	int size;
	cout<<"
 Enter the Maximum Size of Stack : ";
	cin>>size;
	Stack<int>* S = new StaticStack<int>(size) ;

	int choice ;
	int data ;
	bool cont = true ;

	while(cont)
	{
	try
	{

	cout<< endl << "Enter 1 push()"
	<< endl << "Enter 2 to pop()"
	<< endl << "Enter 3 to display()"
	<< endl << "Enter 4 to exit"
	<< endl << "Enter 5 to transverse"
	<< endl << "Enter 6 to reset the transverse" << endl;

	cin >> choice ;
	switch(choice)
	{
	case 1:
	cout << endl << "Enter value to push in stack 
" ;
	cin >> data ;
	S->push(data) ;
	break ;
	case 2:
	  data = S->pop() ;
	  cout << "The value returned is : " << data ;
	  break ;

	case 3:
	  S->display() ;
	  break ;

	case 4:
	  cont = false ;
	  break ;
	case 5:
	  data = S->traverse();
	  cout<< "The value returned is : "<<data << endl << endl;
	  break;
	case 6:
	      S->resetTrav();
	  break;
	default:
	cout <<endl<< "wrong value entered, try again" << endl ;
	}// switch ends

	}
	catch(exception e)
	{
	cout << endl << e.what() << endl ;
	}
	} // while loop ends

	delete S ;
}
Ticket window - Program Using Queue

#include <iostream.h>
#include <conio.h>
#include <process.h>

class ticketqueue{
private:
   //Data Members
		 int q[5];
		 int front, rear, noe;  //noe..to store number of elements

public:
   //Member Functions
		 ticketqueue(){ noe = rear = front = 0;} //Constructor
		 void enqueue(int);
		 void ticketchecker();
		 void print();
		 int isempty();
		 void queuebuilder();
		 void menu();
};
/////////////////////
void ticketqueue :: enqueue(int a)
{
		 		 q[rear] = a;
		 		 rear++;
		 		 noe++;
		 		 if (rear == 5)
		 		 		 rear = 0;
		 		 cout<<"
"<<a<<" Is Enqeueued....."<<endl;
}
/////////////////////
void ticketqueue :: ticketchecker()
{
clrscr();
		 int not,rt;
		 if ( !isempty() )
		 		 {
		 		 		 not = q[front];
		 		 		 if (not > 2)
		 		 		 		 {
		 		 		 		 		 rt = not - 2;
		 		 		 		 		 if ( rt > 0 )
		 		 		 		 		 		 {
		 		 		 		 		 		 		 enqueue(rt);
		 		 		 		 		 		 		 front++;
		 		 		 		 		 		 		 cout<<"

"<<not<<"# Tickets were demanded. 2 Tickets are
given.
"
		 		 		 		 		 		 		  <<"
Enqueued again for next go to get remaining #"<<rt<<"
Tickets"<<endl;
		 		 		 		 		 		 }
		 		 		 		 		 else if ( rt <= 0 )
		 		 		 		 		 		 front++;
		 		 		 		 		 		 noe--;

		 		 		 		 }
		 		 		 else if ( not <= 2 )
		 		 		 		   {
		 		 		 		 		  front++;
		 		 		 		 		  noe--;
		 		 		 		 		 cout<<"
"<<not<<"# tickets are given...."<<endl;
		 		 		 		   }
		 		 		 }
		 else
		 		 cout<<"
!!! NO REQUEST IN THE QUEUE " <<endl;

getch();
clrscr();
menu();
}
/////////////////////
void ticketqueue :: print()
{
clrscr();
		 int i = front;
		 if ( noe > 0 )
		 		 {
		 		 		 cout<<"
REQUESTS ENQUEUED ARE :" ;
		 		 		 do
		 		 		 		 {
		 		 		 		 		 cout<<q[i]<<" ";
		 		 		 		 		 i++;
		 		 		 		 		 if ( i == 5 )
		 		 		 		 		 		 i = 0;
		 		 		 		 }
		 		 		 while ( i != rear );
		 		 }
		 else
		 		 cout<<"
NO REQUEST IN QUEUE...QUEUE IS EMPTY ";
getch();
clrscr();
menu();
}
//////////////////

//Utility Fuction
int ticketqueue :: isempty()
{
		 if ( noe == 0 )
		 		 return 1;
		 else
		 		 return 0;
}
/////////////////

//This Function takes input from the user and shows Queue graphically

void ticketqueue::queuebuilder(){
   clrscr();
   int tickets, z = 0, i = 0, x = 20, y = 10, g = 1, h = 17;
   char c;
   cout<<"Enter number of tickets to purchase... "<<endl;
   while (!(c == 'E' || c == 'e'))
		 {
		 		  if ( z > 4)
		 		 		 {
		 		 		 		 clrscr();
		 		 		 		 cout<<" 

 ERROR!!! Queue Size Violation...Exiting Now  "<<endl;
		 		 		 		 getch();
		 		 		 		 clrscr();
		 		 		 menu();
		 		 		 }

		 		  else
		 		 		 {
		 		 		 		 cout<<"
Enter : ";
		 		 		 		 cin>>tickets;
		 		 		 		 enqueue(tickets);
		 		 		 		 z++;
		 		 		 		 gotoxy(17,10);
		 		 		 		 cout<<"->";
		 		 		 		 gotoxy(20,9);
		 		 		 		 cout<<"----------------------------------";
		 		 		 		 gotoxy(x,y);
		 		 		 		 cout<<q[i];
		 		 		 		 x+=2;
		 		 		 		 gotoxy(20,11);
		 		 		 		 cout<<"----------------------------------";
		 		 		 		 gotoxy(g,h);
		 		 		 		 cout<<"PRESS C/c to CONTINUE E/e to END: ";
		 		 		 		 cin>>c;
		 		 		 		 h += 6;

		 		 		 		 i++;
		 		 		 }
		 }
getch();
clrscr();
menu();
}
//////////////////
void ticketqueue::menu()
{
int b;
gotoxy(15,5);
 cout<<"Press 1................ENTER NO OF TICKETS
";
gotoxy(15,8);
		  cout<<"Press 2................TICKET CHECKER
";
gotoxy(15,11);
		 cout<<"Press 3................ALL TICKET REQUESTS
";
gotoxy(15,15);
		 cout<<"Press 4................EXIT
";
gotoxy(15,18);
		 cout<<"NOW ENTER : ";

		 cin>>b;

if ( b == 1 )
		 queuebuilder();
else if ( b == 2 )
		 ticketchecker();
else if ( b == 3 )
		 print();
else if ( b == 4 )
		 exit(1);
}
//////////////////


void main()
{
clrscr();
ticketqueue t;
t.menu();
getch();
}
Tower of hanoi

#include<iostream>		//the c++ standard library for stream input output
#include<cstdio>		//the c standard library for standard input output
#include<cstdlib>		//for the exit function
using namespace std;

class arr			//arr class that holds each stag
{
	public:
	int a[100],b[100],c[100];
	int topa,topb,topc;
}hanoi;
int move=1;			//counts the no. of moves
int main()
{
	void tower(int ,int *,int *,int *,int *,int *,int *);		//function
prototype
	void show(int);							//function prototype
	int i;
	system("clear");
	cout<<"Enter the no of elements for which u want to solve the 
problem
";
	scanf("%d",&i);
	system("clear");
	for(int j=0;j<i;j++)					//feeds the elements in the arrs;
	{
		hanoi.a[j]=j+1;
		hanoi.b[j]=-1;
		hanoi.c[j]=-1;
	}
	hanoi.topa=i-1;						//topa,topb,topc,mean the top of each arr
	hanoi.topb=-1;
	hanoi.topc=-1;
	cout<<"	    Initially "<<"
";
	for(int j=i-1;j>-1;j--)					//show the statusm of each arr
	{
		show(hanoi.a[j]);
		show(hanoi.b[j]);
		show(hanoi.c[j]);
		cout<<"
";
	}
	cout<<"


";

tower(i,hanoi.a,hanoi.c,hanoi.b,&(hanoi.topa),&(hanoi.topc),&(hanoi.topb))
;	//call to do the job
}

void tower(int n,int src[],int dest[],int aux[],int *ts,int *td,int 
*ta)
//the tower function passes
{										//the arrs along with the top pointers
	void show (int);
	if(n==1)								//if one element is there in source arr ,
	{									//then it is moved to the destination arr,
		dest[++(*td)]=src[(*ts)];
		src[*ts]=-1;
		(*ts)--;
		int max;
		max=((*ts)>(*td)?(*ts):(*td));
		max=(max>(*ta)?max:(*ta));
		cout<<"	    Move "<<move++<<"
";
		for(int i=max;i>-1;i--)						//status of arrs shown
		{
			show(hanoi.a[i]);
			show(hanoi.b[i]);
			show(hanoi.c[i]);
			cout<<"
";
		}
		cout<<"


";
		return;
	}
	tower(n-1,src,aux,dest,ts,ta,td);					//else the
	tower(1,src,dest,aux,ts,td,ta);						//	problem is solved by
	tower(n-1,aux,dest,src,ta,td,ts);					//			recursive calls

}

void show(int a)					//the show function shows the current status of 
the
arrs
{
	if(a==-1)
		cout<<"-		";
	else
		cout<<a<<"		";
}
Add and subtract two polynomials (Using Linked List)

#include<iostream.h>
#include<conio.h>
#include<process.h>

//   Creating a NODE Structure
struct node
{
   int coe,exp;        // data
   struct node *next;  // link to next node and previous node
};

// Creating a class Polynomial
class polynomial
{
   struct node *start,*ptrn,*ptrp;
   public:
     void get_poly(); // to get a polynomial
     void show();     // show
     void add(polynomial p1,polynomial p2); // Add two polynomials
     void subtract(polynomial p1,polynomial p2); //Subtract2 
polynomials
};

void polynomial::get_poly()      //  Get Polynomial
{
   char c='y';
   ptrn=ptrp=start=NULL;
   while(c=='y' || c=='Y')
   {
      ptrn=new node;
      ptrp->next=ptrn;
      if(start==NULL)
	start=ptrn;
      ptrp=ptrn;
      cout<<"
Enter the coefficient: ";
      cin>>ptrn->coe;
      cout<<"Enter the exponent: ";
      cin>>ptrn->exp;
      ptrn->next=NULL;
      cout<<"Enter y to add more nodes: ";
      cin>>c;
   }
   return;
}


void polynomial::show()  // Show Polynomial
{
    struct node *ptr;
    ptr=start;
    while(ptr!=NULL)
    {
       cout<<ptr->coe<<"X^"<<ptr->exp<<" + ";
       ptr=ptr->next;
    }
    cout<<" ";
}

void polynomial::add(polynomial p1,polynomial p2)  // Add Polynomials
{
   struct node *p1ptr,*p2ptr;
   int coe,exp;
   ptrn=ptrp=start=NULL;
   p1ptr=p1.start;
   p2ptr=p2.start;
   while(p1ptr!=NULL && p2ptr!=NULL)
   {
      if(p1ptr->exp==p2ptr->exp) // If coefficients are equal
      {
	 coe=p1ptr->coe+p2ptr->coe;
	 exp=p1ptr->exp;
	 p1ptr=p1ptr->next;
	 p2ptr=p2ptr->next;
      }
      else if(p1ptr->exp>p2ptr->exp)
      {
	 coe=p1ptr->coe;
	 exp=p1ptr->exp;
	 p1ptr=p1ptr->next;
      }
      else if(p1ptr->exp<p2ptr->exp)
      {
	 coe=p2ptr->coe;
	 exp=p2ptr->exp;
	 p2ptr=p2ptr->next;
      }
      ptrn=new node;
      if(start==NULL)
	 start=ptrn;
      ptrn->coe=coe;
      ptrn->exp=exp;
      ptrn->next=NULL;
      ptrp->next=ptrn;
      ptrp=ptrn;
   } // End of While
   if(p1ptr==NULL)
   {
      while(p2ptr!=NULL)
      {
	 coe=p2ptr->coe;
	 exp=p2ptr->exp;
	 p2ptr=p2ptr->next;
	 ptrn=new node;
	 if(start==NULL)
	    start=ptrn;
	 ptrn->coe=coe;
	 ptrn->exp=exp;
	 ptrn->next=NULL;
	 ptrp->next=ptrn;
	 ptrp=ptrn;
      }
   }
   else if(p2ptr==NULL)
   {
      while(p1ptr!=NULL)
      {
	 coe=p1ptr->coe;
	 exp=p1ptr->exp;
	 p1ptr=p1ptr->next;
	 ptrn=new node;
	 if(start==NULL)
	    start=ptrn;
	 ptrn->coe=coe;
	 ptrn->exp=exp;
	 ptrn->next=NULL;
	 ptrp->next=ptrn;
	 ptrp=ptrn;
      }
   }
}  // End of addition

//  Subtract two polynomials
void polynomial::subtract(polynomial p1,polynomial p2)  // Subtract
{
   struct node *p1ptr,*p2ptr;
   int coe,exp;
   ptrn=ptrp=start=NULL;
   p1ptr=p1.start;
   p2ptr=p2.start;
   while(p1ptr!=NULL && p2ptr!=NULL)
   {
      if(p1ptr->exp==p2ptr->exp) // If coefficients are equal
      {
	 coe=p1ptr->coe-p2ptr->coe;
	 exp=p1ptr->exp;
	 p1ptr=p1ptr->next;
	 p2ptr=p2ptr->next;
      }
      else if(p1ptr->exp>p2ptr->exp)
      {
	 coe=p1ptr->coe;
	 exp=p1ptr->exp;
	 p1ptr=p1ptr->next;
      }
      else if(p1ptr->exp<p2ptr->exp)
      {
	 coe=0-p2ptr->coe;
	 exp=p2ptr->exp;
	 p2ptr=p2ptr->next;
      }
      ptrn=new node;
      if(start==NULL)
	 start=ptrn;
      ptrn->coe=coe;
      ptrn->exp=exp;
      ptrn->next=NULL;
      ptrp->next=ptrn;
      ptrp=ptrn;
   } // End of While
   if(p1ptr==NULL)
   {
      while(p2ptr!=NULL)
      {
	 coe=0-p2ptr->coe;
	 exp=p2ptr->exp;
	 p2ptr=p2ptr->next;
	 ptrn=new node;
	 if(start==NULL)
	    start=ptrn;
	 ptrn->coe=coe;
	 ptrn->exp=exp;
	 ptrn->next=NULL;
	 ptrp->next=ptrn;
	 ptrp=ptrn;
      }
   }
   else if(p2ptr==NULL)
   {
      while(p1ptr!=NULL)
      {
	 coe=p1ptr->coe;
	 exp=p1ptr->exp;
	 p1ptr=p1ptr->next;
	 ptrn=new node;
	 if(start==NULL)
	    start=ptrn;
	 ptrn->coe=coe;
	 ptrn->exp=exp;
	 ptrn->next=NULL;
	 ptrp->next=ptrn;
	 ptrp=ptrn;
      }
   }
}  // End of subtraction


int main()
{
   clrscr();
   polynomial p1,p2,sum,diff;
   cout<<"First Polynomial.
";
   p1.get_poly();
   cout<<"
Second polynomial.
";
   p2.get_poly();
   clrscr();
   cout<<"
The First polynomial is: ";
   p1.show();
   cout<<"
The second polynomial is: ";
   p2.show();
   cout<<"

The sum of two polynomials is: ";
   sum.add(p1,p2);
   sum.show();
   cout<<"

The difference of two polynomials is: ";
   diff.subtract(p1,p2);
   diff.show();
   getch();
   return 0;
}
To add and subtract two sparse matrices.
Give two matrices in its simple form.

#include<stdio.h>
#include<iostream.h>
#include<conio.h>

int main()
{
   clrscr();
   int sparse1[10][3],sparse2[10][3],sum[10][3],diff[10][3];
   int m,n,p,q,t1,t2,s,d,element;
   int i,j;
   cout<<"Enter the number of rows and columns : ";
   cin>>m>>n;
   t1=t2=0;

   cout<<"
Enter the first matrix("<<m<<"*"<<n<<"):
";
   for(i=1;i<=m;i++)
   {
      for(j=1;j<=n;j++)
      {
	 cin>>element;
	 if(element!=0)
	 {
	    t1=t1+1;
	    sparse1[t1][1]=i;
	    sparse1[t1][2]=j;
	    sparse1[t1][3]=element;
	 }
      }
   }
   sparse1[0][1]=m;
   sparse1[0][2]=n;
   sparse1[0][3]=t1;
   cout<<"
Enter the second matrix("<<m<<"*"<<n<<"):
";
   for(i=1;i<=m;i++)
   {
      for(j=1;j<=n;j++)
      {
	 cin>>element;
	 if(element!=0)
	 {
	    t2=t2+1;
	    sparse2[t2][1]=i;
	    sparse2[t2][2]=j;
	    sparse2[t2][3]=element;
	 }
      }
   }
   sparse2[0][1]=m;
   sparse2[0][2]=n;
   sparse2[0][3]=t2;

   // displaying the first sparse matrix
   cout<<"

The first sparse matrix is :

Row	Column	Element";
   cout<<"
-----------------------
";
   for(i=0;i<=t1;i++)
   {
      
cout<<sparse1[i][1]<<"	"<<sparse1[i][2]<<"	"<<sparse1[i][3]<<"
";
   }
    // displaying the second sparse matrix
   cout<<"

The second sparse matrix is :

Row	Column	Element";
   cout<<"
-----------------------
";
   for(i=0;i<=t2;i++)
   {
      
cout<<sparse2[i][1]<<"	"<<sparse2[i][2]<<"	"<<sparse2[i][3]<<"
";
   }

   // Addition and subtraction
   i=j=s=d=1;
   while((i<=t1)&&(j<=t2))
   {
      if(sparse1[i][1]==sparse2[j][1])    // if rows are equal
      {
	 if(sparse1[i][2]==sparse2[j][2]) // if columns are equal
	 {
	    sum[s][1]=diff[d][1]=sparse1[i][1];
	    sum[s][2]=diff[d][2]=sparse1[i][2];
	    sum[s][3]=sparse1[i][3]+sparse2[j][3];
	    diff[d][3]=sparse1[i][3]-sparse2[j][3];
	    i++;
	    j++;
	    if(sum[s][3]!=0)
	       s++;
	    if(diff[d][3]!=0)
	       d++;
	 }
	 else   // if columns are not equal
	 {
	    if(sparse1[i][2]<sparse2[j][2])
	    {
	       sum[s][1]=diff[d][1]=sparse1[i][1];
	       sum[s][2]=diff[d][2]=sparse1[i][2];
	       sum[s][3]=diff[d][3]=sparse1[i][3];
	       i++;
	       s++;
	       d++;
	    }
	    else
	    {
	       sum[s][1]=diff[d][1]=sparse2[j][1];
	       sum[s][2]=diff[d][2]=sparse2[j][2];
	       sum[s][3]=sparse2[j][3];
	       diff[d][3]=0-sparse2[j][3];
	       j++;
	       d++;
	       s++;
	    }
	 }
      }
      else   //   if rows are not equal
      {
	 if(sparse1[i][1]<sparse2[j][1])
	 {
	    sum[s][1]=diff[d][1]=sparse1[i][1];
	    sum[s][2]=diff[d][2]=sparse1[i][2];
	    sum[s][3]=diff[d][3]=sparse1[i][3];
	    i++;
	    d++;
	    s++;
	 }
	 else
	 {
	    sum[s][1]=diff[d][1]=sparse2[j][1];
	    sum[s][2]=diff[d][2]=sparse2[j][2];
	    sum[s][3]=sparse2[j][3];
	    diff[d][3]=0-sparse2[j][3];
	    j++;
	    s++;
	    d++;
	 }
      }
   }  // end of while
   if(i<=t1)
   {
      for(p=i;p<=t1;p++)
      {
	 sum[s][1]=diff[d][1]=sparse1[p][1];
	 sum[s][2]=diff[d][2]=sparse1[p][2];
	 sum[s][3]=diff[d][3]=sparse1[p][3];
	 s++;
	 d++;
      }
   }
   else if(j<=t2)
   {
      for(p=j;p<=t2;p++)
      {
	 sum[s][1]=diff[d][1]=sparse2[p][1];
	 sum[s][2]=diff[d][2]=sparse2[p][2];
	 sum[s][3]=sparse2[p][3];
	 diff[d][3]=0-sparse2[j][3];
	 s++;
	 d++;
      }
   }
  // end of addition and subtraction
  sum[0][1]=diff[0][1]=m;
  sum[0][2]=diff[0][2]=n;
  sum[0][3]=s-1;
  diff[0][3]=d-1;

  // displaying the sum matrix
   cout<<"

The sum is :

Row	Column	Element";
   cout<<"
-----------------------
";
   for(i=0;i<s;i++)
   {
      cout<<sum[i][1]<<"	"<<sum[i][2]<<"	"<<sum[i][3]<<"
";
   }
    // displaying the difference matrix
   cout<<"

The difference is :

Row	Column	Element";
   cout<<"
-----------------------
";
   for(i=0;i<d;i++)
   {
      cout<<diff[i][1]<<"	"<<diff[i][2]<<"	"<<diff[i][3]<<"
";
   }
   getch();
   return 0;
}
Appending two linked list based upon two data members
of individual linked list objects.

Code :

class CClass1
{
public:
	char mStringData[10];;

	long int mDataMember1;
	long int mDataMember2;
	CClass1 *structpNextValue;

	void SetValue(CString string, long int a, long int b)
	{
		strcpy(mStringData, string);
		mDataMember1 = a;
		mDataMember2 = b;
	}
	CClass1(void);
	~CClass1(void);
};
///////////////////////////////////////////////////////////////////////
class CClass2
{
public:

	char mStringData[10];
	long int mDataMember1;
	long int mDataMember2;

	CClass2 *structpNextValue;

	void SetValue(CString string, long int a, long int b)
	{
		strcpy(mStringData, string);
		mDataMember1 = a;
		mDataMember2 = b;
	}

	CClass2(void);
	~CClass2(void);
};
///////////////////////////////////////////////////////////////////////

                CClass1	*pstrTemp;

		lTemp = lNumOrphanRecord;

		pstrTemp = (CClass1*)malloc(sizeof(CClass1));
		pstrTemp->structpNextValue = NULL;

 		CClass2 *pstrExcTemp = &mObject2[0];

		while(lTemp > 0)
		{
			pstrTemp->mDataMember1	    = pstrExcTemp->mDataMember1;
			strcpy(pstrTemp->mStringData, pstrExcTemp->mStringData);
			pstrTemp->mDataMember2		= pstrExcTemp->mDataMember2;

			pstrExcTemp = pstrExcTemp->structpNextValue;


			if (mObject1->mDataMember1 == 0)
			{
				mObject1 = pstrTemp;
			}
			else
			{
				CClass1	*pstrPrev = NULL;
				CClass1	*pstrCurr = mObject1;
				long int tempSeqNum = mObject1->mDataMember1;
				int Icount=0;

				while ( (pstrCurr) &&(pstrCurr->mDataMember1 !=0) &&
(pstrCurr->mDataMember1 < pstrTemp->mDataMember1) )
				{
 					pstrPrev = pstrCurr;
					pstrCurr = pstrCurr->structpNextValue;
				}

				if ((pstrCurr) && (pstrCurr->mDataMember1 == 
pstrTemp->mDataMember1) )
				{
					if (pstrCurr->mDataMember2 < pstrTemp->mDataMember2)
					{
						pstrTemp->structpNextValue = pstrCurr->structpNextValue;
						free(pstrCurr);
						pstrCurr = pstrTemp;

						if (tempSeqNum == pstrTemp->mDataMember1)
						{
							mObject1 = pstrCurr;
						}
						if(pstrPrev)
						{
							pstrPrev->structpNextValue = pstrCurr;
						}
					}
					if(!pstrTemp)
						pstrTemp = NULL;

					lNumOrphanRecord--;

				}
			else
			{
				if (pstrPrev)
				{
					pstrPrev->structpNextValue = pstrTemp;
					pstrTemp->structpNextValue = pstrCurr;
				}
				else
				{
					pstrTemp->structpNextValue = pstrCurr;
					mObject1 = pstrTemp;
				}
			}
			}
			pstrTemp = (CClass1*)malloc(sizeof(CClass1));
			pstrTemp->structpNextValue = NULL;
			lTemp--;
		}

		lNumRecord += lNumOrphanRecord;
		pstrExcTemp = &mObject2[0];
		pstrExcTemp = pstrExcTemp->structpNextValue;

		while(mObject2->structpNextValue != NULL)
		{
			pstrExcTemp = mObject2->structpNextValue;
			mObject2->structpNextValue = pstrExcTemp->structpNextValue;
		        if(!pstrExcTemp)
			  pstrExcTemp = NULL;
		}


AVL tree with insertion, deletion and balancing height

# include <iostream.h>
# include <stdlib.h>
# include <conio.h>

struct node
{
   int element;
   node *left;
   node *right;
   int height;
};

typedef struct node *nodeptr;

class bstree
{

   public:
	void insert(int,nodeptr &);
	void del(int, nodeptr &);
	int deletemin(nodeptr &);
	void find(int,nodeptr &);
	nodeptr findmin(nodeptr);
	nodeptr findmax(nodeptr);
	void copy(nodeptr &,nodeptr &);
	void makeempty(nodeptr &);
	nodeptr nodecopy(nodeptr &);
	void preorder(nodeptr);
	void inorder(nodeptr);
	void postorder(nodeptr);
	int bsheight(nodeptr);
	nodeptr srl(nodeptr &);
	nodeptr drl(nodeptr &);
	nodeptr srr(nodeptr &);
	nodeptr drr(nodeptr &);
	int max(int,int);
	int nonodes(nodeptr);
};

//		Inserting a node
void bstree::insert(int x,nodeptr &p)
{
   if (p == NULL)
   {
	p = new node;
	p->element = x;
	p->left=NULL;
	p->right = NULL;
	p->height=0;
	if (p==NULL)
		cout<<"Out of Space";
   }
   else
   {
	if (x<p->element)
	{
	   insert(x,p->left);
	   if ((bsheight(p->left) - bsheight(p->right))==2)
	   {
	      if (x < p->left->element)
		p=srl(p);
	      else
		p = drl(p);
	   }
	}
	else if (x>p->element)
	{
	      insert(x,p->right);
	      if ((bsheight(p->right) - bsheight(p->left))==2)
	      {
		if (x > p->right->element)
			p=srr(p);
		else
			p = drr(p);
	     }
	}
	else
		cout<<"Element Exists";
	}
	int m,n,d;
	m=bsheight(p->left);
	n=bsheight(p->right);
	d=max(m,n);
	p->height = d + 1;

}

//		Finding the Smallest
nodeptr bstree::findmin(nodeptr p)
{
	if (p==NULL)
	{
	    cout<<"
Empty Tree
";
	    return p;
	}
	else
	{
	   while(p->left !=NULL)
		p=p->left;
	   return p;
	}
}

//		Finding the Largest
nodeptr bstree::findmax(nodeptr p)
{
	if (p==NULL)
	{
	   cout<<"
Empty Tree
";
	   return p;
	}
	else
	{
	   while(p->right !=NULL)
	       p=p->right;
	   return p;
	}
}

//		Finding an element
void bstree::find(int x,nodeptr &p)
{
	if (p==NULL)
	   cout<<"
Element not found
";
	else
	if (x < p->element)
	   find(x,p->left);
	else
	if (x>p->element)
	   find(x,p->right);
	else
	   cout<<"
Element found !
";

}

//		Copy a tree
void bstree::copy(nodeptr &p,nodeptr &p1)
{
	makeempty(p1);
	p1 = nodecopy(p);
}

//		Make a tree empty
void bstree::makeempty(nodeptr &p)
{
	nodeptr d;
	if (p != NULL)
	{
	   makeempty(p->left);
	   makeempty(p->right);
	   d=p;
	   free(d);
	   p=NULL;
	}
}

//		Copy the nodes
nodeptr bstree::nodecopy(nodeptr &p)
{
	nodeptr temp;
	if (p==NULL)
	   return p;
	else
	{
	   temp = new node;
	   temp->element = p->element;
	   temp->left = nodecopy(p->left);
	   temp->right = nodecopy(p->right);
	   return temp;
	}
}

//		Deleting a node
void bstree::del(int x,nodeptr &p)
{
	nodeptr d;
	if (p==NULL)
	   cout<<"Element not found 
";
	else if ( x < p->element)
	   del(x,p->left);
	else if (x > p->element)
	   del(x,p->right);
	else if ((p->left == NULL) && (p->right == NULL))
	{
	   d=p;
	   free(d);
	   p=NULL;
	   cout<<"
 Element deleted !
";
	}
	else if (p->left == NULL)
	{
	  d=p;
	  free(d);
	  p=p->right;
	  cout<<"
 Element deleted !
";
	}
	else if (p->right == NULL)
	{
	  d=p;
	  p=p->left;
	  free(d);
	  cout<<"
 Element deleted !
";
	}
	else
	  p->element = deletemin(p->right);
}

int bstree::deletemin(nodeptr &p)
{
	int c;
	cout<<"inside deltemin 
";
	if (p->left == NULL)
	{
	  c=p->element;
	  p=p->right;
	  return c;
	}
	else
	{
	  c=deletemin(p->left);
	  return c;
	}
}

void bstree::preorder(nodeptr p)
{
	if (p!=NULL)
	{
	  cout<<p->element<<"-->";
	  preorder(p->left);
	  preorder(p->right);
	}
}

//		Inorder Printing
void bstree::inorder(nodeptr p)
{
	if (p!=NULL)
	{
	   inorder(p->left);
	   cout<<p->element<<"-->";
	   inorder(p->right);
        }
}

//		PostOrder Printing
void bstree::postorder(nodeptr p)
{
        if (p!=NULL)
        {
	   postorder(p->left);
	   postorder(p->right);
	   cout<<p->element<<"-->";
	}
}

int bstree::max(int value1, int value2)
{
	return ((value1 > value2) ? value1 : value2);
}

int bstree::bsheight(nodeptr p)
{
	int t;
	if (p == NULL)
		return -1;
	else
	{
		t = p->height;
		return t;
	}
}

nodeptr bstree:: srl(nodeptr &p1)
{
	nodeptr p2;
	p2 = p1->left;
	p1->left = p2->right;
	p2->right = p1;
	p1->height = max(bsheight(p1->left),bsheight(p1->right)) + 1;
	p2->height = max(bsheight(p2->left),p1->height) + 1;
	return p2;
}

nodeptr bstree:: srr(nodeptr &p1)
{
	nodeptr p2;
	p2 = p1->right;
	p1->right = p2->left;
	p2->left = p1;
	p1->height = max(bsheight(p1->left),bsheight(p1->right)) + 1;
	p2->height = max(p1->height,bsheight(p2->right)) + 1;
	return p2;
}


nodeptr bstree:: drl(nodeptr &p1)
{
	p1->left=srr(p1->left);
	return srl(p1);
}

nodeptr bstree::drr(nodeptr &p1)
{
	p1->right = srl(p1->right);
	return srr(p1);
}

int bstree::nonodes(nodeptr p)
{
	int count=0;
	if (p!=NULL)
	{
		nonodes(p->left);
		nonodes(p->right);
		count++;
	}
	return count;

}



int main()
{
	clrscr();
	nodeptr root,root1,min,max;//,flag;
	int a,choice,findele,delele,leftele,rightele,flag;
	char ch='y';
	bstree bst;
	//system("clear");
	root = NULL;
	root1=NULL;
	cout<<"
		AVL Tree
";
	cout<<"		========
";
	do
	{
		cout<<"
		1.Insertion
		2.FindMin
		";
		cout<<"3.FindMax
		4.Find
		5.Copy
		";
		cout<<"6.Delete
		7.Preorder
		8.Inorder
";
		cout<<"		9.Postorder
		10.height
";
		cout<<"
Enter the choice:
";
		cin>>choice;
		switch(choice)
		{
		case 1:
			cout<<"
New node's value ?
";
			cin>>a;
			bst.insert(a,root);
			break;
		case 2:
			if (root !=NULL)
			{
			min=bst.findmin(root);
			cout<<"
Min element :	"<<min->element;
			}
			break;
		 case 3:
                        if (root !=NULL)
                        {
			max=bst.findmax(root);
			cout<<"
Max element :	"<<max->element;
			}
			break;
		case 4:
			cout<<"
Search node : 
";
			cin>>findele;
			if (root != NULL)
				bst.find(findele,root);
			break;
		case 5:
			bst.copy(root,root1);
			bst.inorder(root1);
			break;
		case 6:
			cout<<"Delete Node ?
";
			cin>>delele;
			bst.del(delele,root);
			bst.inorder(root);
			break;

		case 7:
			cout<<"
 Preorder Printing... :
";
			bst.preorder(root);
			break;

		case 8:
                       cout<<"
 Inorder Printing.... :
";
                        bst.inorder(root);
                        break;

		case 9:
                        cout<<"
 Postorder Printing... :
";
                        bst.postorder(root);
                        break;
		case 10:
			cout<<"
 Height and Depth is 
";
			cout<<bst.bsheight(root);
			cout<<"No. of nodes:- "<<bst.nonodes(root);
			break;



		}
		cout<<"
 Do u want to continue (y/n) ?
";
		cin>>ch;
	}while(ch=='y');


	return 0;
}



Binary Search Tree with non-recursive traversals

This program includes the inserting a node, deleting a node,recursive tree traversal,non-recursive tree traversal,finding the
minimum,maximum,leftchild,rightchild,copy a tree to another,making a tree null.

Code :
# include <conio.h>
# include <process.h>
# include <iostream.h>
# include <alloc.h>

struct node
{
	int ele;
	node *left;
	node *right;
};

typedef struct node *nodeptr;
class stack
{
	private:
		struct snode
		{
			nodeptr ele;
			snode *next;
		};
		snode *top;
	public:
		stack()
		{
			top=NULL;
		}
		void push(nodeptr p)
		{
			snode *temp;
			temp = new snode;
			temp->ele = p;
			temp->next = top;
			top=temp;
		}

		void pop()
		{
			if (top != NULL)
			{
			nodeptr t;
			snode *temp;
			temp = top;
			top=temp->next;
			delete temp;
			}
		}

		nodeptr topele()
		{
			if (top !=NULL)
				return top->ele;
			else
				return NULL;
		}



		int isempty()
		{
		return ((top == NULL) ? 1 : 0);
		}

};


class bstree
{
	public:
		void insert(int,nodeptr &);
		void del(int,nodeptr &);
		int deletemin(nodeptr &);
		void find(int,nodeptr &);
		nodeptr findmin(nodeptr);
		nodeptr findmax(nodeptr);
		void copy(nodeptr &,nodeptr &);
		void makeempty(nodeptr &);
		nodeptr nodecopy(nodeptr &);
		void preorder(nodeptr);
		void inorder(nodeptr);
		void postorder(nodeptr);
		void preordernr(nodeptr);
		void inordernr(nodeptr);
		void postordernr(nodeptr);
		void leftchild(int,nodeptr &);
		void rightchild(int,nodeptr &);


};

void bstree::insert(int x,nodeptr &p)
{
	if (p==NULL)
	{
		p = new node;
		p->ele=x;
		p->left=NULL;
		p->right=NULL;
	}
	else
	{
		if (x < p->ele)
			insert(x,p->left);
		else if (x>p->ele)
			insert(x,p->right);
		else
			cout<<"Element already Exits !";
	}
}

void bstree:: del(int x,nodeptr &p)
{
	nodeptr d;
	if (p==NULL)
		cout<<"Element not found ";
	else if (x < p->ele)
		del(x,p->left);
	else if (x > p->ele)
		del(x,p->right);
	else if ((p->left == NULL) && (p->right ==NULL))
	{
		d=p;
		free(d);
		p=NULL;
	}
	 else if (p->left == NULL)
	{
		d=p;
		free(d);
		p=p->right;
	}
	else if (p->right ==NULL)
	{
		d=p;
		p=p->left;
		free(d);
	}
	else
	p->ele=deletemin(p->right);
}

int bstree::deletemin(nodeptr &p)
{
	int c;
	if (p->left == NULL)
	{
		c=p->ele;
		p=p->right;
		return c;
	}
	else
		c=deletemin(p->left);
		return c;
}

void bstree::copy(nodeptr &p,nodeptr &p1)
{
	makeempty(p1);
	p1=nodecopy(p);
}

void bstree::makeempty(nodeptr &p)
{
	nodeptr d;
	if (p!=NULL)
	{
		makeempty(p->left);
		makeempty(p->right);
		d=p;
		free(d);
		p=NULL;
	}
}

nodeptr bstree::nodecopy(nodeptr &p)
{
	nodeptr temp;
	if (p == NULL)
		return p;
	else
	{
		temp = new node;
		temp->ele=p->ele;
		temp->left = nodecopy(p->left);
		temp->right = nodecopy(p->right);
		return temp;
	}
}


nodeptr bstree::findmin(nodeptr p)
{
	if (p==NULL)
	{
		cout<<"Tree is empty !";
		return p;
	}
	else
	{
		while (p->left !=NULL)
			p=p->left;
		return p;
	}
}



nodeptr bstree::findmax(nodeptr p)
{
	if (p==NULL)
	{
		cout<<"Tree is empty !";
		return p;
	}
	else
	{
		while (p->right !=NULL)
			p=p->right;
		return p;
	}
}

void bstree::find(int x,nodeptr &p)
{
	if (p==NULL)
		cout<<"Element not found  !";
	else
	{
		if (x <p->ele)
			find(x,p->left);
		else if ( x> p->ele)
			find(x,p->right);
		else
			cout<<"Element Found !";
	}
}

void bstree::preorder(nodeptr p)
{
	if (p!=NULL)
	{
		cout<<p->ele<<"-->";
		preorder(p->left);
		preorder(p->right);
	}
}
void bstree::inorder(nodeptr p)
{
	if (p!=NULL)
	{
		inorder(p->left);
		cout<<p->ele<<"-->";
		inorder(p->right);
	}
}

void bstree::postorder(nodeptr p)
{
	if (p!=NULL)
	{
		postorder(p->left);
		postorder(p->right);
		cout<<p->ele<<"-->";
	}
}



void bstree::preordernr(nodeptr p)
{
	stack s;
	while (1)
	{
	if  (p != NULL)
	{
		cout<<p->ele<<"-->";
		s.push(p);
		p=p->left;
	}
	else
	if (s.isempty())
	{
		cout<<"Stack is empty";
		return;
	}
	else
	{
		nodeptr t;
		t=s.topele();
		p=t->right;
		s.pop();
	}
	}
}


void bstree::inordernr(nodeptr p)
{
	stack s;
	while (1)
	{
	if  (p != NULL)
	{
		s.push(p);
		p=p->left;
	}
	else
	{
	if (s.isempty())
	{
		cout<<"Stack is empty";
		return;
	}
	else
	{
		p=s.topele();
		cout<<p->ele<<"-->";
	}
	s.pop();
	p=p->right;
	}
	}
}


void bstree::postordernr(nodeptr p)
{
	stack s;
	while (1)
	{
	if  (p != NULL)
	{
		s.push(p);
		p=p->left;

	}
	else
	{
		if (s.isempty())
		{
			cout<<"Stack is empty";
			return;
		}
		else
		if (s.topele()->right == NULL)
		{
			p=s.topele();
			s.pop();
			cout<<p->ele<<"-->";
			if (p==s.topele()->right)
			{
				cout<<s.topele()->ele<<"-->";
				s.pop();
			}
		}
		if (!s.isempty())
			p=s.topele()->right;
		else
			p=NULL;
	}
	}
}

void bstree::leftchild(int q,nodeptr &p)
{
	if (p==NULL)
		cout<<"The node does not exists ";

	else
	if (q < p->ele )
		leftchild(q,p->left);
	else
	if (q > p->ele)
		leftchild(q,p->right);
	else
	if (q == p->ele)
	{
		if (p->left != NULL)
			cout<<"Left child of "<<q<<"is "<<p->left->ele;
		else
			cout<<"No Left child !";
	}
}

void bstree::rightchild(int q,nodeptr &p)
{
	if (p==NULL)
		cout<<"The node does not exists ";
	else
	if (q < p->ele )
		rightchild(q,p->left);
	else
	if (q > p->ele)
		rightchild(q,p->right);
	else
	if (q == p->ele)
	{
		if (p->right != NULL)
			cout<<"Right child of "<<q<<"is "<<p->right->ele;
		else
			cout<<"No Right Child !";
	}
}





int main()
{
int ch,x,leftele,rightele;
bstree bst;
char c='y';
nodeptr root,root1,min,max;
root=NULL;
root1=NULL;
do
{
//	system("clear");
	clrscr();
	cout<<"
Binary Search Tree 
";
	cout<<"-------------------------
";
	cout<<"		1.Insertion
		2.Deletion
		3.NodeCopy
";
	cout<<"		4.Find
		5.Findmax
		6.Findmin
";
	cout<<"		7.Preorder
		8.Inorder
		9.Postorder
";
	cout<<"
		10.Leftchild
		11.Rightchild
		0.Exit
";
	cout<<"
Enter your choice :";
	cin>>ch;

	switch(ch)
	{
	case 1:
		cout<<"
		1.Insertion
";
		cout<<"Enter the new element to get inserted :
";
		cin>>x;

		bst.insert(x,root);
		cout<<"Inorder traversal is :
";
		bst.inorder(root);
		break;

	case 2:
		cout<<"
		2.Deletion
";
		cout<<"Enter the element to get deleted :
";
		cin>>x;
		bst.del(x,root);
		bst.inorder(root);
		break;

	case 3:
		cout<<"
		3.Nodecopy
";
		bst.copy(root,root1);
		cout<<"
The new tree is :
";
		bst.inorder(root1);
		break;

	case 4:
		cout<<"
		4.Find
";
		cout<<"Enter the element to be searched :
";
		cin>>x;
		bst.find(x,root);
		break;

	case 5:
		cout<<"
		5.Findmax
";
		if (root == NULL)
			cout<<"
Tree is empty";
		else
		{
			max=bst.findmax(root);
			cout<<"Largest element is :	"<<max->ele<<endl;
		}
		break;

	case 6:
		cout<<"
		6.Findmin
";
		if (root == NULL)
			cout<<"
Tree is empty";
		else
		{
			min=bst.findmin(root);
			cout<<"Smallest element is :	"<<min->ele<<endl;
		}
		break;

	case 7:
		cout<<"
		7.Preorder
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
			cout<<"
Preorder traversal (Non-Recursive) is :
";
			bst.preordernr(root);
			cout<<"
Preorder traversal (Recursive) is :
";
			bst.preorder(root);
		}
		break;

	case 8:
		cout<<"
		8.Inorder
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
			cout<<"
Inorder traversal (Non-Recursive) is :
";
			bst.inordernr(root);
			cout<<"
Inorder traversal (Recursive) is :
";
			bst.inorder(root);
		}
		break;

	case 9:
		cout<<"
		9.Postorder
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
			cout<<"
Postorder traversal (Non-Recursive) is :
";
			bst.postordernr(root);
			cout<<"
Postorder traversal (Recursive) is :
";
			bst.postorder(root);
		}
		break;

	case 10:
		cout<<"
		10.Finding the left Child 
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
			cout<<"Enter the node for which the left child is to be found :
";
			cin>>leftele;
			bst.leftchild(leftele,root);
		}
		break;

	case 11:
		cout<<"
		11.Finding the Right Child 
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
			cout<<"Enter the node for which the Right child is to be found :
";
			cin>>rightele;
			bst.rightchild(rightele,root);
		}
		break;


	case 0:
		exit(0);
	}
	cout<<"
Continue (y/n) ?
";
	cin>>c;
	}while (c=='y' || c == 'Y');
	return 0;
}


Binary Search tree with insertion, deletion, finding an element,
min element, max element, left child, right child, recursive and nonrecursive traversals,
finding the number of nodes, leaves, fullnodes, ancestors, descendants

# include <conio.h>
# include <process.h>
# include <iostream.h>
# include <alloc.h>

struct node
{
	int ele;
	node *left;
	node *right;
};

typedef struct node *nodeptr;
static int nodes=0;
static int leaves=0;
static int full=0;
class stack
{
	private:
		struct snode
		{
			nodeptr ele;
			snode *next;
		};
		snode *top;
	public:
		stack()
		{
			top=NULL;
		}
		void push(nodeptr p)
		{
			snode *temp;
			temp = new snode;
			temp->ele = p;
			temp->next = top;
			top=temp;
		}

		void pop()
		{
			if (top != NULL)
			{
			nodeptr t;
			snode *temp;
			temp = top;
			top=temp->next;
			delete temp;
			}
		}

		nodeptr topele()
		{
			if (top !=NULL)
				return top->ele;
			else
				return NULL;
		}

		int isempty()
		{
		return ((top == NULL) ? 1 : 0);
		}

};


class bstree
{
	public:
		void insert(int,nodeptr &);
		void del(int,nodeptr &);
		int deletemin(nodeptr &);
		void find(int,nodeptr &);
		nodeptr findmin(nodeptr);
		nodeptr findmax(nodeptr);
		void copy(nodeptr &,nodeptr &);
		void makeempty(nodeptr &);
		nodeptr nodecopy(nodeptr &);
		void nonodes(nodeptr);
		void fullnodes(nodeptr);
		void ances(int,nodeptr &);
		void desc(int,nodeptr &);
		void allleaves(nodeptr);
		void noleaves(nodeptr);
		void preorder(nodeptr);
		void inorder(nodeptr);
		void postorder(nodeptr);
		void preordernr(nodeptr);
		void inordernr(nodeptr);
		void postordernr(nodeptr);
		void leftchild(int,nodeptr &);
		void rightchild(int,nodeptr &);
};

void bstree::insert(int x,nodeptr &p)
{
	if (p==NULL)
	{
		p = new node;
		p->ele=x;
		p->left=NULL;
		p->right=NULL;
	}
	else
	{
		if (x < p->ele)
			insert(x,p->left);
		else if (x>p->ele)
			insert(x,p->right);
		else
			cout<<"Element already Exits !";
	}
}

void bstree:: del(int x,nodeptr &p)
{
	nodeptr d;
	if (p==NULL)
		cout<<"Element not found ";
	else if (x < p->ele)
		del(x,p->left);
	else if (x > p->ele)
		del(x,p->right);
	else if ((p->left == NULL) && (p->right ==NULL))
	{
		d=p;
		free(d);
		p=NULL;
	}
	 else if (p->left == NULL)
	{
		d=p;
		free(d);
		p=p->right;
	}
	else if (p->right ==NULL)
	{
		d=p;
		p=p->left;
		free(d);
	}
	else
	p->ele=deletemin(p->right);
}

int bstree::deletemin(nodeptr &p)
{
	int c;
	if (p->left == NULL)
	{
		c=p->ele;
		p=p->right;
		return c;
	}
	else
		c=deletemin(p->left);
		return c;
}

void bstree::copy(nodeptr &p,nodeptr &p1)
{
	makeempty(p1);
	p1=nodecopy(p);
}

void bstree::makeempty(nodeptr &p)
{
	nodeptr d;
	if (p!=NULL)
	{
		makeempty(p->left);
		makeempty(p->right);
		d=p;
		free(d);
		p=NULL;
	}
}

nodeptr bstree::nodecopy(nodeptr &p)
{
	nodeptr temp;
	if (p == NULL)
		return p;
	else
	{
		temp = new node;
		temp->ele=p->ele;
		temp->left = nodecopy(p->left);
		temp->right = nodecopy(p->right);
		return temp;
	}
}


nodeptr bstree::findmin(nodeptr p)
{
	if (p==NULL)
	{
		cout<<"Tree is empty !";
		return p;
	}
	else
	{
		while (p->left !=NULL)
			p=p->left;
		return p;
	}
}



nodeptr bstree::findmax(nodeptr p)
{
	if (p==NULL)
	{
		cout<<"Tree is empty !";
		return p;
	}
	else
	{
		while (p->right !=NULL)
			p=p->right;
		return p;
	}
}

void bstree::find(int x,nodeptr &p)
{
	if (p==NULL)
		cout<<"Element not found  !";
	else
	{
		if (x <p->ele)
			find(x,p->left);
		else if ( x> p->ele)
			find(x,p->right);
		else
			cout<<"Element Found !";
	}
}
void bstree::desc(int x,nodeptr &p)
{
	if (p==NULL)
		cout<<"Element not found  !";
	else
	{
		if (x <p->ele)
			desc(x,p->left);
		else if ( x> p->ele)
			desc(x,p->right);
		else
		{
			if (p->left !=NULL)
			preorder(p->left);
			else
			preorder(p->right);
		}
			//cout<<"Element Found !";
	}
}

void bstree::ances(int x,nodeptr &p)
{
	if (p==NULL)
		cout<<"Element not found  !";
	else
	{
		if (x <p->ele)
			{
			cout<<p->ele<<"-->";
			ances(x,p->left);
			}
		else if ( x> p->ele)
			{
			cout<<p->ele<<"-->";
			ances(x,p->right);
			}
		else
			cout<<"Element Found !";
	}
}

void bstree::nonodes(nodeptr p)
{
	if (p!=NULL)
	{
		nodes++;
		nonodes(p->left);
		nonodes(p->right);
	}
}
void bstree::noleaves(nodeptr p)
{
	if (p!=NULL)
	{
		noleaves(p->left);
		if ((p->left == NULL) && (p->right == NULL))
			leaves++;
		noleaves(p->right);
	}
}
void bstree::allleaves(nodeptr p)
{
	if (p!=NULL)
	{
		allleaves(p->left);
		if ((p->left == NULL) && (p->right == NULL))
			cout<<p->ele<<"-->";
		allleaves(p->right);
	}
}

void bstree::fullnodes(nodeptr p)
{
	if (p!=NULL)
	{
		fullnodes(p->left);
		if ((p->left != NULL) && (p->right != NULL))
			full++;
		fullnodes(p->right);
	}
}

void bstree::preorder(nodeptr p)
{
	if (p!=NULL)
	{
		cout<<p->ele<<"-->";
		preorder(p->left);
		preorder(p->right);
	}
}
void bstree::inorder(nodeptr p)
{
	if (p!=NULL)
	{
		inorder(p->left);
		cout<<p->ele<<"-->";
		inorder(p->right);
	}
}

void bstree::postorder(nodeptr p)
{
	if (p!=NULL)
	{
		postorder(p->left);
		postorder(p->right);
		cout<<p->ele<<"-->";
	}
}



void bstree::preordernr(nodeptr p)
{
	stack s;
	while (1)
	{
	if  (p != NULL)
	{
		cout<<p->ele<<"-->";
		s.push(p);
		p=p->left;
	}
	else
	if (s.isempty())
	{
		cout<<"Stack is empty";
		return;
	}
	else
	{
		nodeptr t;
		t=s.topele();
		p=t->right;
		s.pop();
	}
	}
}


void bstree::inordernr(nodeptr p)
{
	stack s;
	while (1)
	{
	if  (p != NULL)
	{
		s.push(p);
		p=p->left;
	}
	else
	{
	if (s.isempty())
	{
		cout<<"Stack is empty";
		return;
	}
	else
	{
		p=s.topele();
		cout<<p->ele<<"-->";
	}
	s.pop();
	p=p->right;
	}
	}
}


void bstree::postordernr(nodeptr p)
{
	stack s;
	while (1)
	{
	if  (p != NULL)
	{
		s.push(p);
		p=p->left;
	}
	else
	{
		if (s.isempty())
		{
			cout<<"Stack is empty";
			return;
		}
		else
		if (s.topele()->right == NULL)
		{
			p=s.topele();
			s.pop();
			cout<<p->ele<<"-->";
			if (p==s.topele()->right)
			{
				cout<<s.topele()->ele<<"-->";
				s.pop();
			}
			if (!s.isempty())
				p=s.topele()->right;
			else
				p=NULL;
		}
	}
	}
}

void bstree::leftchild(int q,nodeptr &p)
{
	if (p==NULL)
		cout<<"The node does not exists ";
	else
	if (q < p->ele )
		leftchild(q,p->left);
	else
	if (q > p->ele)
		leftchild(q,p->right);
	else
	if (q == p->ele)
	{
		if (p->left != NULL)
			cout<<"Left child of "<<q<<"is "<<p->left->ele;
		else
			cout<<"No Left child !";
	}
}

void bstree::rightchild(int q,nodeptr &p)
{
	if (p==NULL)
		cout<<"The node does not exists ";
	else
	if (q < p->ele )
		rightchild(q,p->left);
	else
	if (q > p->ele)
		rightchild(q,p->right);
	else
	if (q == p->ele)
	{
		if (p->right != NULL)
			cout<<"Right child of "<<q<<"is "<<p->right->ele;
		else
			cout<<"No Right Child !";
	}
}

int main()
{
int ch,x,leftele,rightele;
bstree bst;
char c='y';
nodeptr root,root1,min,max;
root=NULL;
root1=NULL;
do
{
//	system("clear");
	clrscr();
	cout<<"
			Binary Search Tree
";
	cout<<"			--------------------
";
	cout<<"		1.Insertion
		2.Deletion
		3.NodeCopy
";
	cout<<"		4.Find
		5.Findmax
		6.Findmin
";
	cout<<"		7.Preorder
		8.Inorder
		9.Postorder";
	cout<<"
		10.Leftchild
		11.Rightchild
		12.Counting
";
	cout<<"
Enter your choice :";
	cin>>ch;

	switch(ch)
	{
	case 1:
		cout<<"
		1.Insertion
";
		cout<<"Node Element ?
";
		cin>>x;
		bst.insert(x,root);
		cout<<"Inorder traversal is :
";
		bst.inorder(root);
		break;

	case 2:
		cout<<"
		2.Deletion
";
		cout<<"Delete Element ?
";
		cin>>x;
		bst.del(x,root);
		bst.inorder(root);
		break;

	case 3:
		cout<<"
		3.Nodecopy
";
		bst.copy(root,root1);
		cout<<"
The new tree is :
";
		bst.inorder(root1);
		break;

	case 4:
		cout<<"
		4.Find
";
		cout<<"Search Element ?
";
		cin>>x;
		bst.find(x,root);
		cout<<"
 The ancestors are :
";
		bst.ances(x,root);
		cout<<"
 The descendants are :
";
		bst.desc(x,root);
		break;

	case 5:
		cout<<"
		5.Findmax
";
		if (root == NULL)
			cout<<"
Tree is empty";
		else
		{
		max=bst.findmax(root);
		cout<<"Largest element is :	"<<max->ele<<endl;
		}
		break;

	case 6:
		cout<<"
		6.Findmin
";
		if (root == NULL)
			cout<<"
Tree is empty";
		else
		{
		min=bst.findmin(root);
		cout<<"Smallest element is :	"<<min->ele<<endl;
		}
		break;

	case 7:
		cout<<"
		7.Preorder
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
		cout<<"
Preorder traversal (Non-Recursive) is :
";
		bst.preordernr(root);
		cout<<"
Preorder traversal (Recursive) is :
";
		bst.preorder(root);
		}
		break;

	case 8:
		cout<<"
		8.Inorder
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
		cout<<"
Inorder traversal (Non-Recursive) is :
";
		bst.inordernr(root);
		cout<<"
Inorder traversal (Recursive) is :
";
		bst.inorder(root);
		}
		break;

	case 9:
		cout<<"
		9.Postorder
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
		cout<<"
Postorder traversal (Non-Recursive) is :
";
		bst.postordernr(root);
		cout<<"
Postorder traversal (Recursive) is :
";
		bst.postorder(root);
		}
		break;

	case 10:
		cout<<"
		10.Finding the left Child 
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
		cout<<"Parent of the left child ?
";
		cin>>leftele;
		bst.leftchild(leftele,root);
		}
		break;

	case 11:
		cout<<"
		11.Finding the Right Child 
";
		if (root==NULL)
			cout<<"
Tree is empty";
		else
		{
		cout<<"Parent of the right child ?
";
		cin>>rightele;
		bst.rightchild(rightele,root);
		}
		break;
	case 12:
		bst.nonodes(root);
		cout<<"Number of nodes : "<<nodes<<endl;
		nodes=0;
		bst.noleaves(root);
		cout<<"Number of leaves :"<<leaves<<endl;
		leaves=0;
		bst.fullnodes(root);
		cout<<"Number of fullnodes :"<<full<<endl;
		full=0;
		cout<<"All leaf nodes are :
";
		bst.allleaves(root);
		break;
	}
	cout<<"
Continue (y/n) ?
";
	cin>>c;
	}while (c=='y' || c == 'Y');
	return 0;
}


Binary search tree with all the three recursive and non recursive traversals


#include<iostream.h>
#include<conio.h>
#include<stdlib.h>

class binarynode
{
 public:
   int data;
   binarynode *left;
   binarynode *right;
};

class binsrctree
{
 private:
   binarynode *root;
   void inorder_rec(binarynode *);
   void inorder_non_rec(binarynode *);
   void preorder_rec(binarynode *);
   void preorder_non_rec(binarynode *);
   void postorder_rec(binarynode *);
   void postorder_non_rec(binarynode *);
 public:
   binsrctree()
   {
    root=NULL;
   }
   void insert(int );
   void print_inorder_rec();
   void print_inorder_non_rec();
   void print_preorder_rec();
   void print_preorder_non_rec();
   void print_postorder_rec();
   void print_postorder_non_rec();
};

class stack
{
 int top;
 binarynode *stackel[20];
  public:
   stack()
   {
    top=-1;
   }
  void push(binarynode *);
  binarynode* pop();
  int empty()
  {
   if(top==-1)
   return(1);

   return(0);
  }
};

void stack::push(binarynode *node)
{
 stackel[++top]=node;
}

binarynode *stack::pop()
{
 return(stackel[top--]);
}

class stack_int
{
 int top;
 int stack_int[20];
  public:
   stack_int()
   {
    top=-1;
   }
  void push(int flag);
  int pop();
  int empty_int()
  {
   if(top==-1)
   return(1);

   return(0);
  }
};

void stack_int::push(int flag)
{
 stack_int[++top]=flag;
}

int stack_int::pop()
{
 return(stack_int[top--]);
}
/*---------------------------------------------------------------------*/
/* FUNCTION TO INSERT A NODE IN THE TREE */
/*---------------------------------------------------------------------*/
void binsrctree::insert(int val)
{
 binarynode *temp,*prev,*curr;
 temp=new binarynode;
 temp->data=val;
 temp->left=temp->right=NULL;

 if(root==NULL)
 {
  root=temp;
 }
 else
 {
   curr=root;
   while(curr!=NULL)
   {
    prev=curr;
    if(temp->data<curr->data)
       curr=curr->left;
    else
       curr=curr->right;
   }
   if(temp->data<prev->data)
      prev->left=temp;
   else
      prev->right=temp;
  }
}

/* ------------------------------------------------*/
/*INORDER RECURSIVE TRAVERSAL*/
/*-------------------------------------------------*/

void binsrctree::inorder_rec(binarynode *root)
{
  if(root!=NULL)
  {
   inorder_rec(root->left);
   cout<<root->data<<"	";
   inorder_rec(root->right);
  }
}

/*--------------------------------------------------*/
/*INORDER NON RECURSIVE TRAVERSAL*/
/*--------------------------------------------------*/

void binsrctree::inorder_non_rec(binarynode *root)
{
 stack stk;
 binarynode *temp;
 if(root!=NULL)
 {
  temp=root;
  do
  {
   while(temp!=NULL)
   {
      stk.push(temp);
      temp=temp->left;
   }/*end while*/
   if(!stk.empty())
   {
      temp=stk.pop();
      cout<<temp->data<<"	";
      temp=temp->right;
   }/*end if*/
   else
    break;
  }while(1); /*end do while*/
 }/* end if */
 else
  cout<<"
Empty tree";

} /*end function */

/*--------------------------------------------------*/
/*PREORDER RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/
void binsrctree::preorder_rec(binarynode *root)
{
 if(root!=NULL)
 {
   cout<<root->data<<"	";
   preorder_rec(root->left);
   preorder_rec(root->right);
 }
}

/*--------------------------------------------------*/
/*PREORDER NON RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::preorder_non_rec(binarynode *root)
{
 stack stk;
 binarynode *temp=root;

 stk.push(temp);

 while(!stk.empty())
 {
  temp=stk.pop();
  if(temp!=NULL)
  {
   cout<<temp->data<<"	";
   stk.push(temp->right);
   stk.push(temp->left);
  }
 }

}

/*--------------------------------------------------*/
/*POSTRDER RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::postorder_rec(binarynode *root)
{
 if(root!=NULL)
 {
  postorder_rec(root->left);
  postorder_rec(root->right);
  cout<<root->data<<"	";
 }
}

/*--------------------------------------------------*/
/*POSTORDER NON RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::postorder_non_rec(binarynode *root)
{
 stack stk;
 stack_int stk1;
 int flag;
 binarynode *temp=root;

 do
 {
  if(temp!=NULL)
  {
   stk.push(temp);
   stk1.push(1);
   temp=temp->left;
  }
  else
  {
   if(stk.empty())
     break;
   temp=stk.pop();
   flag=stk1.pop();
     if(flag==2)
     {
      cout<<temp->data;
      temp=NULL;
     } /*end if */
     else
     {
      stk.push(temp);
      stk1.push(2);
      temp=temp->right;
     } /* end else */
  } /* end if */
 }while(1);/*end do while*/
}/*end function*/

/*--------------------------------------------------*/
/*FUNCTION TO PRINT INORDER RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::print_inorder_rec()
{
 cout<<"
";
 inorder_rec(root);
 cout<<"
";
}

/*--------------------------------------------------*/
/*FUNCTION TO PRINT INORDER NON RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::print_inorder_non_rec()
{
 cout<<"
";
 inorder_non_rec(root);
 cout<<"
";
}

/*--------------------------------------------------*/
/*FUNCTION TO PRINT PREORDER RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::print_preorder_rec()
{
 cout<<"
";
 preorder_rec(root);
 cout<<"
";
}

/*--------------------------------------------------*/
/*FUNCTION TO PRINT PREORDER NON RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::print_preorder_non_rec()
{
 cout<<"
";
 preorder_non_rec(root);
 cout<<"
";
}

/*--------------------------------------------------*/
/*FUNCTION TO PRINT POSTORDER RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::print_postorder_rec()
{
 cout<<"
";
 postorder_rec(root);
 cout<<"
";
}

/*--------------------------------------------------*/
/*FUNCTION TO PRINT POSTORDER NON RECURSIVE TRAVERSAL */
/*---------------------------------------------------*/

void binsrctree::print_postorder_non_rec()
{
 cout<<"
";
 postorder_non_rec(root);
 cout<<"
";
}

/*--------------------------------------------------*/
/* MAIN FUNCTION */
/*---------------------------------------------------*/

void main()
{
 binsrctree BST;
 int ch,element;
 clrscr();

 do
 {
  cout<<"
1.Insert a node in binary tree";
  cout<<"
2.Recursive Inorder traversal";
  cout<<"
3.Non Recursive Inorder traversal";
  cout<<"
4.Recursive preorder traversal";
  cout<<"
5.Non recursive preorder traversal";
  cout<<"
6.Recursive postorder traversal";
  cout<<"
7.Non recursive postorder traversal";
  cout<<"
8.Exit";
  cout<<"
Enter your choice";
  cin>>ch;

  switch(ch)
  {
   case 1:
    cout<<"
Enter the element you wnat to insert";
    cin>>element;
    BST.insert(element);
    break;
   case 2:
    cout<<"
Recursive Inorder traversal
";
    BST.print_inorder_rec();
    break;
   case 3:
    cout<<"
NonRecursive Inorder traversal
";
    BST.print_inorder_non_rec();
    break;
   case 4:
    cout<<"
Recursive preorder traversal
";
    BST.print_preorder_rec();
    break;
   case 5:
    cout<<"
Non recursive preorder traversal
";
    BST.print_preorder_non_rec();
    break;
   case 6:
    cout<<"
Recursive postorder traversal";
    BST.print_postorder_rec();
    break;
   case 7:
    cout<<"
Non recursive postorder traversal
";
    BST.print_postorder_non_rec();
    break;
   case 8:
    exit(1);

  }
 }while(ch<8);
}
Binary Search is a good searching algorithm.
And also Fast inprocessing. Here you have to input sorted number in an array first then
find out the number

//Binary Searching

#include<iostream.h>
#include<conio.h>
#include<stdio.h>

void main()
{
	clrscr();
	int l_v=1;
	int h_v;
	int a[51];
	int middle;
	int num,i=0;
	cout<<"Input your sorted num : 
";
	while(scanf("%d",&a[i])!=EOF)
		i++;
	h_v=i;
	cout<<"
The input numbers are :
";
	i=0;
	while(i<h_v)
	{
		cout<<a[i]<<endl;
		i++;
	}
	getch();
	cout<<"

Input your searching number : 
";
	cin>>num;
	for(int n=0;a[middle]!=num;n++)
	{
		middle = (l_v + h_v)/2;
		if(a[middle]>num)
			h_v = middle - 1;
		else if(a[middle]<num)
			l_v = middle + 1;
		else if(a[middle]==num)
			cout<<"
Found your number in "<<middle+1<<" position.";
	}
	cout<<"

This program's loop is executed "<<n<<" times to find out 
the
number.";
	getch();
}
Code to create binary tree, find mirror image of it, find height,
print original tree and mirrot image tree level wise, display leaf
nodes

#include<iostream.h>
#include<conio.h>
#include<stdlib.h>    //header for standard library function  exit();
typedef class bin_tree
{
	public:
		int data,status;
		class bin_tree *lchild,*rchild; //pointers to class bin_tree
		bin_tree():data(0),lchild(NULL),rchild(NULL),status(0){}//constructor
		class bin_tree* createbt(class bin_tree*,int data);  //create 
function
		void leafnodes(class bin_tree*);
		void display(class bin_tree*);
		class bin_tree* mirrorimage(class bin_tree*,class bin_tree*);
		void levelprint(class bin_tree*,int&);
}nodebt;//typedef for simplicity
typedef class queue
{
	public:
	nodebt *data;
	class queue *next;
	queue():data(NULL),next(NULL){}
	nodebt* deletefront(queue **front,queue **rear);
	queue *insertrear(queue **front,queue **rear,nodebt *data);
}que;
void nodebt::levelprint(class bin_tree* r,int &height)
{
	que q1;
	nodebt *check=NULL,*pt=r;
	que *front=NULL,*rear=NULL;
	q1.insertrear(&front,&rear,r);
	q1.insertrear(&front,&rear,check);
	while(front!=NULL)//q not empty
	{
		while(pt!=NULL)
		{
			pt=q1.deletefront(&front,&rear);
			if(pt==NULL)
			{
				cout<<endl;
				height++;
				q1.insertrear(&front,&rear,check);
				pt=q1.deletefront(&front,&rear);
			}
			if(front==NULL)
			return;
			cout<<pt->data<<" ";
			if(pt->lchild!=NULL)
			q1.insertrear(&front,&rear,pt->lchild);
			if(pt->rchild!=NULL)
			q1.insertrear(&front,&rear,pt->rchild);
		 }
	}
}
nodebt* que::deletefront(que **front,que **rear)
{
	nodebt *temp=NULL;
		if(*front==NULL)
		{
			cout<<"
 queue is empty";
		}
		else
		{       temp=(*front)->data;
			(*front)=(*front)->next;
			if((*front)==NULL)
			{
			       *rear=NULL;
			}
		}
	return temp;
}
que *que::insertrear(que **front,que **rear,nodebt *data)
{
	que *temp=NULL;
		temp=new queue;
		temp->data=data;
		temp->next=NULL;
		if(*front==NULL)
		{
			*front=temp;
			*rear=temp;
		}
		else
		{
			(*rear)->next=temp;
			*rear=(*rear)->next;
		}
	return *front;
}
nodebt* nodebt::mirrorimage(class bin_tree *r,class bin_tree* m)
{
	nodebt *ret=NULL;
	if(r==NULL)
	return r;
	if(r->status==2)
	{
		nodebt *temp=new nodebt;
		temp->data=r->data;
		temp->status=2;
		m=temp;
		ret=temp;
	}
	if(r->status==0)
	{
		nodebt *temp=new nodebt;
		temp->data=r->data;
		temp->status=1;
		m->rchild=temp;
		m=m->rchild;
	}
	if(r->status==1)
	{
		nodebt *temp=new nodebt;
		temp->data=r->data;
		temp->status=0;
		m->lchild=temp;
		m=m->lchild;
	}

	mirrorimage(r->lchild,m);
	mirrorimage(r->rchild,m);
	return ret;
}
void nodebt::leafnodes(class bin_tree* r)
{
	if(r==NULL)
	return;
	if(r->lchild==NULL && r->lchild==NULL)
	cout<<r->data<<" ";
	leafnodes(r->lchild);
	leafnodes(r->rchild);
}
void nodebt::display(class bin_tree* r)
{
	if(r==NULL)
	return;
	cout<<" "<<r->data<<" ";
	display(r->lchild);
	display(r->rchild);
}
nodebt* nodebt::createbt(nodebt *r,int data)
{
	int ch=0;
	if(r==NULL)
	{
		nodebt *temp=new nodebt;
		temp->data=data;
		temp->status=2;
		r=temp;
	}
	else
	{
		cout<<"
	1.INSERT AT LEFT OF"<<" "<<r->data;
		cout<<"
	2.INSERT AT RIGHT OF"<<" "<<r->data;
		cout<<"
	ENTER YOUR CHOICE=";
		cin>>ch;
		switch(ch)
		{
			case 1:if(r->lchild==NULL)
				{
					nodebt *temp=new nodebt;
					temp->data=data;
					temp->status=0;
					r->lchild=temp;
				}
				else
				createbt(r->lchild,data);
				break;
			case 2:if(r->rchild==NULL)
				{
					nodebt *temp=new nodebt;
					temp->data=data;
					temp->status=1;
					r->rchild=temp;
				}
				else
				createbt(r->rchild,data);
				break;
		}
	}
	return r;
}
int main()
{       int ch=0,data=0,height=0;
	nodebt *head=NULL,*m=NULL;
	nodebt t2;
	do
	{       clrscr();
		cout<<"
		MENU";
		cout<<"
	1.CREATE OR INSERT BINARY TREE";
		cout<<"
	2.PRINT LEAF NODES";
		cout<<"
	3.FIND MIRROR IMAGE OF THE TREE";
		cout<<"
	4.PRINT ORIGINAL AND MIRROR IMAGE LEVELWISE";
		cout<<"
	5.HEIGHT OF TREE";
		cout<<"
	6.EXIT";
		cout<<"
	ENTER YOUR CHOICE=";
		cin>>ch;
		switch(ch)
		{
			case 1: nodebt t1;
				do
				{
					cout<<"
ENTER THE DATA=";cin>>data;
					head=t1.createbt(head,data);
					cout<<"
 DO U WANT TO ADD MORE NODES(1.YES/2.NO)";
					cout<<"
 ENTER YOUR CHOICE";
					cin>>ch;
				}while(ch!=2);
				t1.display(head);
			       break;
			case 2:t1.leafnodes(head);
			       break;
			case 3:m=t2.mirrorimage(head,m);
			       cout<<"
	MIRRORIMAGE TREE LEVELWISE
";
			       height=0;
			       t2.levelprint(m,height);
			       break;
			case 4: cout<<"
	ORIGINAL TREE LEVELWISE
";
				t1.levelprint(head,height);
				m=t2.mirrorimage(head,m);
				cout<<"
	MIRRORIMAGE TREE LEVELWISE
";
				height=0;
				t2.levelprint(m,height);
				cout<<"
	HEIGHT OF BINARY TREE="<<height-1;
				break;
			case 5:cout<<"
	HEIGHT OF BINARY TREE="<<height-1;
			       break;
			case 6:exit(1);
		}
		getch();
	}while(ch!=6);
	return 1;
}
Dictionary implimentation in C++ using Binary Trees

A dictionary in c++, where first, the dictionary is created by
taking an input by the user for the words and their meanings. Next, these
are stored in a binary search tree,aftre which the file is saved.From
here begins the actual program. Try it out!

#include <stdio.h>
#include<iostream.h>
#include <conio.h>
#include <string.h>
#include <stdlib.h>
#include<dos.h>
#define LEFT  1
#define RIGHT 2

struct node
{
 char word[20],meaning[100];
 node *left,*right;
};

node *maketree(char[],char[]);

node* treefromfile();
void filefromtree(node*);
void addword(node*,char[],char[]);
void seperateword(char[],char[],char[]);
void displayall(node*);
node* bsearch(node*,char[]);
void showmenu();
FILE *file_ptr;

void prog()
{
 clrscr();
 char word[20],meaning[100];
 int menuchoice;
 node *temp;
 temp=treefromfile();
 if(temp==NULL)
 {
  printf("
File does not exist or dictionary is empty...");
  getch();
 }
 while(1)
 {
  clrscr();
  showmenu();
  scanf("
%d",&menuchoice);
  switch(menuchoice)
  {
   case 1:printf("
Enter word : ");
	  scanf("%s",word);
	  printf("
Enter meaning : " );
	  flushall();
	  gets(meaning);
	  if(temp==NULL)
	   temp=maketree(word,meaning);
	  else
	   addword(temp,word,meaning);
	  break;
   case 2:if(temp==NULL)
	   printf("
The dictionary is empty...");
	  else
	  {
	   printf("
Find meaning of : ");
	   flushall();
	   gets(word);
	   node *t;
	   t=bsearch(temp,word);
	   if(t==NULL)
	    printf("
Word not found...");
	   else
	   {
	    printf("

%s : ",t->word);
	    puts(t->meaning);
	   }
	  }
	  getch();
	  break;
   case 3:if(temp==NULL)
	   printf("
Dictionary is empty...");
	  else
	   displayall(temp);
	  getch();
	  break;
   case 4:filefromtree(temp);
	  exit(1);
	  break;
   default:cout<<"



Enter Again";
	   delay(1000);
	   prog();
	   break;
  }
 }
}
void showmenu()
{
 printf("
		COMPUTER DICTIONARY");
 printf("
[1].	Add a word.");
 printf("
[2].	Find meaning.");
 printf("
[3].	Display all.");
 printf("
[4]. Save and Close.



Enter Choice");
}
node* treefromfile()
{
 node *ptree=NULL;
 char word[20],meaning[100],str[120],*i;
 int flags=0;
 file_ptr=fopen("C:\dict.anu","r");
 if(file_ptr==NULL)
  ptree=NULL;
 else
 {

  while(!feof(file_ptr))
  {
	i=fgets(str,120,file_ptr);
	if(i==NULL)
	break;
	seperateword(str,word,meaning);
	if(flags==0)
	{
	 ptree=maketree(word,meaning);
	 flags=1;
	}
	else
	 addword(ptree,word,meaning);
  }

  fclose(file_ptr);
 }
 return ptree;
}
node* maketree(char w[],char m[])
{
 node *p;
 p=new node;
 strcpy(p->word,w);
 strcpy(p->meaning,m);
 p->left=NULL;
 p->right=NULL;
 return p;
}
void seperateword(char str[],char w[],char m[])
{
 int i,j;
 for(i=0;str[i]!=' ';i++)
  w[i]=str[i];
 w[i++]=NULL;	//Append the null and skip the space.
 for(j=0;str[i]!='
';i++,j++)
 {
  m[j]=str[i];
 }
 m[j]=NULL;
}
void addword(node *tree,char word[],char meaning[])
{
 node *p,*q;
 p=q=tree;
 while(strcmp(word,p->word)!=0 && p!=NULL)
 {
  q=p;
  if(strcmp(word,p->word)<0)
   p=p->left;
  else
   p=p->right;
 }
 if(strcmp(word,q->word)==0)
 {
  printf("
This word already exists...");
  delay(1000);
 }
 else if(strcmp(word,q->word)<0)
  q->left=maketree(word,meaning);
 else
  q->right=maketree(word,meaning);
}
node* bsearch(node *tree,char word[])
{
 node *q;
 q=tree;
 while(q!=NULL)
 {
  //p=q;
  if(strcmp(word,q->word)<0)
   q=q->left;
  else if(strcmp(word,q->word)>0)
   q=q->right;
  if(strcmp(word,q->word)==0)
   break;
 }
 return q;
}
void filefromtree(node *tree)
{
 void travandwrite(node*);
 file_ptr=fopen("C:\dict.anu","w");
 if(file_ptr==NULL)
 {
  printf("
Cannot open file for writing data...");
 }
 else //if(tree==NULL)
 {
  if(tree!=NULL)
  {
   travandwrite(tree);
  }
  fclose(file_ptr);  //Close the file anyway.
 }
}
void travandwrite(node *tree)
{
 if(tree!=NULL)
 {
  fprintf(file_ptr,"%s %s
",tree->word,tree->meaning);
  travandwrite(tree->left);
  travandwrite(tree->right);
 }
}
void displayall(node *tree)
{
 if(tree!=NULL)
 {
  displayall(tree->left);
  printf("%s : %s
",tree->word,tree->meaning);
  displayall(tree->right);
 }
}

void intro()
{
int i;
clrscr();
gotoxy(20,20);
cout<<"DICTIONARY LOADING";
for(i=0;i<50;i++)
{
 gotoxy(15+i,21);
 cout<<"???";
 gotoxy(20,22);
 cout<<2*i<<"% completed";
 delay(150);
}
gotoxy(20,20);
cout<<"DICTIONARY LOADING COMPLETED";
clrscr();
}
void main()
{
clrscr();
intro();
prog();
}


Sorted Doubly Linked List with Insertion and Deletion

#include <iostream>
#include <cstdlib>
#include <string>
using namespace std;

class Dllist
{
   private:
       typedef struct Node
       {
          string name;
          Node* next;
          Node* prev;
       };
       Node* head;
       Node* last;
   public:
       Dllist()
       {
         head = NULL;
         last = NULL;
       }
       bool empty() const { return head==NULL; }
       friend ostream& operator<<(ostream& ,const Dllist& );
       void Insert(const string& );
       void Remove(const string& );
};

void Dllist::Insert(const string& s)
{
    // Insertion into an Empty List.
    if(empty())
    {
       Node* temp = new Node;
       head = temp;
       last = temp;
       temp->prev = NULL;
       temp->next = NULL;
       temp->name = s;
    }
    else
    {
       Node* curr;
       curr = head;
       while( s>curr->name && curr->next != last->next) curr = curr->next;

       if(curr == head)
       {
         Node* temp = new Node;
         temp->name = s;
         temp->prev = curr;
         temp->next = NULL;
         head->next = temp;
         last = temp;
      //  cout<<" Inserted "<<s<<" After "<<curr->name<<endl;
       }
       else
       {
       if(curr == last && s>last->name)
       {
         last->next = new Node;
         (last->next)->prev = last;
         last = last->next;
         last->next = NULL;
         last->name = s;
      //  cout<<" Added "<<s<<" at the end "<<endl;
       }
       else
       {
         Node* temp = new Node;
         temp->name = s;
         temp->next = curr;
         (curr->prev)->next = temp;
         temp->prev = curr->prev;
         curr->prev = temp;
      //  cout<<" Inserted "<<s<<" Before "<<curr->name<<endl;
       }
      }
    }
}

ostream& operator<<(ostream& ostr, const Dllist& dl )
{
    if(dl.empty()) ostr<<" The list is empty. "<<endl;
    else
    {
        Dllist::Node* curr;
        for(curr = dl.head; curr != dl.last->next; curr=curr->next)
          ostr<<curr->name<<" ";
        ostr<<endl;
        ostr<<endl;
        return ostr;
    }
}

void Dllist::Remove(const string& s)
{
    bool found = false;
    if(empty())
    {
      cout<<" This is an empty list! "<<endl;
      return;
    }
    else
    {
      Node* curr;
      for(curr = head; curr != last->next; curr = curr->next)
      {
          if(curr->name == s)
          {
             found = true;
             break;
          }
      }
      if(found == false)
      {
       cout<<" The list does not contain specified Node"<<endl;
       return;
      }
      else
      {
         // Curr points to the node to be removed.
         if (curr == head && found)
         {
           if(curr->next != NULL)
           {
            head = curr->next;
            delete curr;
            return;
           }
           else
           {
            delete curr;
            head = NULL;
            last = NULL;
            return;
           }
         }
        if (curr == last && found)
        {
         last = curr->prev;
         delete curr;
         return;
        }
       (curr->prev)->next = curr->next;
       (curr->next)->prev = curr->prev;
        delete curr;
     }
  }
}

int main()
{
    Dllist d1;
    int ch;
    string temp;
    while(1)
    {
       cout<<endl;
       cout<<" Doubly Linked List Operations "<<endl;
       cout<<" ------------------------------"<<endl;
       cout<<" 1. Insertion "<<endl;
       cout<<" 2. Deletion "<<endl;
       cout<<" 3. Display "<<endl;
       cout<<" 4. Exit "<<endl;
       cout<<" Enter your choice : ";
       cin>>ch;
       switch(ch)
       {
          case 1: cout<<" Enter Name to be inserted : ";
                  cin>>temp;
                  d1.Insert(temp);
                  break;
          case 2: cout<<" Enter Name to be deleted : ";
                  cin>>temp;
                  d1.Remove(temp);
                  break;
          case 3: cout<<" The List contains : ";
                  cout<<d1;
                  break;
          case 4: system("pause");
                  return 0;
                  break;
       }
    }
Graph Representation Multi List Implementation

This is quite simple and useful implementation
IMPLEMENTATION OF GRAPH USING MULTI-LIST

Code :


#include<constream.h>


template<class T>
class Node
{
 friend class Graph<T>;
  private:
	  T data;
	  Node<T>* vlist;
	  Node<T>* next;
	  int status;
  public:
	 Node(T val)
	  {
	    data=val;
	    vlist=NULL;
	    next=NULL;
	  }
};


template<class T>
class Graph
{
 private:
	 Node<T>* head;
 public:
	Graph()
	{
	 head=NULL;
	}

   void Insert_Vertex(T val);
   void Insert_Edge(T v_val,T e_val);

   void Print_Vertices();
   void Print_Edges(T v_val);

   void Delete_Edge(T v_val,T e_val);
   void Delete_Vertex(T val);
   void bfs();
};

/////////////////
//  INSERTION  //
/////////////////

template<class T>
void Graph<T>::Insert_Vertex(T val)
{
 Node<T>* temp=new Node<T>(val);

   if(head==NULL)
    {
     head=temp;
     return;
    }

   Node<T>* t=head;
   while(t->vlist!=NULL)
    t=t->vlist;

   t->vlist=temp;

}


template<class T>
void Graph<T>::Insert_Edge(T v_val,T e_val)
{
  if(head==NULL)
   return;

  Node<T>* k=head;
  Node<T>* t=head;
  Node<T>* temp=new Node<T>(e_val);

  while(t!=NULL)
   {
     if(t->data==v_val)
      {
	Node<T>* s=t;
	    while(s->next!=NULL)
	      s=s->next;
	    s->next=temp;
	while(k!=NULL)
	 {
	   if(k->data==e_val)
	     break;
	   k=k->vlist;
	 }

	temp->vlist=k;
	 return;
      }
     t=t->vlist;
   }


}
///////////////////////
//  PRINT FUNCTIONS  //
///////////////////////
template<class T>
void Graph<T>::Print_Vertices()
{
 Node<T>* t=head;
   while(t!=NULL)
    {
      cout<<t->data<<"	";
      t=t->vlist;
    }
}


template<class T>
void Graph<T>::Print_Edges(T v_val)
{
   Node<T>* t=head;
   while(t!=NULL)
    {
       if(t->data==v_val)
	{
	  while(t->next!=NULL)
	   {
	    cout<<t->next->vlist->data<<"	";
	    t=t->next;
	   }
	}
       t=t->vlist;
    }
}
//////////////////
//   DELETION   //
//////////////////
template<class T>
void Graph<T>::Delete_Edge(T v_val,T e_val)
{
  if(head==NULL)
   return;

  Node<T>* t=head;

   while(t!=NULL)
   {
      if(t->data==v_val)
       {
	Node<T>* s=t;
	t=t->next;
	   while(t!=NULL)
	    {
	       if(t->data==e_val)
		{
		  s->next=t->next;
		  t=NULL;
		  t->vlist=NULL;
		  delete t;
		   return;
		}
	      s=t;
	      t=t->next;
	    }
       }
     t=t->vlist;
   }
}

template<class T>
void Graph<T>::Delete_Vertex(T v_val)
{
    if(head==NULL)
      return;

  Node<T>* e=head;

    // Delete Edges in other Vertices

    while(e!=NULL)
     {
       Delete_Edge(e->data,v_val);
       e=e->vlist;
     }


   // Delete  Vertex Edges

   Node<T>* t=head;

    while(t!=NULL)
     {
	if(t->data==v_val)
	 {
	    Node<T>* s=t;
	      while(s->next!=NULL)
	       {
		Node<T>* k=s->next;

		  while(k!=NULL)
		    k=k->next;

		   k=NULL;
		   k->vlist=NULL;
		   delete k;

		s=s->next;
	       }
	 }
       t=t->vlist;
     }

    //Delete Vertex

    if(head->data==v_val)
     {
       Node<T>* temp=head;
       head=head->vlist;
       temp=NULL;
       delete temp;
       return;
     }


     Node<T>* p1=head->vlist;
     Node<T>* p2=head;

	 while(p1!=NULL)
	  {
	    if(p1->data==v_val)
	     {
	      p2->vlist=p1->vlist;
	      p1=NULL;
	      delete p1;
	      return;
	     }
	   p2=p1;
	   p1=p1->vlist;
	  }

}

//----------------MIAN FUNCTION---------------//
void main()
{
clrscr();
Graph<char> G;
G.Insert_Vertex('A');
G.Insert_Vertex('B');
G.Insert_Vertex('C');
G.Insert_Vertex('D');



G.Insert_Edge('A','B');
G.Insert_Edge('A','C');
G.Insert_Edge('A','D');

G.Insert_Edge('B','A');
G.Insert_Edge('B','C');
G.Insert_Edge('B','D');


cout<<"

The vertices in the Graph are:	";
G.Print_Vertices();

cout<<"

Egdes of the given vertex to other vertices are:	";
G.Print_Edges('B');

G.Delete_Edge('B','C');

cout<<"

Egdes after deletion:	";
G.Print_Edges('B');

G.Delete_Vertex('A');

cout<<"


The vertices in the Graph After Deletion:  ";
G.Print_Vertices();

cout<<"

Egdes of the given vertex to other vertices are:	";
G.Print_Edges('B');


getch();
}


       
Program to create a graph and use Deapth First Search(DFS)
and Breadth First Search(BFS) Traversal.

#include<conio.h>
#include<iostream.h>
#include<stdlib.h>

void create();  // For creating a graph
void dfs();  // For Deapth First Search(DFS) Traversal.
void bfs();  // For Breadth First Search(BFS) Traversal.

struct node  // Structure for elements in the graph
{
   int data,status;
   struct node *next;
   struct link *adj;
};

struct link  // Structure for adjacency list
{
   struct node *next;
   struct link *adj;
};

struct node *start,*p,*q;
struct link *l,*k;

int main()
{
   int choice;
   clrscr();
   create();
   while(1)
   {
      cout<<"

-----------------------";
      cout<<"
1: DFS
2: BSF
3: Exit
Enter your choice: ";
      cin>>choice;
      switch(choice)
      {
	 case 1:
	    dfs();
	    break;
	 case 2:
	    bfs();
	    break;
	 case 3:
	    exit(0);
	    break;
	 default:
	    cout<<"
Incorrect choice!
Re-enter your choice.";
	    getch();
      }
   }
   return 0;
}

void create()    // Creating a graph
{
   int dat,flag=0;
   start=NULL;
   cout<<"
Enter the nodes in the graph(0 to end): ";
   while(1)
   {
      cin>>dat;
      if(dat==0)
	 break;
      p=new node;
      p->data=dat;
      p->status=0;
      p->next=NULL;
      p->adj=NULL;
      if(flag==0)
      {
	 start=p;
	 q=p;
	 flag++;
      }
      else
      {
	 q->next=p;
	 q=p;
      }
   }
   p=start;
   while(p!=NULL)
   {
      cout<<"Enter the links to "<<p->data<<" (0 to end) : ";
      flag=0;
      while(1)
      {
	 cin>>dat;
	 if(dat==0)
	    break;
	 k=new link;
	 k->adj=NULL;
	 if(flag==0)
	 {
	    p->adj=k;
	    l=k;
	    flag++;
	 }
	 else
	 {
	    l->adj=k;
	    l=k;
	 }
	 q=start;
	 while(q!=NULL)
	 {
	    if(q->data==dat)
	       k->next=q;
	    q=q->next;
	 }
      }
      p=p->next;
   }
   cout<<"

-------------------------";
   return;
}


// Deapth First Search(DFS) Traversal.
void bfs()
{
   int qu[20],i=1,j=0;
   p=start;
   while(p!=NULL)
   {
      p->status=0;
      p=p->next;
   }
   p=start;
   qu[0]=p->data;
   p->status=1;
   while(1)
   {
      if(qu[j]==0)
	 break;
      p=start;
      while(p!=NULL)
      {
	 if(p->data==qu[j])
	     break;
	 p=p->next;
      }
      k=p->adj;
      while(k!=NULL)
      {
	 q=k->next;
	 if(q->status==0)
	 {
	    qu[i]=q->data;
	    q->status=1;
	    qu[i+1]=0;
	    i++;
	 }
	 k=k->adj;
      }
      j++;
   }
   j=0;
   cout<<"

Breadth First Search Results
";
   cout<<"
---------------------------
";
   while(qu[j]!=0)
   {
      cout<<qu[j]<<"  ";
      j++;
   }
   getch();
   return;
}


// Breadth First Search(BFS) Traversal.
void dfs()
{
   int stack[25],top=1;
   cout<<"

Deapth First Search Results
";
   cout<<"
---------------------------
";
   p=start;
   while(p!=NULL)
   {
      p->status=0;
      p=p->next;
   }
   p=start;
   stack[0]=0;
   stack[top]=p->data;
   p->status=1;
   while(1)
   {
      if(stack[top]==0)
	 break;
      p=start;
      while(p!=NULL)
      {
	 if(p->data==stack[top])
	    break;
	 p=p->next;
      }
      cout<<stack[top]<<"  ";
      top--;
      k=p->adj;
      while(k!=NULL)
      {
	 q=k->next;
	 if(q->status==0)
	 {
	    top++;
	    stack[top]=q->data;
	    q->status=1;
	 }
	 k=k->adj;
      }
   }
   getch();
   return;
}
Merge Two Sorted Linked List To Form A Third Linked List

Code :



#include<iostream.h>
#include<conio.h>
#include<process.h>

//   Creating a NODE Structure
struct node
{
   int data;  // data
   struct node *next;  // link to next node and previous node
};

// Creating a class LIST
class list
{
   struct node *start;
   public:
      void create(); // to create a list
      void show();   // show
      void merge(list,list);  // Merge two list's
};

// Main function
int main()
{
   clrscr();
   list l1,l2,l3;
   cout<<"Enter the First List in ascending order.
";
   l1.create(); // to create a first list
   cout<<"
Enter the Second List in ascending order.
";
   l2.create(); // to create a second list
   cout<<"
The first list is
";
   l1.show();
   cout<<"
The second list is
";
   l2.show();
   l3.merge(l1,l2);
   l3.show();
   getch();
   return (0);
}

//    Functions

// Creating a new node
void list::create()
{
   struct node *nxt_node,*pre_node;
   int value,no,i;
   start=nxt_node=pre_node=NULL;
   cout<<"
How many nodes : ";
   cin>>no;
   cout<<"Enter "<<no<<" Elements: ";
   for(i=1;i<=no;i++)
   {
      cin>>value;
      nxt_node=new node;
      nxt_node->data=value;
      nxt_node->next=NULL;
      if(start==NULL)
	 start=nxt_node;
      else
	 pre_node->next=nxt_node;
      pre_node=nxt_node;
   }
   cout<<"
The list is created!

";
}

// Displaying LIST
void list::show()
{
   struct node *ptr=start;
   cout<<"

The List is 
";
   while(ptr!=NULL)
   {
      cout<<ptr->data<<" -> ";
      ptr=ptr->next;
   }
   cout<<"   ";
}

void list::merge(list l1,list l2)
{
   struct node *nxt_node,*pre_node,*pptr,*qptr;
   int dat;
   pptr=l1.start;
   qptr=l2.start;
   start=nxt_node=pre_node=NULL;
   while(pptr!=NULL && qptr!=NULL)
   {
      if(pptr->data<=qptr->data)
      {
	 dat=pptr->data;
	 pptr=pptr->next;
      }
      else
      {
	 dat=qptr->data;
	 qptr=qptr->next;
      }
      nxt_node=new node;
      nxt_node->data=dat;
      nxt_node->next=NULL;
      if(start==NULL)
	 start=nxt_node;
      else
	 pre_node->next=nxt_node;
      pre_node=nxt_node;
   }
   if(pptr==NULL)
   {
      while(qptr!=NULL)
      {
	 nxt_node=new node;
	 nxt_node->data=qptr->data;
	 nxt_node->next=NULL;
	 if(start==NULL)
	    start=nxt_node;
	 else
	    pre_node->next=nxt_node;
	 pre_node=nxt_node;
	 qptr=qptr->next;
      }
   }
   else if(qptr==NULL)
   {
      while(pptr!=NULL)
      {
	 nxt_node=new node;
	 nxt_node->data=pptr->data;
	 nxt_node->next=NULL;
	 if(start==NULL)
	    start=nxt_node;
	 else
	    pre_node->next=nxt_node;
	 pre_node=nxt_node;
	 pptr=pptr->next;
      }
   }
   cout<<"
The lists are merged.";
   return;
}


       
This program will take two doubly-linked lists of nodes and merges
them into another doubly-linked list of nodes.

Code :
#include<iostream>
using namespace std;
class Node
{
  public:
    int data;
    Node *next;
    Node *prev;
    Node()
    {
      data=0;
      next=prev=NULL;
    }
};
class Node1
{
    public:
      int data;
      Node1 *next;
      Node1 *prev;
      Node1()
      {
         data=0;
         next=prev=NULL;
      }
};
class Node2
{
   public:
     int data;
     Node2 *next;
     Node2 *prev;
     Node2()
     {
         data=0;
         next=prev=NULL;
     }
};
class DoublyLinkedList
{
    private:
       Node *headNode, *tailnode;
       Node1 *headNode1, *tailNode1;
       Node2 *headNode2, *tailNode2;
    public:
          DoublyLinkedList()
           {
              headNode=tailNode=NULL;
              headNode1=tailNode1=NULL;
              headNode2=tailNode2=NULL;
           }
         void Insert();//Insert data into the two lists
         void Merge() ;//Merging two lists into one
         void Display();//Display only the merged list
};
void DoublyLinkedList::Insert()
{
    char option;
    //This section inserts elements into the nodes of the first list
    do
    {
      Node *newnode = new Node();
      cin>>newnode->data;
      newnode->next=NULL;
      newnode->prev=NULL;
      if(headNode==NULL)
      {
        headNode= tailNode=newnode;
      }
      else
      {
        Node *curr = headNode;
        while(curr->next!=NULL)
         {
           curr=curr->next;
         }
         curr->next=tailNode=newnode;
         newnode->prev=curr;
       }
       cout<<"Enter y to continue adding data into the first list :";
       cin>>option;
    }
    while(option=='y'||option=='Y');

    //The section inserts the elements into the nodes of the second 
list
    do
    {
      Node1 *newnode = new Node1();
      cin>>newnode->data;
      newnode->next=NULL;
      newnode->prev=NULL;
      if(headNode1==NULL)
      {
        headNode1=tailNode1=newnode;
      }
      else
      {
        Node1 *curr = headNode1;
        while(curr->next!=NULL)
         {
           curr=curr->next;
         }
         curr->next= tailNode1=newnode;
         newnode->prev=curr;
       }
       cout<<"Enter y to continue adding data into the second list :";
       cin>>option;
    }
    while(option=='y'||option=='Y');
}
void DoublyLinkedList::Merge()
{
   Node *currentNode=headNode;
   Node1 *currentNode1=headNode1;
   //This section of code copies all the data from list 1 into the new
list
   while(currentNode!=NULL)
   {
     Node2 *newnode = new Node2();
     newnode->data = currentNode->data;
     newnode->next = NULL;
     newnode->prev = NULL;
     if(headNode2==NULL)
     {
       headNode2=tailNode2=newnode;
     }
     else
     {
       Node2 *temp = headNode2;
       while(temp->next!=NULL)
       {
         temp=temp->next;
       }
       temp->next=tailNode2=newnode;
       newnode->prev=temp;
     }
       currentNode=currentNode->next;
    }

    //This section of code appends the new list with data from the 
second
list
    while(currentNode1!=NULL)
    {
     Node2 *newnode = new Node2();
     newnode->data = currentNode1->data;
     newnode->next = newnode->prev=NULL;
     if(tailNode2->next==NULL)
     {
        tailNode2->next=newnode;
        newnode->prev = tailNode2;
        tailNode2=newnode;
     }
     currentNode1= currentNode1->next;
  }
}
void DoublyLinkedList::Display()
{
    Node2 *currentNode2 = headNode2;
    while(currentNode2!=NULL)
    {
       cout<<currentNode2->data<<" ";
       currentNode2=currentNode2->next;
    }
    cout<<endl;
}

void main()
{
    DoublyLinkedList DLL;
    DLL.Insert();
    DLL.Merge();
    DLL.Display();
}
Program for Multiplication of two matrices using OOP concept

Code :
	 #include<iostream.h>
	 #include<conio.h>

	   class matrix
	   {
		  int a[10][10], m,n;
		 public:
		 matrix()
		 {
		 }
		 matrix(int m,int n)
		 {
			this->m=m;
			this->n=n;


		 }
		 void set_mat()
		 {
		 for(int i=0;i<m;i++)
		  for(int j=0;j<n;j++)
		  a[i][j]=0;
		  }

		 void read_mat();
		 void disp_mat();
		 void mul_mat(matrix,matrix);
	  };
	  void matrix :: read_mat()
	  {
		for(int i=0;i<m;i++)
		 for(int j=0;j<n;j++)
		 {
		   cout<<"enter element "<<i+1<<","<<j+1<<"?";
		   cin>>a[i][j];
		 }
	  }
	  void matrix :: disp_mat()
	  {
		cout<<"Matrix Elements:
";
		for(int i=0;i<m;i++)
		{
		 for(int j=0;j<n;j++)
			cout<<a[i][j]<<"  ";
		  cout<<endl;
		 }

	   }
	   void matrix :: mul_mat(matrix m1,matrix m2)
	   {
		  if(m1.n!=m2.m)
		  cout<<"matrix multiplication is not possible ";
		  else
		  {
		  for(int i=0;i<m1.m;i++)
		   for(int j=0;j<m1.n;j++)
			for(int k=0;k<m2.n;k++)
			{
			  a[i][j]+=m1.a[i][k]*m2.a[k][j];
			}
		  }
		}
		void main()
		{
		  int m,n,p,q;
		  clrscr();


		  cout<<"enter first matrix size ?";
		  cin>>m>>n;
		  matrix m1(m,n);
		  m1.read_mat();
		  cout<<"enter second matrix size ?";
		  cin>>p>>q;
		  matrix m2(p,q);
		  m2.read_mat();
		  matrix m3(m,q);
		  m3.set_mat();
		  m3.mul_mat(m1,m2);
		  m1.disp_mat();
		  m2.disp_mat();
		  m3.disp_mat();
		  getch();
		  }

This program will take two doubly-linked lists of nodes and merges
them into another doubly-linked list of nodes.

Code :
#include<iostream>
using namespace std;
class Node
{
  public:
    int data;
    Node *next;
    Node *prev;
    Node()
    {
      data=0;
      next=prev=NULL;
    }
};
class Node1
{
    public:
      int data;
      Node1 *next;
      Node1 *prev;
      Node1()
      {
         data=0;
         next=prev=NULL;
      }
};
class Node2
{
   public:
     int data;
     Node2 *next;
     Node2 *prev;
     Node2()
     {
         data=0;
         next=prev=NULL;
     }
};
class DoublyLinkedList
{
    private:
       Node *headNode, *tailnode;
       Node1 *headNode1, *tailNode1;
       Node2 *headNode2, *tailNode2;
    public:
          DoublyLinkedList()
           {
              headNode=tailNode=NULL;
              headNode1=tailNode1=NULL;
              headNode2=tailNode2=NULL;
           }
         void Insert();//Insert data into the two lists
         void Merge() ;//Merging two lists into one
         void Display();//Display only the merged list
};
void DoublyLinkedList::Insert()
{
    char option;
    //This section inserts elements into the nodes of the first list
    do
    {
      Node *newnode = new Node();
      cin>>newnode->data;
      newnode->next=NULL;
      newnode->prev=NULL;
      if(headNode==NULL)
      {
        headNode= tailNode=newnode;
      }
      else
      {
        Node *curr = headNode;
        while(curr->next!=NULL)
         {
           curr=curr->next;
         }
         curr->next=tailNode=newnode;
         newnode->prev=curr;
       }
       cout<<"Enter y to continue adding data into the first list :";
       cin>>option;
    }
    while(option=='y'||option=='Y');

    //The section inserts the elements into the nodes of the second 
list
    do
    {
      Node1 *newnode = new Node1();
      cin>>newnode->data;
      newnode->next=NULL;
      newnode->prev=NULL;
      if(headNode1==NULL)
      {
        headNode1=tailNode1=newnode;
      }
      else
      {
        Node1 *curr = headNode1;
        while(curr->next!=NULL)
         {
           curr=curr->next;
         }
         curr->next= tailNode1=newnode;
         newnode->prev=curr;
       }
       cout<<"Enter y to continue adding data into the second list :";
       cin>>option;
    }
    while(option=='y'||option=='Y');
}
void DoublyLinkedList::Merge()
{
   Node *currentNode=headNode;
   Node1 *currentNode1=headNode1;
   //This section of code copies all the data from list 1 into the new
list
   while(currentNode!=NULL)
   {
     Node2 *newnode = new Node2();
     newnode->data = currentNode->data;
     newnode->next = NULL;
     newnode->prev = NULL;
     if(headNode2==NULL)
     {
       headNode2=tailNode2=newnode;
     }
     else
     {
       Node2 *temp = headNode2;
       while(temp->next!=NULL)
       {
         temp=temp->next;
       }
       temp->next=tailNode2=newnode;
       newnode->prev=temp;
     }
       currentNode=currentNode->next;
    }

    //This section of code appends the new list with data from the 
second
list
    while(currentNode1!=NULL)
    {
     Node2 *newnode = new Node2();
     newnode->data = currentNode1->data;
     newnode->next = newnode->prev=NULL;
     if(tailNode2->next==NULL)
     {
        tailNode2->next=newnode;
        newnode->prev = tailNode2;
        tailNode2=newnode;
     }
     currentNode1= currentNode1->next;
  }
}
void DoublyLinkedList::Display()
{
    Node2 *currentNode2 = headNode2;
    while(currentNode2!=NULL)
    {
       cout<<currentNode2->data<<" ";
       currentNode2=currentNode2->next;
    }
    cout<<endl;
}

void main()
{
    DoublyLinkedList DLL;
    DLL.Insert();
    DLL.Merge();
    DLL.Display();
}
Program for Multiplication of two matrices using OOP concept

Code :
	 #include<iostream.h>
	 #include<conio.h>

	   class matrix
	   {
		  int a[10][10], m,n;
		 public:
		 matrix()
		 {
		 }
		 matrix(int m,int n)
		 {
			this->m=m;
			this->n=n;


		 }
		 void set_mat()
		 {
		 for(int i=0;i<m;i++)
		  for(int j=0;j<n;j++)
		  a[i][j]=0;
		  }

		 void read_mat();
		 void disp_mat();
		 void mul_mat(matrix,matrix);
	  };
	  void matrix :: read_mat()
	  {
		for(int i=0;i<m;i++)
		 for(int j=0;j<n;j++)
		 {
		   cout<<"enter element "<<i+1<<","<<j+1<<"?";
		   cin>>a[i][j];
		 }
	  }
	  void matrix :: disp_mat()
	  {
		cout<<"Matrix Elements:
";
		for(int i=0;i<m;i++)
		{
		 for(int j=0;j<n;j++)
			cout<<a[i][j]<<"  ";
		  cout<<endl;
		 }

	   }
	   void matrix :: mul_mat(matrix m1,matrix m2)
	   {
		  if(m1.n!=m2.m)
		  cout<<"matrix multiplication is not possible ";
		  else
		  {
		  for(int i=0;i<m1.m;i++)
		   for(int j=0;j<m1.n;j++)
			for(int k=0;k<m2.n;k++)
			{
			  a[i][j]+=m1.a[i][k]*m2.a[k][j];
			}
		  }
		}
		void main()
		{
		  int m,n,p,q;
		  clrscr();


		  cout<<"enter first matrix size ?";
		  cin>>m>>n;
		  matrix m1(m,n);
		  m1.read_mat();
		  cout<<"enter second matrix size ?";
		  cin>>p>>q;
		  matrix m2(p,q);
		  m2.read_mat();
		  matrix m3(m,q);
		  m3.set_mat();
		  m3.mul_mat(m1,m2);
		  m1.disp_mat();
		  m2.disp_mat();
		  m3.disp_mat();
		  getch();
		  }

Program for Circular Queue Implementation using Arrays

Code :

	  /* Circular Queues */
	  #include<iostream.h>
	  #include<conio.h>

	  const int MAX = 5;
	  class cqueue
	  {
		   int a[MAX],front,rear;
		public :
		   cqueue()
		   {
			 front=rear=-1;
		   }
		   void insert(int );
		   int deletion();
		   void display();
	  };

	  void cqueue :: insert(int val)
	  {
		 if((front==0 && rear==MAX-1) || (rear+1==front))
			  cout<<" Circular Queue is Full
";
		 else
		 {
		   if(rear==MAX-1)
			  rear=0;
		   else
			 rear++;
		   a[rear]=val;
		 }
		 if(front==-1)
		   front=0;
	  }
	  int cqueue :: deletion()
	  {
		 int k;
		 if(front==-1)
			cout<<"Circular Queue is Empty
";
		 else
		 {
			k=a[front];
			if(front==rear)
			   front=rear=-1;
			else
			{
			   if(front==MAX-1)
				  front=0;
			   else
				  front++;
			}
		 }
		 return k;
	  }
	  void cqueue :: display()
	  {
		  int i;
		  if(front==-1)
			 cout<<"Circular Queue is Empty
";
		  else
		  {
			 if(rear < front)
			 {
				for(i=front;i<=MAX-1;i++)
				   cout<<a[i]<<"   ";
				for(i=0;i<=rear;i++)
				   cout<<a[i]<<"   ";
			 }
			 else
			 {
				for(i=front;i<=rear;i++)
				   cout<<a[i]<<"   ";
				cout<<endl;
			 }
		  }
	  }

	  void main()
	  {
		 cqueue c1;

		 int ch,val;
		 char op;
		 do
		 {
		   clrscr();
		   cout<<"-----------Menu-------------
";
		   cout<<"1.Insertion
2.Deletion
3.Display
4.Exit
";
		   cout<<"Enter Your Choice <1..4> ?";
		   cin>>ch;
		   switch(ch)
		   {
			   case 1 : cout<<"Enter Element to Insert ?";
						cin>>val;
						c1.insert(val);
						break;
			   case 2 : val=c1.deletion();
						cout<<"Deleted Element :"<<val<<endl;
						break;
			   case 3 : c1.display();
						break;
			}
			cout<<"Do you want to continue<Y/N> ?";
			cin>>op;
		  }while(op=='Y' || op=='y');
		   getch();
		}

Inserting, deleting and displaying elements in the Double Circular Linked List

Code :

	 #include<iostream.h>
	 #include<conio.h>

	 class cirdlink
	 {
		struct node
		{
		 int data;
		 node *rnext;
		 node *lnext;
		}*new1,*head,*tail,*ptr,*temp;

	   public:

	   cirdlink()
	   {
		 head=tail=NULL;
	   }

	   void creation();
	   void insertion();
	   void deletion();
	   void display();
	 };

	 void cirdlink :: creation()
	 {
		if(head==NULL)
		{
		   new1=new node[sizeof(node)];
		   new1->rnext=NULL;
		   new1->lnext=NULL;
		   cout<<"enter student number  :";
		   cin>>new1->data;
		   head=new1;
		   tail=new1;
		   head->rnext=tail;
		   head->lnext=tail;
		   tail->rnext=head;
		   tail->lnext=head;
		 }
		 else
		 cout<<" creation done only once  !";
	   }

	   void cirdlink :: insertion()
	   {
		 int i,pos;
		 new1=new node[sizeof(node)];
		 new1->rnext=NULL;
		 new1->lnext=NULL;
		 cout<<"enter student number :";
		 cin>>new1->data;
		 cout<<"enter position you want to insert  :";
		 cin>>pos;
		 if(pos==1)
		 {
		   new1->rnext=head;
		   head=new1;
		   tail->lnext=head;
		   tail->rnext=head;
		   head->lnext=tail;
		 }
		 else
		 {
		   i=1;
		   temp=head;
		   while(i < pos-1 && temp->rnext!=tail)
		   {
			   i++;
			   temp=temp->rnext;
		   }
		   if(temp->rnext==tail)
		   {
				 new1->rnext=tail->rnext;
				 tail->rnext=new1;
				 new1->lnext=tail;
				 tail=new1;
				 head->lnext=tail;
		   }
		   else
		   {
				 new1->rnext=temp->rnext;
				 new1->lnext=temp;
				 temp->rnext=new1;
				 new1->rnext->lnext=new1;
		   }
		 }
	   }
	   void  cirdlink :: deletion()
	   {
			int pos,i;

			cout<<"Enter Position you want to Delete ?";
			cin>>pos;

			if(pos==1 && head!=tail)
			{
				ptr=head;
				head=head->rnext;
				head->lnext=tail;
				tail->rnext=head;
				delete ptr;
			}
			else
			{
				i=1;
				temp=head;
				while(i < pos-1 && temp->rnext!=tail)
				{
				   i++;
				   temp=temp->rnext;
				}
				if(temp->rnext!=tail)
				{
					 ptr=temp->rnext;
					 temp->rnext=ptr->rnext;
					 ptr->rnext->lnext=ptr->lnext;
					 delete ptr;
				}
				else
				{
				   if(temp->rnext==tail && head!=tail)
				   {
						 ptr=tail;
						 tail=temp;
						 tail->rnext=head;
						 head->lnext=tail;
						 delete ptr;
					}
					else
					{
					   head=NULL;
					   tail=NULL;
					   delete head;
					   delete tail;
				   }
				}
			   }
			}
		  void cirdlink::display()
		  {
			   int ch;
			   cout<<"1.forward
2.backward
:";
			   cout<<"Enter your choice<1/2>?";
			   cin>>ch;
			  switch(ch)
			  {
				  case 1:  if(head!=NULL)
						   {
							 temp=head;
							 while(temp!=tail)
							 {
							  cout<<temp->data<<"    ";
							  temp=temp->rnext;
							 }
							 if(temp==tail)
							   cout<<temp->data;
							 }
							 break;

				  case 2 :  if(tail!=NULL)
							{
							  temp=tail;
							  while(temp!=head)
							  {
								cout<<temp->data<<"    ";
								temp=temp->lnext;
							   }
							   if(temp==head)
								  cout<<temp->data;
							 }
							 break;
			  }
		  }

		  void main()
		  {
			 cirdlink c1;

			 int ch;
			 char op;
			 do
			 {
				clrscr();
				cout<<"----------Menu------------
";
				cout<<"1.Creation
2.Insertion
3.Deletion
4.Display
";
				cout<<"Enter Your choice <1..4> ?";
				cin>>ch;
				switch(ch)
				{
					 case 1 :   c1.creation();
								break;
					 case 2 :   c1.insertion();
								break;
					 case 3 :	c1.deletion();
								break;
					 case 4 :	c1.display();
								break;
				}
				cout<<"Do you want to continue <Y/N> ?";
				cin>>op;
			 }while(op=='y' || op=='Y');
			getch();
		  }




Program for Priority Queue

Code :

	#include<iostream.h>
	#include<conio.h>

	const int MAX=5;

	class pqueue
	{
		  int front,rear;
		public:
		  struct data
		  {
		   int val,p,o;
		  }d[MAX];

		 pqueue()
		 {
			front=rear=-1;
		 }
		 void insert(data d1);
		 data deletion();
		 void display();
	};
	void pqueue :: insert(data d1)
	{
		if(rear==MAX-1)
		   cout<<"Priority Queue is Full
";
		else
		{
		   rear++;
		   d[rear]=d1;
		   if(front==-1)
			  front=0;
		   data temp;
		   for(int i=front;i<=rear;i++)
			 for(int j=i+1;j<=rear;j++)
			 {
				 if(d[i].p > d[j].p)
				 {
					temp=d[i];
					d[i]=d[j];
					d[j]=temp;
				 }
				 else
				 {
					 if(d[i].p==d[j].p)
					 {
						 if(d[i].o > d[j].o)
						 {
							  temp=d[i];
							  d[i]=d[j];
							  d[j]=temp;
						 }
					 }
				 }
			 }
		}
	}
	data pqueue :: deletion()
	{
		data d1;
		if(front==-1)
		   cout<<"Priority Queue is Empty
";
		else
		{
		   d1=d[front];
		   if(front==rear)
			  front=rear=-1;
		   else
			  front++;
		}
		return d1;
	}
	void pqueue :: display()
	{
		 if(front==-1)
			 cout<<"Priority Queue is Empty
";
		 else
		 {
			for(int i=front;i<=rear;i++)
			{
				cout<<"Object  :"<<i+1<<endl;
				cout<<"Value ="<<d[i].val<<endl;
				cout<<"Priority="<<d[i].p<<endl;
				cout<<"Order =  "<<d[i].o<<endl;
			}
		 }
	}
	void main()
	{
	  pqueue p1;

	  data d1;
	  char op;
	  do
	  {
		int ch;

		clrscr();
		cout<<"----------Menu-------------
";
		cout<<"1.Insertion
2.Deletion
3.Display
4.Exit
";
		cout<<"Enter your Choice<1..4> ?";
		cin>>ch;
		switch(ch)
		{
		   case 1 :  cout<<"Enter Value ?";
					 cin>>d1.val;
					 cout<<"Enter Priority?";
					 cin>>d1.p;
					 cout<<"Enter Order ?";
					 cin>>d1.o;
					 p1.insert(d1);
					 break;
		   case 2 :  d1=p1.deletion();
					 cout<<"Value = "<<d1.val<<endl;
					 cout<<"Priority = "<<d1.p<<endl;
					 cout<<"Order ="<<d1.o<<endl;
					 break;
		   case 3 :  p1.display();
					 break;
		  }
		  cout<<"Do You Want to Continue <Y/N> ?";
		  cin>>op;
		}while(op=='Y' || op=='y');
		getch();
	  }






Program is designed using doubly linked list and file operations.
It's code is to understand and use it.

Simple address book

#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
#include<alloc.h>
#include<string.h>
#include<graphics.h>
struct entry
{
char name[50];
char nick[50];
char email[50];
char address[50];
char city[50];
char cont[50];
char pin[50];
struct entry *lptr;
struct entry *rptr;
}*temp,*newe,*l,*r;
typedef struct entry *list;
void newentry();
void display(char n[50]);
void deletentry(char n[50]);
void displayall();
void makempty();
int isempty();
void saventry();
void loadentry();
void deleteall();
void newentry()
{
char a[50],b[50],f[50],g[50],c[50],d[50],e[50];
int i,k=0;
printf("Enter the Datas for the New Entry:
");
printf("Name      :");
scanf("%s",a);
printf("Nick name :");
scanf("%s",b);
printf("E-mail ID :");
scanf("%s",c);
printf("Address   :");
scanf("%s",d);
printf("City      :");
scanf("%s",e);
printf("Contact No:");
scanf("%s",f);
printf("Pincode   :");
scanf("%s",g);
newe=(struct entry*)malloc(sizeof(struct entry));
for(i=0;i<50;i++)
{
newe->name[i]=' ';
newe->nick[i]=' ';
newe->email[i]=' ';
newe->address[i]=' ';
newe->city[i]=' ';
newe->cont[i]=' ';
newe->pin[i]=' ';
}
for(i=0;i<50;i++)
{
newe->name[i]=a[i];
newe->nick[i]=b[i];
newe->email[i]=c[i];
newe->address[i]=d[i];
newe->city[i]=e[i];
newe->cont[i]=f[i];
newe->pin[i]=g[i];
}
if(isempty())
{
newe->lptr=newe->rptr=NULL;
l=r=newe;
printf("Your Entry is Added
");
}
else
 {
	 temp=l;
	 while(temp!=NULL)
  {
	  i=stricmp(newe->name,temp->name);
	 if(i<0)
	 break;
	 else if(i>0)
	  temp=temp->rptr;
	  else if(i==0)
	 {
		printf("Name Already Exists.Entry cannot be Added
");
	  k=1;
	  break;
	 }
	}
	 if(k!=1)
	 {
		if(temp==l)
	{
	  newe->lptr=NULL;
	  newe->rptr=l;
	  l->lptr=newe;
	  l=newe;
	  printf("Your Entry is Added
");
	 }
	 else if(temp==NULL)
	{
	  newe->rptr=NULL;
	  newe->lptr=r;
	  r->rptr=newe;
	  r=newe;
	  printf("Your Entry is Added
");
	 }
	 else
	{
	newe->rptr=temp;
	newe->lptr=temp->lptr;
	temp->lptr=newe;
	(newe->lptr)->rptr=newe;
	printf("Your Entry is Added
");
	}
  }
  }
}

void displayall()
{       int n=1;
if(!isempty())
{
temp=l;
while(temp!=NULL)
{
printf("[%d]	Name      :%s
	Nick Name :%s
	E-mail ID 
:%s
	address
:%s
	City      :%s
	Contact.No:%s
	Pin code
:%s

",n,temp->name,temp->nick,temp->email,temp->address,temp->city,temp
->cont,temp->pin);
temp=temp->rptr;
n++;
}
}
else
printf("Address Book is Empty
");
}

void deletentry(char n[50])
{
int i;
if(isempty())
printf("Address  Book is Empty 
");
else{
temp=l;
while(temp!=NULL)
{
i=stricmp(temp->name,n);
if(i==NULL)
{
if(l==r)
{
l=r=NULL;
printf("Entry deleted
");
break;
}
else if(temp==l)
  {
  l=l->rptr;
  l->lptr=NULL;
  printf("Entry deleted
");
  break;
  }
else if(temp==r)
{
r=r->lptr;
r->rptr=NULL;
printf("Entry deleted
");
break;
}
else{
(temp->lptr)->rptr=temp->rptr;
(temp->rptr)->lptr=temp->lptr;
printf("Entry deleted
");
break;
}
}
temp=temp->rptr;

}
if(temp==NULL)
printf("Not Found
");
}
}
int isempty()
{
return l==NULL;
}

void makempty()
{
l=r=NULL;
printf("Address Book is Emptied
");
}





void display(char n[50])
{
int i,p=1;
if(isempty())
printf("Address Book is Empty
");
else
{
temp=l;
while(temp!=NULL)
{
i=stricmp(temp->name,n);
if(i==NULL)
{if(p==1)
printf("Entry is found in %dst position
",p);
 else if(p==2)
 printf("Entry is found in %dnd position
",p);
 else if (p==3)
 printf("Entry is found in %drd position
",p);
 else
printf("Entry is found in %dth position
",p);
printf("Name      :%s
Nick Name :%s
E-mail ID :%s
address   
:%s
City
 :%s
Contact.No:%s
Pin code
:%s
",temp->name,temp->nick,temp->email,temp->address,temp->city,temp->co
nt,temp->pin);
break;
}
temp=temp->rptr;
p++;
}
if(temp==NULL)
printf("Entry Not Found
");

}
}






void main()
{
int l=1,m;
int gd=DETECT,gm;
char n[50];
initgraph(&gd,&gm,"c:\tc\bgi");
while(l!=8)
{
clrscr();
textmode(C80);
textcolor(4);
cprintf("*****************************************************************
***************#------------------------MINI PROJECT-SIMPLE ADDRESS
BOOK----------------------#***********************************************
*********************************");
cprintf("Enter Your Choice");
printf("
");
cprintf("(1)-New Entry");
printf("
");
cprintf("(2)-Display an Entry");
printf("
");
cprintf("(3)-Delete an Entry");
printf("
");
cprintf("(4)-Display all Entries");
printf("
");
cprintf("(5)-Empty the book");
printf("
");
cprintf("(6)-Save Entry");
printf("
");
cprintf("(7)-Load Entries");
printf("
");
cprintf("(8)-Delete All Saved Files");
printf("
");
cprintf("(9)-End");
printf("
");
cprintf("*****************************************************************
***************");
printf("
");
scanf("%d",&l);
switch(l)
{
case 1:
textcolor(2);
newentry();
getch();
break;
case 2:
textcolor(2);
cprintf("Enter the Name of the Person to Display");
printf("
");
scanf("%s",&n);
display(n);
getch();
break;
case 3:
textcolor(2);
cprintf("Enter the Name of the Person to Delete");
printf("
");
scanf("%s",&n);
deletentry(n);
getch();
break;
case 4:
textcolor(2);
displayall();
getch();
break;
case 5:
textcolor(2);
makempty();
getch();
break;
case 6:
textcolor(2);
saventry();
getch();
break;
case 7:
textcolor(2);
loadentry();
getch();
break;
case 8:
textcolor(2);
deleteall();
getch();
break;
case 9:
textcolor(2);
printf("Program Ends Here.Thank You!!!");
printf("
");
getch();
break;
default:
textcolor(2);
printf("Enter a Valid Choice from 1-9 only");
printf("
");
getch();
break;
}
}
getch();
}
void saventry()
{
char n[50];
int c;
printf("Enter the Name of the Person
");
scanf("%s",n);
list t;
if(isempty())
printf("Address Book is Empty
");
else
{
FILE *f;
f=fopen("entry.c","a");
int i;t=l;
while(t!=NULL)
{
i=stricmp(t->name,n);
if(i==0)
{
fprintf(f," 
%s %s %s %s %s %s %s
",t->name,t->nick,t->email,t->address,t->city,t->cont,t->pin);
printf("Your Entry Saved
");
printf("Add Another Entry?
 (1-yes/2-no)
");
scanf("%d",&c);
if(c==1)
saventry();
else if(c==2)
break;
}
t=t->rptr;

}
fclose(f);
if(t==NULL)
printf("Entry Not Found
");
}

}
void loadentry()
{
int i=1;
list t;
FILE *f;
       f=fopen("entry.c","r");
	if(f==NULL)
	{
	printf("Cannot Open
");
	exit(1);
	}
	while(fscanf(f," %s %s %s %s %s %s %s
",t->name,t->nick,t->email,t->address,t->city,t->cont,t->pin)!=EOF)
       {	printf("[%d]	Name      :%s
	Nick Name :%s
	E-mail ID
:%s
	address   :%s
	City      :%s
	Contact.No:%s
	Pin code
:%s
",i,t->name,t->nick,t->email,t->address,t->city,t->cont,t->pin);
	i++;}
	fclose(f);
	}


	void deleteall()
	{
	FILE *f;
	f=fopen("entry.c","w");
	fclose(f);
	printf("all saved files were delete
");
	}
Single linked list

#include<iostream.h>
#include<conio.h>
#include<stdlib.h>


class list
{
	struct node
	{
		int data;
		node *link;
	}*p;
public:
	void inslast(int);
	void insbeg(int);
	void insnext(int,int);
	void delelement(int);
	void delbeg();
	void dellast();
	void disp();
	int seek(int);
	list(){p=NULL;}
	~list();
};

void list::inslast(int x)
{
	node *q,*t;
	if(p==NULL)
	{
		p=new node;
		p->data=x;
		p->link=NULL;
	}
	else
	{
		q=p;
		while(q->link!=NULL)
			q=q->link;
		t=new node;
		t->data=x;
		t->link=NULL;
		q->link=t;
	}
	cout<<"
 Inserted successfully at the end..
";
	disp();
}

void list:: insbeg(int x)
{
	node *q;
	q=p;
	p=new node;
	p->data=x;
	p->link=q;
	cout<<"
 Inserted successfully at the begining..
";
	disp();
}


void list::delelement(int x)
{
	node *q,*r;
	q=p;
	if(q->data==x)
	{
		p=q->link;
		delete q;
		return;
	}
	r=q;
	while(q!=NULL)
	{
		if(q->data==x)
		{
			r->link=q->link;
			delete q;
			return;
		}
		r=q;
		q=q->link;
	}
	cout<<"
 Element u entered   "<<x<<"    is not found..
";
}

void list:: delbeg()
{
	cout<<"
 The list before deletion:
";
	disp();
	node *q;
	q=p;
	if(q==NULL)
	{
		cout<<"
 No data is present..
";
		return;
	}
	p=q->link;
	delete q;
	return;
}


void list:: dellast()
{
	cout<<"
 The list before deletion:
";
	disp();
	node *q,*t;
	q=p;
	if(q==NULL)
	{
		cout<<"
 There is no data in the list..
";
		return;
	}
	if(q->link==NULL)
	{
		p=q->link;
		delete q;
		return;
	}

	while(q->link->link!=NULL)
		q=q->link;
	q->link=NULL;
	return;
}

list::~list()
{
	node *q;
	if(p==NULL) return;
	while(p!=NULL)
	{
		q=p->link;
		delete p;
		p=q;
	}
}

void list::disp()
{
	node *q;
	q=p;
	if(q==NULL)
	{
		cout<<"
 No data is in the list..
";
		return;
	}
	cout<<"
 The items present in the list are :
";
	while(q!=NULL)
	{
		cout<<"	"<<q->data;
		q=q->link;
	}
}

void list :: insnext(int value,int position)
{
	node *temp,*temp1;
	temp=p;
	if(temp1==NULL)
	{
		temp1= new node;
		temp1->data=value;
		temp1->link=NULL;
		p=temp1;
		return;
	}
	for(int i=0;((i<position)&&(temp->link!=NULL)) ;i++)
	{
		if(i==(position-1))
		{
			temp1= new node;
			temp1->data= value;
			temp1->link=temp->link;
			temp->link=temp1;
		}
		temp=temp->link;
	}
	//cout<<"
 Inserted successfully at the position.."<<position;
	disp();
}


int list::seek(int value)
{
	node *temp;
	temp=p;
	int position=0;
	while(temp!=NULL)
	{
		if(temp->data==value)
			return position+1;
		else
		{
			temp=temp->link;
			position=position+1;
		}
	}
	cout<<"

 Element "<<value<<" not found";
	return 0;
}


void main()
{
list l;
int ch,v,p,ps;
do
{
	clrscr();
	cout<<"
 Operations on List..
";
	cout<<"
1.Insertion
2.Deletion
3.Display
4.Seek
5.Exit";
	cout<<"
 Enter ur choice:";
	cin>>ch;

	switch(ch)
	{
	case 1:
		cout<<"
1.Insertion at begining
2.Insertion at the end
";
		cout<<"3.Insertion after the mentioned position
";
		cout<<"
 Enter ur choice:";
		cin>>ps;
		cout<<"
 Enter the value to insert:";
		cin>>v;
		switch(ps)
		{
			case 1:
				l.insbeg(v);
				break;
			case 2:
				l.inslast(v);
				break;
			case 3:
				cout<<"
 Enter the position to insert the value:";
				cin>>p;
				l.insnext(v,p);
				break;

			default:
				cout<<"
 The choice is invalid
";
				return;
		}
	break;

	case 2:
		cout<<"
1.Delete the first element 
2.Delete the last element";
		cout<<"
3.Enter the element to delete from the list";
		cout<<"
 Enter ur choice:";
		cin>>ps;
		switch(ps)
		{
			case 1:
				l.delbeg();
				cout<<"
 The list after deletion:
";l.disp();
				break;
			case 2:
				l.dellast();
				cout<<"
 The list after deletion:
";l.disp();
				break;
			case 3:
				l.disp();
				cout<<"
 Enter the element to delete :	";
				cin>>v;
				l.delelement(v);
				cout<<"
 The list after deletion:
";l.disp();
				break;

			default:
				cout<<"
 The option is invalid...
";
				break;
		}
	break;

	case 3:
		l.disp();
		break;

	case 4:
		l.disp();
		cout<<"
 Enter the element to search:";
		cin>>v;
		cout<<"
 The position of the element "<< v<<"  is "<<l.seek(v);
		getch();
		break;

	case 5:
		exit(1);

	default:
		cout<<"
 The option is invalid...
";
		return;
	}
	getch();
}while(ch!=5);
getch();
return;
}
To find the BFS and DFS of the given graph


#include<stdio.h>
#include<conio.h>

#define size 20

int a[10][10],vertex[10],n,e;

/*STACK FUNCTIONS*/
#define bottom -1

int stack[size],top=bottom;
int stackempty()
{
	return(top=bottom) ? 1:0;
}
int stackfull()
{
	return(top==size-1) ? 1:0;
}

void push(int item)
{
	if(stackfull())
		printf("7

 STACK IS FULL");
	else
		stack[++top]=item;
}

int pop()
{
	if(stackempty())
	{
		printf("7

 STACK IS EMPTY");
		return -1;
	}
	else
		return stack[top--];
}

int peep()
{
	if(stackempty())
	{
		printf("7

 STACK IS EMPTY");
		return -1;
	}
	else
		return stack[top];
}

/* QUEUE FUNCTIONS */
#define start -1

int q[size];
int f=start,r=start;

int qempty(){ return(f==r)?1:0; }
int qfull(){ return(r==size-1)?1:0;}

void addq(int c)
{
if(qfull())
	printf("7

QUEUE IS FULL");
else
	q[++r]=c;
}

int delq()
{
if(qempty())
	{
	printf("7

QUEUE IS EMPTY");
	return -1;
	}
else
	return q[++f];
}
// j is unvisited adjecent vertex to i
int adjvertex(int i)
{
int j;
for(j=0;j<n;j++)
	if(a[i][j]==1&&vertex[j]==0)
		return j;
	return n;
}

int  visitall()
{
int i;
for(i=0;i<n;i++)
	if(vertex[i]==0)
		return 0;
	return 1;
}

/*FUNCTION FOR BFS*/
void bfs()
{
int i,j,k,cur=0;//current vertex is startting vertex
for(i=0;i<n;i++)
	vertex[i]=0;//not visited
printf("

BFS path => V%d ",cur+1);
addq(cur);
vertex[cur]=1;//marking visited vertex
	while(!visitall())
		{
		if(qempty())
			{
			printf("7

GRAPH IS DISCONNECTED");
			break;
			}
		cur=delq();
		//visit all vertices which are adjecent to current vertex
		for(j=0;j<n;j++)
			{
			//adjecent are not visited
			if(a[cur][j]==1&&vertex[j]==0)
				{
				printf("V%d ",j+1);
				addq(j);
				//marking visited vertex
				vertex[j]=1;
				}
			}
		}
}

/*FUNCTION FOR DFS*/
void dfs()
{
int i,j,k,cur=0;//current vertex is startting vertex
for(i=0;i<n;i++)
	vertex[i]=0;//not visited
printf("

DFS path => V%d ",cur+1);
push(cur);
vertex[cur]=1;//marking visited vertex
	while(!visitall())
		{
		do
			{
			cur=adjvertex(peep());
			if(cur==n) pop();
			}
		while(cur==n&&!stackempty());
		if(stackempty())
			{
			printf("7

GRAPH IS DISCONNECTED");
			break;
			}
		if(cur!=n)
			{
			printf(" V%d ",cur+1);
			push(cur);
			vertex[cur]=1;//marking visited vertex
			}
		}
}

/*MAIN PROGRAM*/
void main()
{
	int i,j,k;
	clrscr();
	for(i=0;i<10;i++)
	for(j=0;j<10;j++)
	a[i][j]=0;

	printf("
ENTER NO OF VERTICES & EDGES OF UNDIRECTED GRAPH : ");
	scanf("%d%d",&n,&e);

	printf("
ENTER EDGES AS PAIR OF VERTICES

");
	for(k=1;k<=e;k++)
		{
		printf("EDGE %d =>",k);
		scanf("%d%d",&i,&j);
		//for undirected graph
		a[i-1][j-1]=1;
		}

	dfs();
	bfs();
	getch();
}

string.cpp - If you don't have a string type

#include <string.h>
#include "mystring.h"

string::string( const char * cstring )
{
    if( cstring == NULL )
        cstring = "";
    strLength = strlen( cstring );
    bufferLength = strLength + 1;
    buffer = new char[ bufferLength ];
    strcpy( buffer, cstring );
}

string::string( const string & str )
{
    strLength = str.length( );
    bufferLength = strLength + 1;
    buffer = new char[ bufferLength ];
    strcpy( buffer,str.buffer );
}

const string & string::operator=( const string & rhs )
{
    if( this != &rhs )
    {
        if( bufferLength < rhs.length( ) + 1 )
        {
            delete [ ] buffer;
            bufferLength = rhs.length( ) + 1;
            buffer = new char[ bufferLength ];
        }
        strLength = rhs.length( );
        strcpy( buffer, rhs.buffer );
    }
    return *this;
}

const string & string::operator+=( const string & rhs )
{
    if( this == &rhs )
    {
        string copy( rhs );
        return *this += copy;
    }

    int newLength = length( ) + rhs.length( );
    if( newLength >= bufferLength )
    {
        bufferLength = 2 * ( newLength + 1 );

        char *oldBuffer = buffer;
        buffer = new char[ bufferLength ];
        strcpy( buffer, oldBuffer );
        delete [ ] oldBuffer;
    }

    strcpy( buffer + length( ), rhs.buffer );
    strLength = newLength;
    return *this;
}

char & string::operator[ ]( int k )
{
    if( k < 0 || k >= strLength )
        throw StringIndexOutOfBounds( );
    return buffer[ k ];
}

char string::operator[ ]( int k ) const
{
    if( k < 0 || k >= strLength )
        throw StringIndexOutOfBounds( );
    return buffer[ k ];
}

ostream & operator<<( ostream & out, const string & str )
{
    return out << str.c_str();
}

istream & operator>>( istream & in, string & str )
{
    char buf[ string::MAX_LENGTH + 1 ];
    in >> buf;
    if( !in.fail( ) )
        str = buf;
    return in;
}

istream & getline( istream & in, string & str )
{
    char buf[ string::MAX_LENGTH + 1 ];
    in.getline( buf, string::MAX_LENGTH );
    if( !in.fail( ) )
        str = buf;
    return in;
}

bool operator==( const string & lhs, const string & rhs )
{
    return strcmp( lhs.c_str( ), rhs.c_str( ) ) == 0;
}

bool operator!=( const string & lhs, const string & rhs )
{
    return strcmp( lhs.c_str( ), rhs.c_str( ) ) != 0;
}

bool operator<( const string & lhs, const string & rhs )
{
    return strcmp( lhs.c_str( ), rhs.c_str( ) ) < 0;
}

bool operator<=( const string & lhs, const string & rhs )
{
    return strcmp( lhs.c_str( ), rhs.c_str( ) ) <= 0;
}

bool operator>( const string & lhs, const string & rhs )
{
    return strcmp( lhs.c_str( ), rhs.c_str( ) ) > 0;
}

bool operator>=( const string & lhs, const string & rhs )
{
    return strcmp( lhs.c_str( ), rhs.c_str( ) ) >= 0;
}
vector.h - If you don't have a vector type

#ifndef VECTOR_H
#define VECTOR_H

#define vector Vector

class ArrayIndexOutOfBounds { };

template <class Object>
class vector
{
  public:
    explicit vector( int theSize = 0 ) : currentSize( theSize )
      { objects = new Object[ currentSize ]; }
    vector( const vector & rhs ) : objects( NULL )
      { operator=( rhs ); }
    ~vector( )
#ifndef WIN32
      { delete [ ] objects; }
#else
      { if( currentSize != 0 ) delete [ ] objects; }
#endif

    int size( ) const
      { return currentSize; }

    Object & operator[]( int index )
    {
                                                     #ifndef NO_CHECK
        if( index < 0 || index >= currentSize )
            throw ArrayIndexOutOfBounds( );
                                                     #endif
        return objects[ index ];
    }

    const Object & operator[]( int index ) const
    {
                                                     #ifndef NO_CHECK
        if( index < 0 || index >= currentSize )
            throw ArrayIndexOutOfBounds( );
                                                     #endif
        return objects[ index ];
    }


    const vector & operator = ( const vector & rhs );
    void resize( int newSize );
  private:
    int currentSize;
    Object * objects;
};

#include "vector.cpp"
#endif


vector.cpp - If you don't have a vector type

#ifndef VECTOR_CPP_
#define VECTOR_CPP_

#include "vector.h"

template <class Object>
const vector<Object> & vector<Object>::operator=( const vector<Object> & rhs )
{
    if( this != &rhs )
    {
#ifdef WIN32
      if( currentSize != 0 )
#endif
        delete [ ] objects;
        currentSize = rhs.size( );
        objects = new Object[ currentSize ];
        for( int k = 0; k < currentSize; k++ )
            objects[ k ] = rhs.objects[ k ];
    }
    return *this;
}

template <class Object>
void vector<Object>::resize( int newSize )
{
    Object *oldArray = objects;
    int numToCopy = newSize < currentSize ? newSize : currentSize;

    objects = new Object[ newSize ];

    for( int k = 0; k < numToCopy; k++ )
        objects[ k ] = oldArray[ k ];

#ifdef WIN32
  if( currentSize != 0 )
#endif
    delete [ ] oldArray;
    currentSize = newSize;
}

#endif
matrix.h - Simple matrix class
	
	#ifndef MATRIX_H
        #define MATRIX_H

        #include "vector.h"

        template <class Object>
        class matrix
        {
          public:
            matrix( int rows, int cols ) : array( rows )
            {
                for( int i = 0; i < rows; i++ )
                    array[ i ].resize( cols );
            }
            matrix( const matrix & rhs ) : array( rhs.array ) { }
            const vector<Object> & operator[]( int row ) const
              { return array[ row ]; }
            vector<Object> & operator[]( int row )
              { return array[ row ]; }
            int numrows( ) const
              { return array.size( ); }
            int numcols( ) const
              { return numrows( ) ? array[ 0 ].size( ) : 0; }
          private:
            vector< vector<Object> > array;
        };

        #endif


Fig01_02.cpp - A simple recursive routine with a test program
	
	#include <iostream.h>
    
        int f( int x )
        {
/* 1*/      if( x == 0 )
/* 2*/          return 0;
            else
/* 3*/          return 2 * f( x - 1 ) +  x * x;
        }

        int main( )
        {
            cout << "f(5) = " << f( 5 ) << endl;
            return 0;
        }
Fig01_03.cpp - An example of infinite recursion
	
	#include <iostream.h>

        int bad( int n )
        {
/* 1*/      if( n == 0 )
/* 2*/          return 0;
            else
/* 3*/          return bad( n / 3 + 1 ) + n - 1;
        }

        int main( )
        {
            cout << "bad is infinite recursion" << endl;
            return 0;
        }
Fig01_04.cpp - Recursive routine to print numbers, with a test program
	
	#include <iostream.h>

        void printDigit( int n )
        {
            cout << n;
        }

/* START: Fig01_04.txt */
        void printOut( int n )  // Print nonnegative n
        {
            if( n >= 10 )
                printOut( n / 10 );
            printDigit( n % 10 );
        }
/* END */

        int main(  )
        {
            printOut( 1369 );
            cout << endl;
            return 0;
        }
Fig01_05.cpp - Simplest IntCell class, with a test program
 
        #include <iostream.h>

        /**
         * A class for simulating an integer memory cell.
         */
        class IntCell
        {
          public:
            /**
             * Construct the IntCell.
             * Initial value is 0.
             */
            IntCell( )
              { storedValue = 0; }

            /**
             * Construct the IntCell.
             * Initial value is initialValue.
             */
            IntCell( int initialValue )
              { storedValue = initialValue; }

            /**
             * Return the stored value.
             */
            int read( )
              { return storedValue; }

            /**
             * Change the stored value to x.
             */
            void write( int x )
              { storedValue = x; }

          private:
            int storedValue;
        };

        int main( )
        {
            IntCell m;

            m.write( 5 );
            cout << "Cell contents: " << m.read( ) << endl;

            return 0;
        }
Fig01_06.cpp - IntCell class with a few extras, with a test program
 
        #include <iostream.h>

        /**
         * A class for simulating an integer memory cell.
         */
        class IntCell
        {
          public:
/* 1*/      explicit IntCell( int initialValue = 0 )
/* 2*/        : storedValue( initialValue ) { }
/* 3*/      int read( ) const
/* 4*/        { return storedValue; }
/* 5*/      void write( int x )
/* 6*/        { storedValue = x; }
          private:
/* 7*/      int storedValue;
        };

        int main( )
        {
            IntCell m;

            m.write( 5 );
            cout << "Cell contents: " << m.read( ) << endl;

            return 0;
        }
IntCell.h - IntCell class interface (Fig 1.7)
	
	#ifndef IntCell_H_
        #define IntCell_H_

        /**
         * A class for simulating an integer memory cell.
         */
        class IntCell
        {
          public:
            explicit IntCell( int initialValue = 0 );
            int read( ) const;
            void write( int x );
          private:
            int storedValue;
        };

        #endif
IntCell.cpp - IntCell class implementation (Fig 1.8)
	
	#include "IntCell.h"

        /**
         * Construct the IntCell with initialValue
         */

        IntCell::IntCell( int initialValue ) : storedValue( initialValue )
        {
        }

        /**
         * Return the stored value.
         */
        int IntCell::read( ) const
        {
            return storedValue;
        }

        /**
         * Store x.
         */
        void IntCell::write( int x )
        {
            storedValue = x;
        }
TestIntCell.cpp - IntCell test program (Fig 1.9)
	
	#include <iostream.h>
        #include "IntCell.h"

        int main( )
        {
            IntCell m;   // Or, IntCell m( 0 ); but not IntCell m( );

            m.write( 5 );
            cout << "Cell contents: " << m.read( ) << endl;

            return 0;
        }
Fig01_10.cpp - Illustration of using the vector class
 
        #include <iostream.h>
        #include "vector.h"      // vector (our version, in Appendix B)
        #include "mystring.h"    // string (our version, in Appendix B)

        int main( )
        {
            vector<string> v( 5 );
            int itemsRead = 0;
            string x;

            while( cin >> x )
            {
                if( itemsRead == v.size( ) )
                    v.resize( v.size( ) * 2 );
                v[ itemsRead++ ] = x;
            }

            for( int i = itemsRead - 1; i >= 0; i-- )
                cout << v[ i ] << endl;
            return 0;
        }
Fig01_11.cpp - Dynamically allocating an IntCell object (lame)
	
	#include <iostream.h>
        #include "IntCell.h"

        int main( )
        {
/* 1*/      IntCell *m;

/* 2*/      m = new IntCell( 0 );
/* 3*/      m->write( 5 );
/* 4*/      cout << "Cell contents: " << m->read( ) << endl;

/* 5*/      delete m;
/* 6*/      return 0;
        }
BuggyIntCell.cpp - Buggy IntCell class implementation (Figs 1.14 and 1.15)
	
	#include <iostream.h>

        /**
         * Figure 1.14: missing the big three is a bug here.
         */
        class IntCell
        {
          public:
            explicit IntCell( int initialValue = 0 )
              { storedValue = new int( initialValue ); }

            int read( ) const
              { return *storedValue; }
            void write( int x )
              { *storedValue = x; }
          private:
            int *storedValue;
        };


        /*
         * Figure 1.15.
         */
        int f( )
        {
            IntCell a( 2 );
            IntCell b = a;
            IntCell c;

            c = b;
            a.write( 4 );
            cout << a.read( ) << endl << b.read( ) << endl << c.read( ) << endl;
            return 0;
        }


        int main( )
        {
            f( );
            return 0;
        }
Fig01_16.cpp - IntCell class with pointers and Big Three
	
	#include <iostream.h>
        class IntCell
        {
          public:
            explicit IntCell( int initialValue = 0 );

            IntCell( const IntCell & rhs );
            ~IntCell( );
            const IntCell & operator=( const IntCell & rhs );

            int read( ) const;
            void write( int x );
          private:
            int *storedValue;
        };

        IntCell::IntCell( int initialValue )
        {
            storedValue = new int( initialValue );
        }

        IntCell::IntCell( const IntCell & rhs )
        {
            storedValue = new int( *rhs.storedValue );
        }

        IntCell::~IntCell( )
        {
            delete storedValue;
        }

        const IntCell & IntCell::operator=( const IntCell & rhs )
        {
            if( this != &rhs )
                *storedValue = *rhs.storedValue;
            return *this;
        }

        int IntCell::read( ) const
        {
            return *storedValue;
        }

        void IntCell::write( int x )
        {
            *storedValue = x;
        }


        /*
         * Figure 1.15.
         */
        int f( )
        {
            IntCell a( 2 );
            IntCell b = a;
            IntCell c;

            c = b;
            a.write( 4 );
            cout << a.read( ) << endl << b.read( ) << endl << c.read( ) << endl;
            return 0;
        }


        int main( )
        {
            f( );
            return 0;
        }
Fig01_16.cpp - IntCell class with pointers and Big Three
	
	#include <iostream.h>
        class IntCell
        {
          public:
            explicit IntCell( int initialValue = 0 );

            IntCell( const IntCell & rhs );
            ~IntCell( );
            const IntCell & operator=( const IntCell & rhs );

            int read( ) const;
            void write( int x );
          private:
            int *storedValue;
        };

        IntCell::IntCell( int initialValue )
        {
            storedValue = new int( initialValue );
        }

        IntCell::IntCell( const IntCell & rhs )
        {
            storedValue = new int( *rhs.storedValue );
        }

        IntCell::~IntCell( )
        {
            delete storedValue;
        }

        const IntCell & IntCell::operator=( const IntCell & rhs )
        {
            if( this != &rhs )
                *storedValue = *rhs.storedValue;
            return *this;
        }

        int IntCell::read( ) const
        {
            return *storedValue;
        }

        void IntCell::write( int x )
        {
            *storedValue = x;
        }


        /*
         * Figure 1.15.
         */
        int f( )
        {
            IntCell a( 2 );
            IntCell b = a;
            IntCell c;

            c = b;
            a.write( 4 );
            cout << a.read( ) << endl << b.read( ) << endl << c.read( ) << endl;
            return 0;
        }


        int main( )
        {
            f( );
            return 0;
        }
FindMax.cpp - Function template FindMax (Figs 1.17 and 1.18)
	
	#include <iostream.h>
        #include "mystring.h"
        #include "vector.h"
        #include "IntCell.h"
        // Figures 1.17 and 1.18, but with illegalities commented out


        /**
         * Return the maximum item in array a.
         * Assumes a.size( ) > 0.
         * Comparable objects must provide
         *   copy constructor, operator<, operator=
         */
        template <class Comparable>
        const Comparable & findMax( const vector<Comparable> & a )
        {
/* 1*/      int maxIndex = 0;

/* 2*/      for( int i = 1; i < a.size( ); i++ )
/* 3*/          if( a[ maxIndex ] < a[ i ] )
/* 4*/              maxIndex = i;
/* 5*/      return a[ maxIndex ];
        }

        int main( )
        {
            vector<int>     v1( 37 );
            vector<double>  v2( 40 );
            vector<string>  v3( 80 );
//          vector<IntCell> v4( 75 );

            // Additional code to fill in the vectors

            cout << findMax( v1 ) << endl;  // OK: Comparable = int
            cout << findMax( v2 ) << endl;  // OK: Comparable = double
            cout << findMax( v3 ) << endl;  // OK: Comparable = string
//          cout << findMax( v4 ) << endl;  // Illegal; operator< undefined

            return 0;
        };
Fig01_19.cpp - MemoryCell class template without separation
	
	#include <iostream.h>
        #include "mystring.h"


        /**
         * A class for simulating a memory cell.
         */
        template <class Object>
        class MemoryCell
        {
          public:
            explicit MemoryCell( const Object & initialValue = Object( ) )
              : storedValue( initialValue ) { }
            const Object & read( ) const
              { return storedValue; }
            void write( const Object & x )
              { storedValue = x; }
          private:
            Object storedValue;
        };

        // OOPS: I forgot to put a + operator in the string class.
        // So it's here:

        string operator+( const string & lhs, const string & rhs )
        {
            string result = lhs;
            return result += rhs;
            
        }

        int main( )
        {
            MemoryCell<int>    m1;
            MemoryCell<string> m2( "hello" );

            m1.write( 37 );
            m2.write( m2.read( ) + " world" );
            cout << m1.read( ) << endl << m2.read( ) << endl;

            return 0;
        }
MemoryCell.h - MemoryCell class interface (Fig 1.20)
	
	#ifndef MEMORY_CELL_H
        #define MEMORY_CELL_H

        /**
         * A class for simulating a memory cell.
         */
        template <class Object>
        class MemoryCell
        {
          public:
            explicit MemoryCell( const Object & initialValue = Object( ) );
            const Object & read( ) const;
            void write( const Object & x );
          private:
            Object storedValue;
        };

        #include "MemoryCell.cpp"  // Because sep. compilation doesn't always work

        #endif
MemoryCell.cpp - MemoryCell class implementation (Fig 1.21)
	
	#include "MemoryCell.h"

        /**
         * Construct the MemoryCell with initialValue
         */
        template <class Object>
        MemoryCell<Object>::MemoryCell( const Object & initialValue )
          : storedValue( initialValue )
        {
        }

        /**
         * Return the stored value.
         */
        template <class Object>
        const Object & MemoryCell<Object>::read( ) const
        {
            return storedValue;
        }

        /**
         * Store x.
         */
        template <class Object>
        void MemoryCell<Object>::write( const Object & x )
        {
            storedValue = x;
        }

TestMemoryCell.cpp - MemoryCell test program (Fig 1.22)
	
	#include <iostream.h>
        #include "MemoryCell.h"
        #include "mystring.h"


        // OOPS: I forgot to put a + operator in the string class.
        // So it's here:

        string operator+( const string & lhs, const string & rhs )
        {
            string result = lhs;
            return result += rhs;
            
        }

        int main( )
        {
            MemoryCell<int>    m1;
            MemoryCell<string> m2( "hello" );

            m1.write( 37 );
            m2.write( m2.read( ) + " world" );
            cout << m1.read( ) << endl << m2.read( ) << endl;

            return 0;
        }
Fig01_23.cpp - Using Comparable templates - Employee class example
	
	#include <iostream.h>
        #include "vector.h"
        #include "mystring.h"

        class Employee
        {
          public:
            void setValue( const string & n, double s )
              { name = n; salary = s; }

            void print( ostream & out ) const
              { out << name << " (" << salary << ")"; }
            bool operator< ( const Employee & rhs ) const
              { return salary < rhs.salary; }

            // Other general accessors and mutators, not shown
          private:
            string name;
            double salary;
        };

          // Define an output operator for Employee
        ostream & operator<< ( ostream & out, const Employee & rhs )
        {
            rhs.print( out );
            return out;
        }

        /**
         * Return the maximum item in array a.
         * Assumes a.size( ) > 0.
         * Comparable objects must provide
         *   copy constructor, operator<, operator=
         */
        template <class Comparable>
        const Comparable & findMax( const vector<Comparable> & a )
        {
/* 1*/      int maxIndex = 0;

/* 2*/      for( int i = 1; i < a.size( ); i++ )
/* 3*/          if( a[ maxIndex ] < a[ i ] )
/* 4*/              maxIndex = i;
/* 5*/      return a[ maxIndex ];
        }

        int main( )
        {
            vector<Employee> v( 3 );

            v[0].setValue( "Bill Clinton", 200000.00 );
            v[1].setValue( "Bill Gates", 2000000000.00 );
            v[2].setValue( "Billy the Marlin", 60000.00 );
            cout << findMax( v ) << endl;

            return 0;
        }
MaxSumTest.cpp - Various maximum subsequence sum algorithms
	
	#include <iostream.h>
        #include "vector.h"

/* START: Fig02_05.txt */
        /**
         * Cubic maximum contiguous subsequence sum algorithm.
         */
        int maxSubSum1( const vector<int> & a )
        {
/* 1*/      int maxSum = 0;

/* 2*/      for( int i = 0; i < a.size( ); i++ )
/* 3*/          for( int j = i; j < a.size( ); j++ )
                {
/* 4*/              int thisSum = 0;

/* 5*/              for( int k = i; k <= j; k++ )
/* 6*/                  thisSum += a[ k ];

/* 7*/              if( thisSum > maxSum )
/* 8*/                  maxSum   = thisSum;
                }

/* 9*/      return maxSum;
        }
/* END */


/* START: Fig02_06.txt */
        /**
         * Quadratic maximum contiguous subsequence sum algorithm.
         */
        int maxSubSum2( const vector<int> & a )
        {
/* 1*/      int maxSum = 0;

/* 2*/      for( int i = 0; i < a.size( ); i++ )
            {
/* 3*/          int thisSum = 0;
/* 4*/          for( int j = i; j < a.size( ); j++ )
                {
/* 5*/              thisSum += a[ j ];

/* 6*/              if( thisSum > maxSum )
/* 7*/                  maxSum = thisSum;
                }
            }

/* 8*/      return maxSum;
        }
/* END */

        /**
         * Return maximum of three integers.
         */
        int max3( int a, int b, int c )
        {
            return a > b ? a > c ? a : c : b > c ? b : c;
        }

/* START: Fig02_07.txt */
        /**
         * Recursive maximum contiguous subsequence sum algorithm.
         * Finds maximum sum in subarray spanning a[left..right].
         * Does not attempt to maintain actual best sequence.
         */
        int maxSumRec( const vector<int> & a, int left, int right )
        {
/* 1*/      if( left == right )  // Base case
/* 2*/          if( a[ left ] > 0 )
/* 3*/              return a[ left ];
                else
/* 4*/              return 0;

/* 5*/      int center = ( left + right ) / 2;
/* 6*/      int maxLeftSum  = maxSumRec( a, left, center );
/* 7*/      int maxRightSum = maxSumRec( a, center + 1, right );

/* 8*/      int maxLeftBorderSum = 0, leftBorderSum = 0;
/* 9*/      for( int i = center; i >= left; i-- )
            {
/*10*/          leftBorderSum += a[ i ];
/*11*/          if( leftBorderSum > maxLeftBorderSum )
/*12*/              maxLeftBorderSum = leftBorderSum;
            }

/*13*/      int maxRightBorderSum = 0, rightBorderSum = 0;
/*14*/      for( int j = center + 1; j <= right; j++ )
            {
/*15*/          rightBorderSum += a[ j ];
/*16*/          if( rightBorderSum > maxRightBorderSum )
/*17*/              maxRightBorderSum = rightBorderSum;
            }

/*18*/      return max3( maxLeftSum, maxRightSum,
/*19*/                   maxLeftBorderSum + maxRightBorderSum );
        }

        /**
         * Driver for divide-and-conquer maximum contiguous
         * subsequence sum algorithm.
         */
        int maxSubSum3( const vector<int> & a )
        {
            return maxSumRec( a, 0, a.size( ) - 1 );
        }
/* END */


/* START: Fig02_08.txt */
        /**
         * Linear-time maximum contiguous subsequence sum algorithm.
         */
        int maxSubSum4( const vector<int> & a )
        {
/* 1*/      int maxSum = 0, thisSum = 0;

/* 2*/      for( int j = 0; j < a.size( ); j++ )
            {
/* 3*/          thisSum += a[ j ];

/* 4*/          if( thisSum > maxSum )
/* 5*/              maxSum = thisSum;
/* 6*/          else if( thisSum < 0 )
/* 7*/              thisSum = 0;
            }

/* 8*/      return maxSum;
        }
/* END */

        /**
         * Simple test program.
         */
        int main( )
        {
            vector<int> a( 8 );
            a[ 0 ] = 4; a[ 1 ] = -3; a[ 2 ] = 5; a[ 3 ] = -2;
            a[ 4 ] = -1; a[ 5 ] = 2; a[ 6 ] = 6; a[ 7 ] = -2;
            int maxSum;

            maxSum = maxSubSum1( a );
            cout << "Max sum is " <<  maxSum << endl;
            maxSum = maxSubSum2( a );
            cout << "Max sum is " <<  maxSum << endl;
            maxSum = maxSubSum3( a );
            cout << "Max sum is " <<  maxSum << endl;
            maxSum = maxSubSum4( a );
            cout << "Max sum is " <<  maxSum << endl;

            return 0;
        }
Fig02_09.cpp - Test program for binary search
	
	#include <iostream.h>
        #include "vector.h"

        const int NOT_FOUND = -1;

/* START: Fig02_09.txt*/
        /**
         * Performs the standard binary search using two comparisons per level.
         * Returns index where item is found or -1 if not found
         */
        template <class Comparable>
        int binarySearch( const vector<Comparable> & a, const Comparable & x )
        {
/* 1*/      int low = 0, high = a.size( ) - 1;

/* 2*/      while( low <= high )
            {
/* 3*/          int mid = ( low + high ) / 2;

/* 4*/          if( a[ mid ] < x )
/* 5*/              low = mid + 1;
/* 6*/          else if( a[ mid ] > x )
/* 7*/              high = mid - 1;
                else
/* 8*/              return mid;   // Found
            }
/* 9*/      return NOT_FOUND;     // NOT_FOUND is defined as -1
        }
/* END */

        // Test program
        int main( )
        {
            const int SIZE = 8;
            vector<int> a( SIZE );

            for( int i = 0; i < SIZE; i++ )
                a[ i ] = i * 2;

            for( int j = 0; j < SIZE * 2; j++ )
                cout << "Found " << j << " at " << binarySearch( a, j ) << endl;
            return 0;
        }
Fig02_10.cpp - Euclid's algorithm, with a test program
	
	#include <iostream.h>

/* START: Fig02_10.txt*/
        long gcd( long m, long n )
        {
/* 1*/      while( n != 0 )
            {
/* 2*/          long rem = m % n;
/* 3*/          m = n;
/* 4*/          n = rem;
            }
/* 5*/      return m;
        }
/* END */

        // Test program
        int main( )
        {
            cout << "gcd( 45, 35 ) = " << gcd( 45, 35 ) << endl;
            cout << "gcd( 1989, 1590 ) = " << gcd( 1989, 1590 ) << endl;
            return 0;
        }
Fig02_11.cpp - Recursive exponentiation algorithm, with a test program
	
	#include <iostream.h>

        bool isEven( int n )
        {
            return n % 2 == 0;
        }

/* START: Fig02_11.txt*/
        long pow( long x, int n )
        {
/* 1*/      if( n == 0 )
/* 2*/          return 1;
/* 3*/      if( n == 1 )
/* 4*/          return x;
/* 5*/      if( isEven( n ) )
/* 6*/          return pow( x * x, n / 2 );
            else
/* 7*/          return pow( x * x, n / 2 ) * x;
        }
/* END */

        // Test program
        int main( )
        {
            cout << "2^21 = " << pow( 2, 21 ) << endl;
            cout << "2^30 = " << pow( 2, 30 ) << endl;
            return 0;
        }
LinkedList.h - Header file for linked list
	
	#ifndef LinkedList_H
        #define LinkedList_H

        #include "dsexceptions.h"
        #include <iostream.h>    // For NULL

        // List class
        //
        // CONSTRUCTION: with no initializer
        // Access is via ListItr class
        //
        // ******************PUBLIC OPERATIONS*********************
        // boolean isEmpty( )     --> Return true if empty; else false
        // void makeEmpty( )      --> Remove all items
        // ListItr zeroth( )      --> Return position to prior to first
        // ListItr first( )       --> Return first position
        // void insert( x, p )    --> Insert x after current iterator position p
        // void remove( x )       --> Remove x
        // ListItr find( x )      --> Return position that views x
        // ListItr findPrevious( x )
        //                        --> Return position prior to x
        // ******************ERRORS********************************
        // No special errors

        template <class Object>
        class List;     // Incomplete declaration.

        template <class Object>
        class ListItr;     // Incomplete declaration.

        template <class Object>
        class ListNode
        {
            ListNode( const Object & theElement = Object( ), ListNode * n = NULL )
              : element( theElement ), next( n ) { }

            Object   element;
            ListNode *next;

            friend class List<Object>;
            friend class ListItr<Object>;
        };


        template <class Object>
        class List
        {
          public:
            List( );
            List( const List & rhs );
            ~List( );

            bool isEmpty( ) const;
            void makeEmpty( );
            ListItr<Object> zeroth( ) const;
            ListItr<Object> first( ) const;
            void insert( const Object & x, const ListItr<Object> & p );
            ListItr<Object> find( const Object & x ) const;
            ListItr<Object> findPrevious( const Object & x ) const;
            void remove( const Object & x );

            const List & operator=( const List & rhs );

          private:
            ListNode<Object> *header;
        };


        // ListItr class; maintains "current position"
        //
        // CONSTRUCTION: Package friendly only, with a ListNode
        //
        // ******************PUBLIC OPERATIONS*********************
        // bool isPastEnd( )      --> True if past end position in list
        // void advance( )        --> Advance (if not already null)
        // Object retrieve        --> Return item in current position

        template <class Object>
        class ListItr
        {
          public:
            ListItr( ) : current( NULL ) { }
            bool isPastEnd( ) const
              { return current == NULL; }
            void advance( )
              { if( !isPastEnd( ) ) current = current->next; }
            const Object & retrieve( ) const
              { if( isPastEnd( ) ) throw BadIterator( );
                return current->element; }

          private:
            ListNode<Object> *current;    // Current position

            ListItr( ListNode<Object> *theNode )
              : current( theNode ) { }

            friend class List<Object>; // Grant access to constructor
        };

        #include "LinkedList.cpp"
        #endif
LinkedList.cpp - Implementation for linked list
	
	#include "LinkedList.h"

        /**
         * Construct the list
         */
        template <class Object>
        List<Object>::List( )
        {
            header = new ListNode<Object>;
        }

        /**
         * Copy constructor
         */
        template <class Object>
        List<Object>::List( const List<Object> & rhs )
        {
            header = new ListNode<Object>;
            *this = rhs;
        }

        /**
         * Destructor
         */
        template <class Object>
        List<Object>::~List( )
        {
            makeEmpty( );
            delete header;
        }

        /**
         * Test if the list is logically empty.
         * return true if empty, false otherwise.
         */
        template <class Object>
        bool List<Object>::isEmpty( ) const
        {
            return header->next == NULL;
        }

        /**
         * Make the list logically empty.
         */
        template <class Object>
        void List<Object>::makeEmpty( )
        {
            while( !isEmpty( ) )
                remove( first( ).retrieve( ) );
        }

        /**
         * Return an iterator representing the header node.
         */
        template <class Object>
        ListItr<Object> List<Object>::zeroth( ) const
        {
            return ListItr<Object>( header );
        }

        /**
         * Return an iterator representing the first node in the list.
         * This operation is valid for empty lists.
         */
        template <class Object>
        ListItr<Object> List<Object>::first( ) const
        {
            return ListItr<Object>( header->next );
        }

        /**
         * Insert item x after p.
         */
        template <class Object>
        void List<Object>::insert( const Object & x, const ListItr<Object> & p )
        {
            if( p.current != NULL )
                p.current->next = new ListNode<Object>( x, p.current->next );
        }

        /**
         * Return iterator corresponding to the first node containing an item x.
         * Iterator isPastEnd if item is not found.
         */
        template <class Object>
        ListItr<Object> List<Object>::find( const Object & x ) const
        {
/* 1*/      ListNode<Object> *itr = header->next;

/* 2*/      while( itr != NULL && itr->element != x )
/* 3*/          itr = itr->next;

/* 4*/      return ListItr<Object>( itr );
        }

        /**
         * Return iterator prior to the first node containing an item x.
         */
        template <class Object>
        ListItr<Object> List<Object>::findPrevious( const Object & x ) const
        {
/* 1*/      ListNode<Object> *itr = header;

/* 2*/      while( itr->next != NULL && itr->next->element != x )
/* 3*/          itr = itr->next;

/* 4*/      return ListItr<Object>( itr );
        }

        /**
         * Remove the first occurrence of an item x.
         */
        template <class Object>
        void List<Object>::remove( const Object & x )
        {
            ListItr<Object> p = findPrevious( x );

            if( p.current->next != NULL )
            {
                ListNode<Object> *oldNode = p.current->next;
                p.current->next = p.current->next->next;  // Bypass deleted node
                delete oldNode;
            }
        }

        /**
         * Deep copy of linked lists.
         */
        template <class Object>
        const List<Object> & List<Object>::operator=( const List<Object> & rhs )
        {
            ListItr<Object> ritr = rhs.first( );
            ListItr<Object> itr = zeroth( );

            if( this != &rhs )
            {
                makeEmpty( );
                for( ; !ritr.isPastEnd( ); ritr.advance( ), itr.advance( ) )
                    insert( ritr.retrieve( ), itr );
            }
            return *this;
        }

TestLinkedList.cpp - Test program for linked list package
	
	#include <iostream.h>
        #include "LinkedList.h"

            // Simple print method
        template <class Object>
        void printList( const List<Object> & theList )
        {
            if( theList.isEmpty( ) )
                cout << "Empty list" << endl;
            else
            {
                ListItr<Object> itr = theList.first( );
                for( ; !itr.isPastEnd( ); itr.advance( ) )
                    cout << itr.retrieve( ) << " ";
            }

            cout << endl;
        }


        int main( )
        {
            List<int>    theList;
            ListItr<int> theItr = theList.zeroth( );
            int i;

            printList( theList );

            for( i = 0; i < 10; i++ )
            {
                theList.insert( i, theItr );
                printList( theList );
                theItr.advance( );
            }

            for( i = 0; i < 10; i += 2 )
                theList.remove( i );

            for( i = 0; i < 10; i++ )
                if( ( i % 2 == 0 ) != ( theList.find( i ).isPastEnd( ) ) )
                    cout << "Find fails!" << endl;

            cout << "Finished deletions" << endl;
            printList( theList );

            List<int> list2;
            list2 = theList;
            printList( list2 );

            return 0;
        }
Polynomial.cpp - Polynomials
    
    /*
     * This code doesn't really do much, and abstraction is not built in.
     * Thus, I haven't bothered testing it exhaustively.
     */
    #include <iostream.h>
    #include "vector.h"

    class Polynomial
    {
        enum { MAX_DEGREE = 100 };
        friend int main( );   // So I can do a quick test.

      public:
        Polynomial( );
        void zeroPolynomial( );
        Polynomial operator+( const Polynomial & rhs ) const;
        Polynomial operator*( const Polynomial & rhs ) const;
        void print( ostream & out ) const;
  
      private:
        vector<int> coeffArray;
        int highPower;
    };


        int max( int a, int b )
        {
             return a > b ? a : b;
        }

        Polynomial::Polynomial( ) : coeffArray( MAX_DEGREE + 1 )
        {
           zeroPolynomial( );
        }

        void Polynomial::zeroPolynomial( )
        {
            for( int i = 0; i <= MAX_DEGREE; i++ )
                coeffArray[ i ] = 0;
            highPower = 0;
        }

        Polynomial Polynomial::operator+( const Polynomial & rhs ) const
        {
            Polynomial sum;

            sum.highPower = max( highPower, rhs.highPower );
            for( int i = sum.highPower; i >= 0; i-- )
                sum.coeffArray[ i ] = coeffArray[ i ] + rhs.coeffArray[ i ];
            return sum;
        }

        Polynomial Polynomial::operator*( const Polynomial & rhs ) const
        {
            Polynomial product;

            product.highPower = highPower + rhs.highPower;
            if( product.highPower > MAX_DEGREE )
                cerr << "operator* exceeded MAX_DEGREE" << endl;
            for( int i = 0; i <= highPower; i++ )
                for( int j = 0; j <= rhs.highPower; j++ )
                    product.coeffArray[ i + j ] +=
                            coeffArray[ i ] * rhs.coeffArray[ j ];
            return product;
        }

        void Polynomial::print( ostream & out ) const
        {
            for( int i = highPower; i > 0; i-- )
                out << coeffArray[ i ] << "x^" << i << " + ";
            out << coeffArray[ 0 ] << endl;
        }

        ostream & operator<<( ostream & out, const Polynomial & rhs )
        {
            rhs.print( out );
            return out;
        }

        int main( )
        {
            Polynomial p;
            Polynomial q;

            p.highPower = 1; p.coeffArray[ 0 ] = 1; p.coeffArray[ 1 ] = 1;

            q = p + p;
            p = q * q;
            q = p + p;

            cout << q << endl;
            return 0;
        }
CursorList.h - Header file for cursor linked list
	
	#ifndef CursorList_H
        #define CursorList_H

#define List CursorList

        #include "vector.h"
        #include "dsexceptions.h"

        // LinkedList class using a cursor implementation
        //
        // CONSTRUCTION: with no initializer
        // Access is via LinkedListItr class
        //
        // ******************PUBLIC OPERATIONS*********************
        // boolean isEmpty( )     --> Return true if empty; else false
        // void makeEmpty( )      --> Remove all items
        // ListItr zeroth( )      --> Return position to prior to first
        // ListItr first( )       --> Return first position
        // void insert( x, p )    --> Insert x after current iterator position p
        // void remove( x )       --> Remove x
        // ListItr find( x )      --> Return position that views x
        // ListItr findPrevious( x )
        //                        --> Return position prior to x
        // ******************ERRORS********************************
        // No special errors

        template <class Object>
        class ListItr;     // Incomplete declaration.

        template <class Object>
        class List
        {
          public:
            List( );
            List( const List & rhs );
            ~List( );

            bool isEmpty( ) const;
            void makeEmpty( );
            ListItr<Object> zeroth( ) const;
            ListItr<Object> first( ) const;
            void insert( const Object & x, const ListItr<Object> & p );
            ListItr<Object> find( const Object & x ) const;
            ListItr<Object> findPrevious( const Object & x ) const;
            void remove( const Object & x );

          public:
            struct CursorNode
            {
                CursorNode( ) : next( 0 ) { }

              private:
                CursorNode( const Object & theElement, int n )
                  : element( theElement ), next( n ) { }

                Object element;
                int    next;

                friend class List<Object>;
                friend class ListItr<Object>;
            };

            const List & operator=( const List & rhs );

          private:
            int header;

            static vector<CursorNode> cursorSpace;

            static void initializeCursorSpace( );
            static int alloc( );
            static void free( int p );

            friend class ListItr<Object>;
        };


        // ListItr class; maintains "current position"
        //
        // CONSTRUCTION: Package friendly only, with an int
        //
        // ******************PUBLIC OPERATIONS*********************
        // bool isPastEnd( )      --> True if at valid position in list
        // void advance( )        --> Advance (if not already null)
        // Object retrieve        --> Return item in current position

        template <class Object>
        class ListItr
        {
          public:
            ListItr( ) : current( 0 ) { }
            bool isPastEnd( ) const
              { return current == 0; }
            void advance( )
              { if( !isPastEnd( ) ) current = List<Object>::cursorSpace[ current ].next; }
            const Object & retrieve( ) const
              { if( isPastEnd( ) ) throw BadIterator( );
                return List<Object>::cursorSpace[ current ].element; }

          private:
            int current;       // Current position
            friend class List<Object>;

            ListItr( int theNode )
              : current( theNode ) { }
        };

        #include "CursorList.cpp"
        #endif
CursorList.cpp - Implementation for cursor linked list
	
	#include "CursorList.h"

        /**
         * Routine to initialize the cursorSpace.
         */
        template <class Object>
        void List<Object>::initializeCursorSpace( )
        {
            static int cursorSpaceIsInitialized = false;

            if( !cursorSpaceIsInitialized )
            {
                cursorSpace.resize( 100 );
                for( int i = 0; i < cursorSpace.size( ); i++ )
                    cursorSpace[ i ].next = i + 1;
                cursorSpace[ cursorSpace.size( ) - 1 ].next = 0;
                cursorSpaceIsInitialized = true;
            }
        }

        /**
         * Allocate a CursorNode
         */
        template <class Object>
        int List<Object>::alloc( )
        {
            int p = cursorSpace[ 0 ].next;
            cursorSpace[ 0 ].next = cursorSpace[ p ].next;
            return p;
        }

        /**
         * Free a CursorNode
         */
        template <class Object>
        void List<Object>::free( int p )
        {
            cursorSpace[ p ].next = cursorSpace[ 0 ].next;
            cursorSpace[ 0 ].next = p;
        }


        /**
         * Construct the list
         */
        template <class Object>
        List<Object>::List( )
        {
            initializeCursorSpace( );
            header = alloc( );
            cursorSpace[ header ].next = 0;
        }

        /**
         * Copy constructor
         */
        template <class Object>
        List<Object>::List( const List<Object> & rhs )
        {
            initializeCursorSpace( );
            header = alloc( );
            cursorSpace[ header ].next = 0;
            *this = rhs;
        }

        /**
         * Destroy the list
         */
        template <class Object>
        List<Object>::~List( )
        {
            makeEmpty( );
            free( header );
        }

        /**
         * Test if the list is logically empty.
         * return true if empty, false otherwise.
         */
        template <class Object>
        bool List<Object>::isEmpty( ) const
        {
            return cursorSpace[ header ].next == 0;
        }

        /**
         * Make the list logically empty.
         */
        template <class Object>
        void List<Object>::makeEmpty( )
        {
            while( !isEmpty( ) )
                remove( first( ).retrieve( ) );
        }

        /**
         * Return an iterator representing the header node.
         */
        template <class Object>
        ListItr<Object> List<Object>::zeroth( ) const
        {
            return ListItr<Object>( header );
        }

        /**
         * Return an iterator representing the first node in the list.
         * This operation is valid for empty lists.
         */
        template <class Object>
        ListItr<Object> List<Object>::first( ) const
        {
            return ListItr<Object>( cursorSpace[ header ].next );
        }

        /**
         * Insert item x after p.
         */
        template <class Object>
        void List<Object>::insert( const Object & x, const ListItr<Object> & p )
        {
            if( p.current != 0 )
            {
                int pos = p.current;
                int tmp = alloc( );

                cursorSpace[ tmp ] = CursorNode( x, cursorSpace[ pos ].next );
                cursorSpace[ pos ].next = tmp;
            }
        }

        /**
         * Return iterator corresponding to the first node containing an item x.
         * Iterator isPastEnd if item is not found.
         */
        template <class Object>
        ListItr<Object> List<Object>::find( const Object & x ) const
        {
/* 1*/      int itr = cursorSpace[ header ].next;

/* 2*/      while( itr != 0 && cursorSpace[ itr ].element != x )
/* 3*/          itr = cursorSpace[ itr ].next;

/* 4*/      return ListItr<Object>( itr );
        }

        /**
         * Return iterator prior to the first node containing an item x.
         */
        template <class Object>
        ListItr<Object> List<Object>::findPrevious( const Object & x ) const
        {
/* 1*/      int itr = header;

/* 2*/      while( cursorSpace[ itr ].next != 0 &&
                   cursorSpace[ cursorSpace[ itr ].next ].element != x )
/* 3*/          itr = cursorSpace[ itr ].next;

/* 4*/      return ListItr<Object>( itr );
        }

        /**
         * Remove the first occurrence of an item x.
         */
        template <class Object>
        void List<Object>::remove( const Object & x )
        {
            ListItr<Object> p = findPrevious( x );
            int pos = p.current;

            if( cursorSpace[ pos ].next != 0 )
            {
                int tmp = cursorSpace[ pos ].next;
                cursorSpace[ pos ].next = cursorSpace[ tmp ].next;
                free ( tmp );
            }
        }


        /**
         * Deep copy of linked lists.
         */
        template <class Object>
        const List<Object> & List<Object>::operator=( const List<Object> & rhs )
        {
            ListItr<Object> ritr = rhs.first( );
            ListItr<Object> itr = zeroth( );

            if( this != &rhs )
            {
                makeEmpty( );
                for( ; !ritr.isPastEnd( ); ritr.advance( ), itr.advance( ) )
                    insert( ritr.retrieve( ), itr );
            }
            return *this;
        }


TestCursorList.cpp - Test program for cursor implementation of linked lists
	
	#include <iostream.h>
        #include "CursorList.h"

            // Simple print method
        template <class Object>
        void printList( const List<Object> & theList )
        {
            if( theList.isEmpty( ) )
                cout << "Empty list" << endl;
            else
            {
                ListItr<Object> itr = theList.first( );
                for( ; !itr.isPastEnd( ); itr.advance( ) )
                    cout << itr.retrieve( ) << " ";
            }

            cout << endl;
        }

        vector<List<int>::CursorNode> List<int>::cursorSpace;

        int main( )
        {
            List<int>    theList;
            ListItr<int> theItr = theList.zeroth( );
            int i;

            printList( theList );

            for( i = 0; i < 10; i++ )
            {
                theList.insert( i, theItr );
                printList( theList );
                theItr.advance( );
            }

            for( i = 0; i < 10; i += 2 )
                theList.remove( i );

            for( i = 0; i < 10; i++ )
                if( ( i % 2 == 0 ) != ( theList.find( i ).isPastEnd( ) ) )
                    cout << "Find fails!" << endl;

            cout << "Finished deletions" << endl;
            printList( theList );

            return 0;
        }
StackAr.h - Header file for stack - array version
	
	#ifndef STACKAR_H
        #define STACKAR_H

        #include "vector.h"
        #include "dsexceptions.h"

        // Stack class -- array implementation
        //
        // CONSTRUCTION: with or without a capacity; default is 10
        //
        // ******************PUBLIC OPERATIONS*********************
        // void push( x )         --> Insert x
        // void pop( )            --> Remove most recently inserted item
        // Object top( )          --> Return most recently inserted item
        // Object topAndPop( )    --> Return and remove most recently inserted item
        // bool isEmpty( )        --> Return true if empty; else false
        // bool isFull( )         --> Return true if full; else false
        // void makeEmpty( )      --> Remove all items
        // ******************ERRORS********************************
        // Overflow and Underflow thrown as needed

        template <class Object>
        class Stack
        {
          public:
            explicit Stack( int capacity = 10 );

            bool isEmpty( ) const;
            bool isFull( ) const;
            const Object & top( ) const;

            void makeEmpty( );
            void pop( );
            void push( const Object & x );
            Object topAndPop( );

          private:
            vector<Object> theArray;
            int            topOfStack;
        };

        #include "StackAr.cpp"
        #endif
StackAr.cpp - Implementation for stack - array version
	
	#include "StackAr.h"

        /**
         * Construct the stack.
         */
        template <class Object>
        Stack<Object>::Stack( int capacity ) : theArray( capacity )
        {
            topOfStack = -1;
        }

        /**
         * Test if the stack is logically empty.
         * Return true if empty, false otherwise.
         */
        template <class Object>
        bool Stack<Object>::isEmpty( ) const
        {
            return topOfStack == -1;
        }

        /**
         * Test if the stack is logically full.
         * Return true if full, false otherwise.
         */
        template <class Object>
        bool Stack<Object>::isFull( ) const
        {
            return topOfStack == theArray.size( ) - 1;
        }

        /**
         * Make the stack logically empty.
         */
        template <class Object>
        void Stack<Object>::makeEmpty( )
        {
            topOfStack = -1;
        }

        /**
         * Get the most recently inserted item in the stack.
         * Does not alter the stack.
         * Return the most recently inserted item in the stack.
         * Exception Underflow if stack is already empty.
         */
        template <class Object>
        const Object & Stack<Object>::top( ) const
        {
            if( isEmpty( ) )
                throw Underflow( );
            return theArray[ topOfStack ];
        }

        /**
         * Remove the most recently inserted item from the stack.
         * Exception Underflow if stack is already empty.
         */
        template <class Object>
        void Stack<Object>::pop( )
        {
            if( isEmpty( ) )
                throw Underflow( );
            topOfStack--;
        }

        /**
         * Insert x into the stack, if not already full.
         * Exception Overflow if stack is already full.
         */
        template <class Object>
        void Stack<Object>::push( const Object & x )
        {
            if( isFull( ) )
                throw Overflow( );
            theArray[ ++topOfStack ] = x;
        }

        /**
         * Return and remove most recently inserted item from the stack.
         * Return most recently inserted item.
         * Exception Underflow if stack is already empty.
         */
        template <class Object>
        Object Stack<Object>::topAndPop( )
        {
            if( isEmpty( ) )
                throw Underflow( );
            return theArray[ topOfStack-- ];
        }
TestStackAr.cpp - Test program for (array-based) stacks
	
	#include <iostream.h>
        #include "StackAr.h"

        int main( )
        {
            Stack<int> s;

            for( int i = 0; i < 10; i++ )
                s.push( i );
        
            while( !s.isEmpty( ) )
                cout << s.topAndPop( ) << endl;

            return 0;
        } 
StackLi.h - Header file for stack - list version
	
	#ifndef STACKLI_H
        #define STACKLI_H

        #include "dsexceptions.h"
        #include <iostream.h>       // For NULL

        // Stack class -- linked list implementation
        //
        // CONSTRUCTION: with no parameters
        //
        // ******************PUBLIC OPERATIONS*********************
        // void push( x )         --> Insert x
        // void pop( )            --> Remove most recently inserted item
        // Object top( )          --> Return most recently inserted item
        // Object topAndPop( )    --> Return and remove most recently inserted item
        // bool isEmpty( )        --> Return true if empty; else false
        // bool isFull( )         --> Return true if full; else false
        // void makeEmpty( )      --> Remove all items
        // ******************ERRORS********************************
        // Overflow and Underflow thrown as needed

        template <class Object>
        class Stack
        {
          public:
            Stack( );
            Stack( const Stack & rhs );
            ~Stack( );

            bool isEmpty( ) const;
            bool isFull( ) const;
            const Object & top( ) const;

            void makeEmpty( );
            void pop( );
            void push( const Object & x );
            Object topAndPop( );

            const Stack & operator=( const Stack & rhs );

          private:
            struct ListNode
            {
                Object   element;
                ListNode *next;

                ListNode( const Object & theElement, ListNode * n = NULL )
                  : element( theElement ), next( n ) { }
            };

            ListNode *topOfStack;
        };

        #include "StackLi.cpp"
        #endif

StackLi.cpp - Implementation for stack - list version
	
	#include "StackLi.h"
        #include <iostream.h>

        /**
         * Construct the stack.
         */
        template <class Object>
        Stack<Object>::Stack( )
        {
            topOfStack = NULL;
        }

        /**
         * Copy constructor.
         */
        template <class Object>
        Stack<Object>::Stack( const Stack<Object> & rhs )
        {
            topOfStack = NULL;
            *this = rhs;
        }

        /**
         * Destructor.
         */
        template <class Object>
        Stack<Object>::~Stack( )
        {
            makeEmpty( );
        }

        /**
         * Test if the stack is logically full.
         * Return false always, in this implementation.
         */
        template <class Object>
        bool Stack<Object>::isFull( ) const
        {
            return false;
        }

        /**
         * Test if the stack is logically empty.
         * Return true if empty, false otherwise.
         */
        template <class Object>
        bool Stack<Object>::isEmpty( ) const
        {
            return topOfStack == NULL;
        }

        /**
         * Make the stack logically empty.
         */
        template <class Object>
        void Stack<Object>::makeEmpty( )
        {
            while( !isEmpty( ) )
                pop( );
        }

        /**
         * Get the most recently inserted item in the stack.
         * Return the most recently inserted item in the stack
         * or throw an exception if empty.
         */
        template <class Object>
        const Object & Stack<Object>::top( ) const
        {
            if( isEmpty( ) )
                throw Underflow( );
            return topOfStack->element;
        }

        /**
         * Remove the most recently inserted item from the stack.
         * Exception Underflow if the stack is empty.
         */
        template <class Object>
        void Stack<Object>::pop( )
        {
            if( isEmpty( ) )
                throw Underflow( );

            ListNode *oldTop = topOfStack;
            topOfStack = topOfStack->next;
            delete oldTop;
        }

        /**
         * Return and remove the most recently inserted item
         * from the stack.
         */
        template <class Object>
        Object Stack<Object>::topAndPop( )
        {
            Object topItem = top( );
            pop( );
            return topItem;
        }

        /**
         * Insert x into the stack.
         */
        template <class Object>
        void Stack<Object>::push( const Object & x )
        {
            topOfStack = new ListNode( x, topOfStack );
        }

        /**
         * Deep copy.
         */
        template <class Object>
        const Stack<Object> & Stack<Object>::
        operator=( const Stack<Object> & rhs )
        {
            if( this != &rhs )
            {
                makeEmpty( );
                if( rhs.isEmpty( ) )
                    return *this;

                ListNode *rptr = rhs.topOfStack;
                ListNode *ptr  = new ListNode( rptr->element );
                topOfStack = ptr;

                for( rptr = rptr->next; rptr != NULL; rptr = rptr->next )
                    ptr = ptr->next = new ListNode( rptr->element );
            }
            return *this;
        }
TestStackLi.cpp - Test program for (list-based) stacks
	
	#include "StackLi.h"
        #include <iostream.h>

        int main( )
        {
            Stack<int> s, s1;

            for( int i = 0; i < 10; i++ )
                s.push( i );
        
            s1 = s;

            cout << "s" << endl;
            while( !s.isEmpty( ) )
                cout << s.topAndPop( ) << endl;

            cout << endl << "s1" << endl;
            while( !s1.isEmpty( ) )
                cout << s1.topAndPop( ) << endl;

            return 0;
        } 
QueueAr.h - Header file for queue - array version
	
	#ifndef QUEUEAR_H
        #define QUEUEAR_H

        #include "vector.h"
        #include "dsexceptions.h"

        // Queue class -- array implementation
        //
        // CONSTRUCTION: with or without a capacity; default is 10
        //
        // ******************PUBLIC OPERATIONS*********************
        // void enqueue( x )      --> Insert x
        // void dequeue( )        --> Return and remove least recently inserted item
        // Object getFront( )     --> Return least recently inserted item
        // bool isEmpty( )        --> Return true if empty; else false
        // bool isFull( )         --> Return true if full; else false
        // void makeEmpty( )      --> Remove all items
        // ******************ERRORS********************************
        // Overflow and Underflow thrown as needed

        template <class Object>
        class Queue
        {
          public:
            explicit Queue( int capacity = 10 );

            bool isEmpty( ) const;
            bool isFull( ) const;
            const Object & getFront( ) const;

            void makeEmpty( );
            Object dequeue( );
            void enqueue( const Object & x );

          private:
            vector<Object> theArray;
            int            currentSize;
            int            front;
            int            back;

            void increment( int & x );
        };

        #include "QueueAr.cpp"
        #endif
QueueAr.cpp - Implementation for queue - array version
	
	#include "QueueAr.h"

        /**
         * Construct the queue.
         */
        template <class Object>
        Queue<Object>::Queue( int capacity ) : theArray( capacity )
        {
            makeEmpty( );
        }

        /**
         * Test if the queue is logically empty.
         * Return true if empty, false otherwise.
         */
        template <class Object>
        bool Queue<Object>::isEmpty( ) const
        {
            return currentSize == 0;
        }

        /**
         * Test if the queue is logically full.
         * Return true if full, false otherwise.
         */
        template <class Object>
        bool Queue<Object>::isFull( ) const
        {
            return currentSize == theArray.size( );
        }

        /**
         * Make the queue logically empty.
         */
        template <class Object>
        void Queue<Object>::makeEmpty( )
        {
            currentSize = 0;
            front = 0;
            back = -1;
        }

        /**
         * Get the least recently inserted item in the queue.
         * Return the least recently inserted item in the queue
         * or throw Underflow if empty.
         */
        template <class Object>
        const Object & Queue<Object>::getFront( ) const
        {
            if( isEmpty( ) )
                throw Underflow( );
            return theArray[ front ];
        }

        /**
         * Return and remove the least recently inserted item from the queue.
         * Throw Underflow if empty.
         */
        template <class Object>
        Object Queue<Object>::dequeue( )
        {
            if( isEmpty( ) )
                throw Underflow( );

            currentSize--;
            Object frontItem = theArray[ front ];
            increment( front );
            return frontItem;
        }

        /**
         * Insert x into the queue.
         * Throw Overflow if queue is full
         */
        template <class Object>
        void Queue<Object>::enqueue( const Object & x )
        {
            if( isFull( ) )
                throw Overflow( );
            increment( back );
            theArray[ back ] = x;
            currentSize++;
        }

        /**
         * Internal method to increment x with wraparound.
         */
        template <class Object>
        void Queue<Object>::increment( int & x )
        {
            if( ++x == theArray.size( ) )
                x = 0;
        }
TestQueueAr.cpp - Test program for queues
	
	#include <iostream.h>
        #include "QueueAr.h"
        
        int main( )
        {
            Queue<int> q;

            for( int j = 0; j < 5; j++ )
            {
                for( int i = 0; i < 5; i++ )
                    q.enqueue( i );
        
                while( !q.isEmpty( ) )
                    cout << q.dequeue( ) << endl;
            }

            return 0;
        } 
BinarySearchTree.h - Header file for binary search tree
	
	#ifndef BINARY_SEARCH_TREE_H_
        #define BINARY_SEARCH_TREE_H_

        #include "dsexceptions.h"
        #include <iostream.h>       // For NULL

          // Binary node and forward declaration because g++ does
          // not understand nested classes.
        template <class Comparable>
        class BinarySearchTree;

        template <class Comparable>
        class BinaryNode
        {
            Comparable element;
            BinaryNode *left;
            BinaryNode *right;

            BinaryNode( const Comparable & theElement, BinaryNode *lt, BinaryNode *rt )
              : element( theElement ), left( lt ), right( rt ) { }
            friend class BinarySearchTree<Comparable>;
        };


        // BinarySearchTree class
        //
        // CONSTRUCTION: with ITEM_NOT_FOUND object used to signal failed finds
        //
        // ******************PUBLIC OPERATIONS*********************
        // void insert( x )       --> Insert x
        // void remove( x )       --> Remove x
        // Comparable find( x )   --> Return item that matches x
        // Comparable findMin( )  --> Return smallest item
        // Comparable findMax( )  --> Return largest item
        // boolean isEmpty( )     --> Return true if empty; else false
        // void makeEmpty( )      --> Remove all items
        // void printTree( )      --> Print tree in sorted order

        template <class Comparable>
        class BinarySearchTree
        {
          public:
            explicit BinarySearchTree( const Comparable & notFound );
            BinarySearchTree( const BinarySearchTree & rhs );
            ~BinarySearchTree( );

            const Comparable & findMin( ) const;
            const Comparable & findMax( ) const;
            const Comparable & find( const Comparable & x ) const;
            bool isEmpty( ) const;
            void printTree( ) const;

            void makeEmpty( );
            void insert( const Comparable & x );
            void remove( const Comparable & x );

            const BinarySearchTree & operator=( const BinarySearchTree & rhs );

          private:
            BinaryNode<Comparable> *root;
            const Comparable ITEM_NOT_FOUND;

            const Comparable & elementAt( BinaryNode<Comparable> *t ) const;

            void insert( const Comparable & x, BinaryNode<Comparable> * & t ) const;
            void remove( const Comparable & x, BinaryNode<Comparable> * & t ) const;
            BinaryNode<Comparable> * findMin( BinaryNode<Comparable> *t ) const;
            BinaryNode<Comparable> * findMax( BinaryNode<Comparable> *t ) const;
            BinaryNode<Comparable> * find( const Comparable & x, BinaryNode<Comparable> *t ) const;
            void makeEmpty( BinaryNode<Comparable> * & t ) const;
            void printTree( BinaryNode<Comparable> *t ) const;
            BinaryNode<Comparable> * clone( BinaryNode<Comparable> *t ) const;
        };

        #include "BinarySearchTree.cpp"
        #endif
BinarySearchTree.cpp - Implementation for binary search tree
	
	#include "BinarySearchTree.h"
        #include <iostream.h>

        /**
         * Implements an unbalanced binary search tree.
         * Note that all "matching" is based on the < method.
         */

        /**
         * Construct the tree.
         */
        template <class Comparable>
        BinarySearchTree<Comparable>::BinarySearchTree( const Comparable & notFound ) :
          root( NULL ), ITEM_NOT_FOUND( notFound )
        {
        }


        /**
         * Copy constructor.
         */
        template <class Comparable>
        BinarySearchTree<Comparable>::
        BinarySearchTree( const BinarySearchTree<Comparable> & rhs ) :
          root( NULL ), ITEM_NOT_FOUND( rhs.ITEM_NOT_FOUND )
        { 
            *this = rhs;
        }

        /**
         * Destructor for the tree.
         */
        template <class Comparable>
        BinarySearchTree<Comparable>::~BinarySearchTree( )
        {
            makeEmpty( );
        }

        /**
         * Insert x into the tree; duplicates are ignored.
         */
        template <class Comparable>
        void BinarySearchTree<Comparable>::insert( const Comparable & x )
        {
            insert( x, root );
        }

        /**
         * Remove x from the tree. Nothing is done if x is not found.
         */
        template <class Comparable>
        void BinarySearchTree<Comparable>::remove( const Comparable & x )
        {
            remove( x, root );
        }


        /**
         * Find the smallest item in the tree.
         * Return smallest item or ITEM_NOT_FOUND if empty.
         */
        template <class Comparable>
        const Comparable & BinarySearchTree<Comparable>::findMin( ) const
        {
            return elementAt( findMin( root ) );
        }

        /**
         * Find the largest item in the tree.
         * Return the largest item of ITEM_NOT_FOUND if empty.
         */
        template <class Comparable>
        const Comparable & BinarySearchTree<Comparable>::findMax( ) const
        {
            return elementAt( findMax( root ) );
        }

        /**
         * Find item x in the tree.
         * Return the matching item or ITEM_NOT_FOUND if not found.
         */
        template <class Comparable>
        const Comparable & BinarySearchTree<Comparable>::
                                 find( const Comparable & x ) const
        {
            return elementAt( find( x, root ) );
        }

        /**
         * Make the tree logically empty.
         */
        template <class Comparable>
        void BinarySearchTree<Comparable>::makeEmpty( )
        {
            makeEmpty( root );
        }

        /**
         * Test if the tree is logically empty.
         * Return true if empty, false otherwise.
         */
        template <class Comparable>
        bool BinarySearchTree<Comparable>::isEmpty( ) const
        {
            return root == NULL;
        }

        /**
         * Print the tree contents in sorted order.
         */
        template <class Comparable>
        void BinarySearchTree<Comparable>::printTree( ) const
        {
            if( isEmpty( ) )
                cout << "Empty tree" << endl;
            else
                printTree( root );
        }

        /**
         * Deep copy.
         */
        template <class Comparable>
        const BinarySearchTree<Comparable> &
        BinarySearchTree<Comparable>::
        operator=( const BinarySearchTree<Comparable> & rhs )
        {
            if( this != &rhs )
            {
                makeEmpty( );
                root = clone( rhs.root );
            }
            return *this;
        }

        /**
         * Internal method to get element field in node t.
         * Return the element field or ITEM_NOT_FOUND if t is NULL.
         */
        template <class Comparable>
        const Comparable & BinarySearchTree<Comparable>::
        elementAt( BinaryNode<Comparable> *t ) const
        {
            if( t == NULL )
                return ITEM_NOT_FOUND;
            else
                return t->element;
        }

        /**
         * Internal method to insert into a subtree.
         * x is the item to insert.
         * t is the node that roots the tree.
         * Set the new root.
         */
        template <class Comparable>
        void BinarySearchTree<Comparable>::
        insert( const Comparable & x, BinaryNode<Comparable> * & t ) const
        {
            if( t == NULL )
                t = new BinaryNode<Comparable>( x, NULL, NULL );
            else if( x < t->element )
                insert( x, t->left );
            else if( t->element < x )
                insert( x, t->right );
            else
                ;  // Duplicate; do nothing
        }

        /**
         * Internal method to remove from a subtree.
         * x is the item to remove.
         * t is the node that roots the tree.
         * Set the new root.
         */
        template <class Comparable>
        void BinarySearchTree<Comparable>::
        remove( const Comparable & x, BinaryNode<Comparable> * & t ) const
        {
            if( t == NULL )
                return;   // Item not found; do nothing
            if( x < t->element )
                remove( x, t->left );
            else if( t->element < x )
                remove( x, t->right );
            else if( t->left != NULL && t->right != NULL ) // Two children
            {
                t->element = findMin( t->right )->element;
                remove( t->element, t->right );
            }
            else
            {
                BinaryNode<Comparable> *oldNode = t;
                t = ( t->left != NULL ) ? t->left : t->right;
                delete oldNode;
            }
        }

        /**
         * Internal method to find the smallest item in a subtree t.
         * Return node containing the smallest item.
         */
        template <class Comparable>
        BinaryNode<Comparable> *
        BinarySearchTree<Comparable>::findMin( BinaryNode<Comparable> *t ) const
        {
            if( t == NULL )
                return NULL;
            if( t->left == NULL )
                return t;
            return findMin( t->left );
        }

        /**
         * Internal method to find the largest item in a subtree t.
         * Return node containing the largest item.
         */
        template <class Comparable>
        BinaryNode<Comparable> *
        BinarySearchTree<Comparable>::findMax( BinaryNode<Comparable> *t ) const
        {
            if( t != NULL )
                while( t->right != NULL )
                    t = t->right;
            return t;
        }

        /**
         * Internal method to find an item in a subtree.
         * x is item to search for.
         * t is the node that roots the tree.
         * Return node containing the matched item.
         */
        template <class Comparable>
        BinaryNode<Comparable> *
        BinarySearchTree<Comparable>::
        find( const Comparable & x, BinaryNode<Comparable> *t ) const
        {
            if( t == NULL )
                return NULL;
            else if( x < t->element )
                return find( x, t->left );
            else if( t->element < x )
                return find( x, t->right );
            else
                return t;    // Match
        }
/****** NONRECURSIVE VERSION*************************
        template <class Comparable>
        BinaryNode<Comparable> *
        BinarySearchTree<Comparable>::
        find( const Comparable & x, BinaryNode<Comparable> *t ) const
        {
            while( t != NULL )
                if( x < t->element )
                    t = t->left;
                else if( t->element < x )
                    t = t->right;
                else
                    return t;    // Match

            return NULL;   // No match
        }
*****************************************************/

        /**
         * Internal method to make subtree empty.
         */
        template <class Comparable>
        void BinarySearchTree<Comparable>::
        makeEmpty( BinaryNode<Comparable> * & t ) const
        {
            if( t != NULL )
            {
                makeEmpty( t->left );
                makeEmpty( t->right );
                delete t;
            }
            t = NULL;
        }

        /**
         * Internal method to print a subtree rooted at t in sorted order.
         */
        template <class Comparable>
        void BinarySearchTree<Comparable>::printTree( BinaryNode<Comparable> *t ) const
        {
            if( t != NULL )
            {
                printTree( t->left );
                cout << t->element << endl;
                printTree( t->right );
            }
        }

        /**
         * Internal method to clone subtree.
         */
        template <class Comparable>
        BinaryNode<Comparable> *
        BinarySearchTree<Comparable>::clone( BinaryNode<Comparable> * t ) const
        {
            if( t == NULL )
                return NULL;
            else
                return new BinaryNode<Comparable>( t->element, clone( t->left ), clone( t->right ) );
        }
TestBinarySearchTree.cpp - Test program for binary search tree
	
	#include <iostream.h>
        #include "BinarySearchTree.h"

            // Test program
        int main( )
        {
            const int ITEM_NOT_FOUND = -9999;
            BinarySearchTree<int> t( ITEM_NOT_FOUND );
            int NUMS = 4000;
            const int GAP  =   37;
            int i;

            cout << "Checking... (no more output means success)" << endl;

            for( i = GAP; i != 0; i = ( i + GAP ) % NUMS )
                t.insert( i );

            for( i = 1; i < NUMS; i+= 2 )
                t.remove( i );

            if( NUMS < 40 )
                t.printTree( );
            if( t.findMin( ) != 2 || t.findMax( ) != NUMS - 2 )
                cout << "FindMin or FindMax error!" << endl;

            for( i = 2; i < NUMS; i+=2 )
                if( t.find( i ) != i )
                    cout << "Find error1!" << endl;

            for( i = 1; i < NUMS; i+=2 )
            {
                if( t.find( i ) != ITEM_NOT_FOUND )
                    cout << "Find error2!" << endl;
            }

            BinarySearchTree<int> t2( ITEM_NOT_FOUND );
            t2 = t;

            for( i = 2; i < NUMS; i+=2 )
                if( t2.find( i ) != i )
                    cout << "Find error1!" << endl;

            for( i = 1; i < NUMS; i+=2 )
            {
                if( t2.find( i ) != ITEM_NOT_FOUND )
                    cout << "Find error2!" << endl;
            }


            return 0;
    }
AvlTree.h - Header file for AVL tree
	
	#ifndef AVL_TREE_H_
        #define AVL_TREE_H_


          // Node and forward declaration because g++ does
          // not understand nested classes.
        template <class Comparable>
        class AvlTree;

        template <class Comparable>
        class AvlNode
        {
            Comparable element;
            AvlNode   *left;
            AvlNode   *right;
            int       height;

            AvlNode( const Comparable & theElement, AvlNode *lt, AvlNode *rt, int h = 0 )
              : element( theElement ), left( lt ), right( rt ), height( h ) { }
            friend class AvlTree<Comparable>;
        };

        #include "dsexceptions.h"
        #include <iostream.h>       // For NULL

        // AvlTree class
        //
        // CONSTRUCTION: with ITEM_NOT_FOUND object used to signal failed finds
        //
        // ******************PUBLIC OPERATIONS*********************
        // void insert( x )       --> Insert x
        // void remove( x )       --> Remove x (unimplemented)
        // Comparable find( x )   --> Return item that matches x
        // Comparable findMin( )  --> Return smallest item
        // Comparable findMax( )  --> Return largest item
        // boolean isEmpty( )     --> Return true if empty; else false
        // void makeEmpty( )      --> Remove all items
        // void printTree( )      --> Print tree in sorted order

        template <class Comparable>
        class AvlTree
        {
          public:
            explicit AvlTree( const Comparable & notFound );
            AvlTree( const AvlTree & rhs );
            ~AvlTree( );

            const Comparable & findMin( ) const;
            const Comparable & findMax( ) const;
            const Comparable & find( const Comparable & x ) const;
            bool isEmpty( ) const;
            void printTree( ) const;

            void makeEmpty( );
            void insert( const Comparable & x );
            void remove( const Comparable & x );

            const AvlTree & operator=( const AvlTree & rhs );

          private:
            AvlNode<Comparable> *root;
            const Comparable ITEM_NOT_FOUND;

            const Comparable & elementAt( AvlNode<Comparable> *t ) const;

            void insert( const Comparable & x, AvlNode<Comparable> * & t ) const;
            AvlNode<Comparable> * findMin( AvlNode<Comparable> *t ) const;
            AvlNode<Comparable> * findMax( AvlNode<Comparable> *t ) const;
            AvlNode<Comparable> * find( const Comparable & x, AvlNode<Comparable> *t ) const;
            void makeEmpty( AvlNode<Comparable> * & t ) const;
            void printTree( AvlNode<Comparable> *t ) const;
            AvlNode<Comparable> * clone( AvlNode<Comparable> *t ) const;

                // Avl manipulations
            int height( AvlNode<Comparable> *t ) const;
            int max( int lhs, int rhs ) const;
            void rotateWithLeftChild( AvlNode<Comparable> * & k2 ) const;
            void rotateWithRightChild( AvlNode<Comparable> * & k1 ) const;
            void doubleWithLeftChild( AvlNode<Comparable> * & k3 ) const;
            void doubleWithRightChild( AvlNode<Comparable> * & k1 ) const;
        };

        #include "AvlTree.cpp"
        #endif
TestAvlTree.cpp - Test program for AVL trees
	
	#include <iostream.h>
        #include "AvlTree.h"

            // Test program
        int main( )
        {
            const int ITEM_NOT_FOUND = -9999;
            AvlTree<int> t( ITEM_NOT_FOUND ), t2( ITEM_NOT_FOUND );
            int NUMS = 40000;
            const int GAP  =   37;
            int i;

            cout << "Checking... (no more output means success)" << endl;

            for( i = GAP; i != 0; i = ( i + GAP ) % NUMS )
                t.insert( i );

            if( NUMS < 40 )
                t.printTree( );
            if( t.findMin( ) != 1 || t.findMax( ) != NUMS - 1 )
                cout << "FindMin or FindMax error!" << endl;

            t2 = t;

            for( i = 1; i < NUMS; i++ )
                if( t2.find( i ) != i )
                    cout << "Find error1!" << endl;
            if( t2.find( 0 ) != ITEM_NOT_FOUND )
                cout << "ITEM_NOT_FOUND failed!" << endl;

            return 0;
    }
SeparateChaining.h - Header file for separate chaining
	
	#ifndef SEPARATE_CHAINING_H_
        #define SEPARATE_CHAINING_H_

        #include "vector.h"
        #include "mystring.h"
        #include "LinkedList.h"

        // SeparateChaining Hash table class
        //
        // CONSTRUCTION: an initialization for ITEM_NOT_FOUND
        //               and an approximate initial size or default of 101
        //
        // ******************PUBLIC OPERATIONS*********************
        // void insert( x )       --> Insert x
        // void remove( x )       --> Remove x
        // Hashable find( x )     --> Return item that matches x
        // void makeEmpty( )      --> Remove all items
        // int hash( string str, int tableSize )
        //                        --> Global method to hash strings

        template <class HashedObj>
        class HashTable
        {
          public:
            explicit HashTable( const HashedObj & notFound, int size = 101 );
            HashTable( const HashTable & rhs )
              : ITEM_NOT_FOUND( rhs.ITEM_NOT_FOUND ), theLists( rhs.theLists ) { }

            const HashedObj & find( const HashedObj & x ) const;

            void makeEmpty( );
            void insert( const HashedObj & x );
            void remove( const HashedObj & x );

            const HashTable & operator=( const HashTable & rhs );
          private:
            vector<List<HashedObj> > theLists;   // The array of Lists
            const HashedObj ITEM_NOT_FOUND;
        };

        int hash( const string & key, int tableSize );
        int hash( int key, int tableSize );

        #include "SeparateChaining.cpp"
        #endif
SeparateChaining.cpp - Implementation for separate chaining
	
	#include "SeparateChaining.h"
        #include <iostream.h>


        /**
         * Internal method to test if a positive number is prime.
         * Not an efficient algorithm.
         */
        bool isPrime( int n )
        {
            if( n == 2 || n == 3 )
                return true;

            if( n == 1 || n % 2 == 0 )
                return false;

            for( int i = 3; i * i <= n; i += 2 )
                if( n % i == 0 )
                    return false;

            return true;
        }

        /**
         * Internal method to return a prime number at least as large as n.
         * Assumes n > 0.
         */
        int nextPrime( int n )
        {
            if( n % 2 == 0 )
                n++;

            for( ; !isPrime( n ); n += 2 )
                ;

            return n;
        }

        /**
         * Construct the hash table.
         */
        template <class HashedObj>
        HashTable<HashedObj>::HashTable( const HashedObj & notFound, int size )
          : ITEM_NOT_FOUND( notFound ), theLists( nextPrime( size ) )
        {
        }

        /**
         * Insert item x into the hash table. If the item is
         * already present, then do nothing.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::insert( const HashedObj & x )
        {
            List<HashedObj> & whichList = theLists[ hash( x, theLists.size( ) ) ];
            ListItr<HashedObj> itr = whichList.find( x );

            if( itr.isPastEnd( ) )
                whichList.insert( x, whichList.zeroth( ) );
        }

        /**
         * Remove item x from the hash table.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::remove( const HashedObj & x )
        {
           theLists[ hash( x, theLists.size( ) ) ].remove( x );
        }

        /**
         * Find item x in the hash table.
         * Return the matching item or ITEM_NOT_FOUND if not found
         */
        template <class HashedObj>
        const HashedObj & HashTable<HashedObj>::find( const HashedObj & x ) const
        {
            ListItr<HashedObj> itr;
            itr = theLists[ hash( x, theLists.size( ) ) ].find( x );
            if( itr.isPastEnd( ) )
                return ITEM_NOT_FOUND;
            else
                return itr.retrieve( );
        }

        /**
         * Make the hash table logically empty.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::makeEmpty( )
        {
            for( int i = 0; i < theLists.size( ); i++ )
                theLists[ i ].makeEmpty( );
        }

        /**
         * Deep copy.
         */
        template <class HashedObj>
        const HashTable<HashedObj> &
        HashTable<HashedObj>::operator=( const HashTable<HashedObj> & rhs )
        {
            if( this != &rhs )
                theLists = rhs.theLists;
            return *this;
        }

        
        /**
         * A hash routine for string objects.
         */
        int hash( const string & key, int tableSize )
        {
            int hashVal = 0;

            for( int i = 0; i < key.length( ); i++ )
                hashVal = 37 * hashVal + key[ i ];

            hashVal %= tableSize;
            if( hashVal < 0 )
                hashVal += tableSize;

            return hashVal;
        }


        /**
         * A hash routine for ints.
         */
        int hash( int key, int tableSize )
        {
            if( key < 0 ) key = -key;
            return key % tableSize;
        }
SeparateChaining.cpp - Implementation for separate chaining
	
	#include "SeparateChaining.h"
        #include <iostream.h>


        /**
         * Internal method to test if a positive number is prime.
         * Not an efficient algorithm.
         */
        bool isPrime( int n )
        {
            if( n == 2 || n == 3 )
                return true;

            if( n == 1 || n % 2 == 0 )
                return false;

            for( int i = 3; i * i <= n; i += 2 )
                if( n % i == 0 )
                    return false;

            return true;
        }

        /**
         * Internal method to return a prime number at least as large as n.
         * Assumes n > 0.
         */
        int nextPrime( int n )
        {
            if( n % 2 == 0 )
                n++;

            for( ; !isPrime( n ); n += 2 )
                ;

            return n;
        }

        /**
         * Construct the hash table.
         */
        template <class HashedObj>
        HashTable<HashedObj>::HashTable( const HashedObj & notFound, int size )
          : ITEM_NOT_FOUND( notFound ), theLists( nextPrime( size ) )
        {
        }

        /**
         * Insert item x into the hash table. If the item is
         * already present, then do nothing.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::insert( const HashedObj & x )
        {
            List<HashedObj> & whichList = theLists[ hash( x, theLists.size( ) ) ];
            ListItr<HashedObj> itr = whichList.find( x );

            if( itr.isPastEnd( ) )
                whichList.insert( x, whichList.zeroth( ) );
        }

        /**
         * Remove item x from the hash table.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::remove( const HashedObj & x )
        {
           theLists[ hash( x, theLists.size( ) ) ].remove( x );
        }

        /**
         * Find item x in the hash table.
         * Return the matching item or ITEM_NOT_FOUND if not found
         */
        template <class HashedObj>
        const HashedObj & HashTable<HashedObj>::find( const HashedObj & x ) const
        {
            ListItr<HashedObj> itr;
            itr = theLists[ hash( x, theLists.size( ) ) ].find( x );
            if( itr.isPastEnd( ) )
                return ITEM_NOT_FOUND;
            else
                return itr.retrieve( );
        }

        /**
         * Make the hash table logically empty.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::makeEmpty( )
        {
            for( int i = 0; i < theLists.size( ); i++ )
                theLists[ i ].makeEmpty( );
        }

        /**
         * Deep copy.
         */
        template <class HashedObj>
        const HashTable<HashedObj> &
        HashTable<HashedObj>::operator=( const HashTable<HashedObj> & rhs )
        {
            if( this != &rhs )
                theLists = rhs.theLists;
            return *this;
        }

        
        /**
         * A hash routine for string objects.
         */
        int hash( const string & key, int tableSize )
        {
            int hashVal = 0;

            for( int i = 0; i < key.length( ); i++ )
                hashVal = 37 * hashVal + key[ i ];

            hashVal %= tableSize;
            if( hashVal < 0 )
                hashVal += tableSize;

            return hashVal;
        }


        /**
         * A hash routine for ints.
         */
        int hash( int key, int tableSize )
        {
            if( key < 0 ) key = -key;
            return key % tableSize;
        }
TestSeparateChaining.cpp - Test program for separate chaining hash tables
	
	#include <iostream.h>
        #include "SeparateChaining.h"

            // Simple main
        int main( )
        {
            int ITEM_NOT_FOUND = -9999;
            HashTable<int> H( ITEM_NOT_FOUND );

            const int NUMS = 4000;
            const int GAP  =   37;
            int i;

            cout << "Checking... (no more output means success)" << endl;

            for( i = GAP; i != 0; i = ( i + GAP ) % NUMS )
                H.insert( i );
            for( i = 1; i < NUMS; i += 2 )
                H.remove( i );

            for( i = 2; i < NUMS; i += 2 )
                if( H.find( i ) != i )
                    cout << "Find fails " << i << endl;

            for( i = 1; i < NUMS; i += 2 )
            {
                if( H.find( i ) != ITEM_NOT_FOUND )
                    cout << "OOPS!!! " <<  i << endl;
            }

            return 0;
        }
QuadraticProbing.h - Header file for quadratic probing hash table
	
	#ifndef QUADRATIC_PROBING_H_
        #define QUADRATIC_PROBING_H_

        #include "vector.h"
        #include "mystring.h"

        // QuadraticProbing Hash table class
        //
        // CONSTRUCTION: an initialization for ITEM_NOT_FOUND
        //               and an approximate initial size or default of 101
        //
        // ******************PUBLIC OPERATIONS*********************
        // void insert( x )       --> Insert x
        // void remove( x )       --> Remove x
        // Hashable find( x )     --> Return item that matches x
        // void makeEmpty( )      --> Remove all items

        template <class HashedObj>
        class HashTable
        {
          public:
            explicit HashTable( const HashedObj & notFound, int size = 101 );
            HashTable( const HashTable & rhs )
              : ITEM_NOT_FOUND( rhs.ITEM_NOT_FOUND ),
                array( rhs.array ), currentSize( rhs.currentSize ) { }

            const HashedObj & find( const HashedObj & x ) const;

            void makeEmpty( );
            void insert( const HashedObj & x );
            void remove( const HashedObj & x );

            const HashTable & operator=( const HashTable & rhs );

            enum EntryType { ACTIVE, EMPTY, DELETED };
          private:
            struct HashEntry
            {
                HashedObj element;
                EntryType info;

                HashEntry( const HashedObj & e = HashedObj( ), EntryType i = EMPTY )
                  : element( e ), info( i ) { }
            };
            
            vector<HashEntry> array;
            int currentSize;
            const HashedObj ITEM_NOT_FOUND;

            bool isActive( int currentPos ) const;
            int findPos( const HashedObj & x ) const;
            void rehash( );
        };

        int hash( const string & key, int tableSize );
        int hash( int key, int tableSize );

        #include "QuadraticProbing.cpp"
        #endif
QuadraticProbing.cpp - Implementation for quadratic probing hash table
	
	#include "QuadraticProbing.h"
        #include <iostream.h>


        /**
         * Internal method to test if a positive number is prime.
         * Not an efficient algorithm.
         */
        bool isPrime( int n )
        {
            if( n == 2 || n == 3 )
                return true;

            if( n == 1 || n % 2 == 0 )
                return false;

            for( int i = 3; i * i <= n; i += 2 )
                if( n % i == 0 )
                    return false;

            return true;
        }

        /**
         * Internal method to return a prime number at least as large as n.
         * Assumes n > 0.
         */
        int nextPrime( int n )
        {
            if( n % 2 == 0 )
                n++;

            for( ; !isPrime( n ); n += 2 )
                ;

            return n;
        }

        /**
         * Construct the hash table.
         */
        template <class HashedObj>
        HashTable<HashedObj>::HashTable( const HashedObj & notFound, int size )
          : ITEM_NOT_FOUND( notFound ), array( nextPrime( size ) )
        {
            makeEmpty( );
        }

        /**
         * Insert item x into the hash table. If the item is
         * already present, then do nothing.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::insert( const HashedObj & x )
        {
                // Insert x as active
            int currentPos = findPos( x );
            if( isActive( currentPos ) )
                return;
            array[ currentPos ] = HashEntry( x, ACTIVE );

                // Rehash; see Section 5.5
            if( ++currentSize > array.size( ) / 2 )
                rehash( );
        }

        /**
         * Expand the hash table.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::rehash( )
        {
            vector<HashEntry> oldArray = array;

                // Create new double-sized, empty table
            array.resize( nextPrime( 2 * oldArray.size( ) ) );
            for( int j = 0; j < array.size( ); j++ )
                array[ j ].info = EMPTY;

                // Copy table over
            currentSize = 0;
            for( int i = 0; i < oldArray.size( ); i++ )
                if( oldArray[ i ].info == ACTIVE )
                    insert( oldArray[ i ].element );
        }

        /**
         * Method that performs quadratic probing resolution.
         * Return the position where the search for x terminates.
         */
        template <class HashedObj>
        int HashTable<HashedObj>::findPos( const HashedObj & x ) const
        {
/* 1*/      int collisionNum = 0;
/* 2*/      int currentPos = hash( x, array.size( ) );

/* 3*/      while( array[ currentPos ].info != EMPTY &&
                   array[ currentPos ].element != x )
            {
/* 4*/          currentPos += 2 * ++collisionNum - 1;  // Compute ith probe
/* 5*/          if( currentPos >= array.size( ) )
/* 6*/              currentPos -= array.size( );
            }

/* 7*/      return currentPos;
        }


        /**
         * Remove item x from the hash table.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::remove( const HashedObj & x )
        {
            int currentPos = findPos( x );
            if( isActive( currentPos ) )
                array[ currentPos ].info = DELETED;
        }

        /**
         * Find item x in the hash table.
         * Return the matching item or ITEM_NOT_FOUND if not found
         */
        template <class HashedObj>
        const HashedObj & HashTable<HashedObj>::find( const HashedObj & x ) const
        {
            int currentPos = findPos( x );
            if( isActive( currentPos ) )
                return array[ currentPos ].element;
            else
                return ITEM_NOT_FOUND;
        }

        /**
         * Make the hash table logically empty.
         */
        template <class HashedObj>
        void HashTable<HashedObj>::makeEmpty( )
        {
            currentSize = 0;
            for( int i = 0; i < array.size( ); i++ )
                array[ i ].info = EMPTY;
        }

        /**
         * Deep copy.
         */
        template <class HashedObj>
        const HashTable<HashedObj> & HashTable<HashedObj>::
        operator=( const HashTable<HashedObj> & rhs )
        {
            if( this != &rhs )
            {
                array = rhs.array;
                currentSize = rhs.currentSize;
            }
            return *this;
        }


        /**
         * Return true if currentPos exists and is active.
         */
        template <class HashedObj>
        bool HashTable<HashedObj>::isActive( int currentPos ) const
        {
            return array[ currentPos ].info == ACTIVE;
        }

        /**
         * A hash routine for string objects.
         */
        int hash( const string & key, int tableSize )
        {
            int hashVal = 0;

            for( int i = 0; i < key.length( ); i++ )
                hashVal = 37 * hashVal + key[ i ];

            hashVal %= tableSize;
            if( hashVal < 0 )
                hashVal += tableSize;

            return hashVal;
        }


        /**
         * A hash routine for ints.
         */
        int hash( int key, int tableSize )
        {
            if( key < 0 ) key = -key;
            return key % tableSize;
        }
TestQuadraticProbing.cpp - Test program for quadratic probing hash tables
	
	#include <iostream.h>
        #include "QuadraticProbing.h"

            // Simple main
        int main( )
        {
            int ITEM_NOT_FOUND = -9999;
            HashTable<int> H( ITEM_NOT_FOUND );

            const int NUMS = 4000;
            const int GAP  =   37;
            int i;

            cout << "Checking... (no more output means success)" << endl;

            for( i = GAP; i != 0; i = ( i + GAP ) % NUMS )
                H.insert( i );
            for( i = 1; i < NUMS; i += 2 )
                H.remove( i );

            for( i = 2; i < NUMS; i +=2 )
                if( H.find( i ) != i )
                    cout << "Find fails " << i << endl;

            for( i = 1; i < NUMS; i += 2 )
            {
                if( H.find( i ) != ITEM_NOT_FOUND )
                    cout << "OOPS!!! " <<  i << endl;
            }

            return 0;
        }


